[
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html",
    "title": "Data Types, Operators, and Expressions",
    "section": "",
    "text": "Python Data Types\nEverything in Python is an object.\nWhen we say ‘type,’ we mean object type.\nData types and data structures are both types of object.\nData types and structures are created by the way they are written.\nWhen we write the raw values of a data type, we call these literals, meaning their literal value.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#integers",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#integers",
    "title": "Data Types, Operators, and Expressions",
    "section": "Integers",
    "text": "Integers\nAn integer is a sequence of one or more unquoted roman numerals.\n\n100\n\n100\n\n\n\n643523453323\n\n643523453323\n\n\n\n-0\n\n0",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#floats-decimals",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#floats-decimals",
    "title": "Data Types, Operators, and Expressions",
    "section": "Floats (decimals)",
    "text": "Floats (decimals)\nA float is a sequence of unquoted numerals with one and only one period.\n\n3.14 \n\n3.14\n\n\nNote that a period as a suffix or prefix will convert an integer to a float.\n\n1, 1., .1\n\n(1, 1.0, 0.1)\n\n\nNote also that we are separating these numbers with commas.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#strings",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#strings",
    "title": "Data Types, Operators, and Expressions",
    "section": "Strings",
    "text": "Strings\nStrings are sequences of quoted characters of any kind, i.e. numbers, letters, punctuation, etc.\nQuotes may be be single ' or double\".\nThe type of quote does not matter, but they must be straight quotes, not so-called “smart quotes” that some word processors use.\n\n\"foo\" \n\n'foo'\n\n\n\n\"1\"\n\n'1'\n\n\n\n'foo'\n\n'foo'\n\n\nNote how Python’s internal representation of a string uses single quotes.\nNote also that there is no explicit character type as in Java and other languages.\nSome languages, such as Java and C, reserve a data type for single characters and create strings by putting these types into an array or some other data structure.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#booleans",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#booleans",
    "title": "Data Types, Operators, and Expressions",
    "section": "Booleans",
    "text": "Booleans\nBoolean values are represented by the following unquoted reserved words:\n\nTrue, False\n\n(True, False)\n\n\nNote that these are case-sensitive. The following will not work:\n\nTRUE\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n/tmp/ipykernel_742001/3320712247.py in &lt;module&gt;\n----&gt; 1 TRUE\n\nNameError: name 'TRUE' is not defined\n\n\n\n\nfalse",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#nothing",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#nothing",
    "title": "Data Types, Operators, and Expressions",
    "section": "Nothing",
    "text": "Nothing\nPython has a reserved data type for situations where there is no value to represent.\nIt evaluates to nothing!\n\nNone\n\n\nprint(None)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#complex-numbers",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#complex-numbers",
    "title": "Data Types, Operators, and Expressions",
    "section": "Complex numbers",
    "text": "Complex numbers\nComplex numbers are created by combining imaginary numbers with other numbers.\nImaginary numbers are floats or integers with a j suffix.\n\n5 + 0j\n\n\n5.0 / 100 + .1j\n\n\n5.0 ** .1j",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#int",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#int",
    "title": "Data Types, Operators, and Expressions",
    "section": "int()",
    "text": "int()\nThis converts a number or string into an integer where it makes sense to do so.\nFloat to Int\n\nval = 3.8\nval, type(val)\n\n\nval_int = int(val)\nval_int, type(val_int)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#float",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#float",
    "title": "Data Types, Operators, and Expressions",
    "section": "float()",
    "text": "float()\nThis converts a string or integer into a float.\nString to Float\n\nval_str = '3.8'\nval_str, type(val)\n\n\nval_int = float(val_str)\nval_int, type(val_int)\n\nNote that converting string decimal to integer will fail.\n\nval_int = int(val_str)\nval_int, type(val_int)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#ord",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#ord",
    "title": "Data Types, Operators, and Expressions",
    "section": "ord()",
    "text": "ord()\nThis converts a character to it’s code point.\nA code point is the internal number associated with each character in the character set used by Python.\nThe character set is called Unicode.\n\nord('a'), ord('A')",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#floor-division",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#floor-division",
    "title": "Data Types, Operators, and Expressions",
    "section": "floor division //",
    "text": "floor division //\nReturns the result of a divions without the remainder.\n\n5 // 2\n\n\n-5 // 2\n\n\n5.5 // 2\n\nNote the data types of the returned values.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#modulus",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#modulus",
    "title": "Data Types, Operators, and Expressions",
    "section": "modulus %",
    "text": "modulus %\nReturns the remainder\n\n5 % 2\n\nodd integers % 2 = 1\neven integers % 2 = 0\nLook at this …\n\n5.5 / 2, 5.5 // 2, 5.5 % 2",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#exponentiation",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#exponentiation",
    "title": "Data Types, Operators, and Expressions",
    "section": "exponentiation **",
    "text": "exponentiation **\nRaises one number to the power of another.\n\n5**3",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#concatenation",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#concatenation",
    "title": "Data Types, Operators, and Expressions",
    "section": "concatenation +",
    "text": "concatenation +\nWhen used with strings, the plus operator joins strings into larger strings.\nThe plus sign is an overloaded operator in Python.\n\nmy_string = 'This: '\n\n\nmy_2nd_string = my_string + ' Hello, world!'\n\n\nmy_2nd_string",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#repetition",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#repetition",
    "title": "Data Types, Operators, and Expressions",
    "section": "repetition *",
    "text": "repetition *\nThis joins a string to itself as many times as specified.\n\nprint('-' * 80)\n\n\nbart_S1E3 = 'I will not skateboard in the halls'\n\n\nprint((bart_S1E3 + '\\n') * 5)\n\n\n\n\nimage.png\n\n\nSee them all :-)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#equality",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#equality",
    "title": "Data Types, Operators, and Expressions",
    "section": "equality ==",
    "text": "equality ==\n\n0 == (10 % 5)\n\n\n'Boo' == 'Hoo'",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#greater-than-and-less-than",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#greater-than-and-less-than",
    "title": "Data Types, Operators, and Expressions",
    "section": "greater than and less than",
    "text": "greater than and less than\n&gt;, &lt;, &gt;=, and &lt;=\n\n10 &lt; 5, 5. &lt; 100 - 90\n\nNote that we can compare strings, too:\n\n'A' + 'B' == 'AB'\n\n\n'A' &lt; 'B'\n\nWe can compare relative magnitude because we are comparing their code points:\n\nord('A'), ord('B')\n\nWatch out when comparing floats, though!\nThis works:\n\n.5 == 1/2\n\nBut this does not:\n\nx = 0.1 + 0.2\ny = 0.3\n\n\nx == y\n\nThis is because the two values are represented differently internally:\n\nx, y\n\nYou can overcome this by rounding both values, like so:\n\nround(x, 2) == round(y, 2)\n\nBut note this fails:\n\nround(x, 20) == round(y, 20), round(x, 20), round(y, 20)\n\nThis is because of how Python (and computers in general) handle floating point numbers.\nThe best soluation is to do this:\n\nimport math\n\nmath.isclose(x, y)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#inequality",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#inequality",
    "title": "Data Types, Operators, and Expressions",
    "section": "inequality !=",
    "text": "inequality !=\n\n5/9 != 0.5555",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#conjunctions-and-or-not",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#conjunctions-and-or-not",
    "title": "Data Types, Operators, and Expressions",
    "section": "Conjunctions and, or, not",
    "text": "Conjunctions and, or, not\nNote the we group comparisons with parentheses.\n\nx = 10\n\n(x % 10 == 0) or (x &lt; -1)\n\n\n(x % 10 == 0) and (x &lt; -1)\n\n\nnot x == 5",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#identity-is",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#identity-is",
    "title": "Data Types, Operators, and Expressions",
    "section": "Identity is",
    "text": "Identity is\nThe is keyword tests if two variables refer to the same object.\nDepending on object types involved, variable can sometimes point to the same object when we assign one variable to another.\nThe test returns True if the two objects are the same object and False if they are not.\nUse the == operator to test if two variables store equal values.\nis\n\nx = 'foo'\ny = 'foo'\nz = 'bar'\n\n\nx is y, x is z",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-01-DataTypes.html#negation-not",
    "href": "notebooks/M02_BasicPython/M02-01-DataTypes.html#negation-not",
    "title": "Data Types, Operators, and Expressions",
    "section": "Negation not",
    "text": "Negation not\nnot flips the value of a boolean.\n\nnot True, not False, not 0, not 1, not 1000, not None\n\nis not tests if two variables do not point to the same object.\n\nx is not y, x is not z",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Types, Operators, and Expressions</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html",
    "title": "Numbers",
    "section": "",
    "text": "Built-in Functions\nPython has many built-in mathematical functions for numbers.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#pow-power",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#pow-power",
    "title": "Numbers",
    "section": "pow() Power",
    "text": "pow() Power\n\\(2\\) raised to \\(3 = 8\\)\n\npow(2,3)\n\n8",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#abs-absolute-value",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#abs-absolute-value",
    "title": "Numbers",
    "section": "abs() Absolute value",
    "text": "abs() Absolute value\nReturns \\(2\\), the absolute value of its argument.\n\nabs(-2)\n\n2",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#round-round",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#round-round",
    "title": "Numbers",
    "section": "round() Round",
    "text": "round() Round\nRounding up or down its argument (to closest whole number).\nRounds up to \\(3.0\\).\n\nround(2.8)\n\n3\n\n\nRounds down to \\(1.0\\).\n\nround(1.1)\n\n1\n\n\nYou can specify how many decimal places to round to as well.\n\nround(5.36958211, 2)\n\n5.37",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#math.sqrt-square-root",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#math.sqrt-square-root",
    "title": "Numbers",
    "section": "math.sqrt() Square root",
    "text": "math.sqrt() Square root\n\nmath.sqrt(12)\n\n3.4641016151377544\n\n\n\nprint(math.floor(2.5)) # returns largest whole number less than the argument\nprint(math.floor(2.9))\nprint(math.floor(2.1))\n\n2\n2\n2",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#math.log",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#math.log",
    "title": "Numbers",
    "section": "math.log()",
    "text": "math.log()\n\nmath.log(100, 10)\n\n2.0\n\n\n\nmath.log(256, 2)\n\n8.0",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#random.random",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#random.random",
    "title": "Numbers",
    "section": "random.random()",
    "text": "random.random()\nUsing random() will return a number between \\(0\\) and \\(1\\).\n\nprint(random.random())\n\n0.605894272418689",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-02-Numbers.html#random.randint",
    "href": "notebooks/M02_BasicPython/M02-02-Numbers.html#random.randint",
    "title": "Numbers",
    "section": "random.randint()",
    "text": "random.randint()\nWe may specify a range in the parentheses.\nThis will return a random integer in the range \\(1\\) to \\(100\\) inclusive.\n\nprint(random.randint(1,100))\n\n18",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Numbers</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-03-Booleans.html",
    "href": "notebooks/M02_BasicPython/M02-03-Booleans.html",
    "title": "Booleans",
    "section": "",
    "text": "Programming for Data Science\nA boolean value takes one of True or False, which are built-in values\ncheck if cache is True, using if statement\nif statement using a bool evaluates to True or False\n\ncache = True\n\nif cache:\n   print('data will be cached')\n\ndata will be cached\n\n\n\nprint(type(cache))\n\n&lt;class 'bool'&gt;\n\n\nBooleans are frequently used in if/then statements.\nWe’ll cover these later.\n\ncache = True\noome = False\n\nif cache or oome:\n    print('condition met!')\nelse:\n    print(\"No dice.\")\n\nAND statements will short circuit if an early condition fails.\n\nif oome and cache:\n    print('condition met!')\n\nIn this case, since oome is False, the check on cache never happens.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Booleans</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html",
    "title": "Strings",
    "section": "",
    "text": "Strings\nStrings are sequences of characters.\nCharacters are member of character sets. Python uses the Unicode character set.\nPython does not have a data type for individual characters, though, as some languages do.\nInstead, a string is an object type that is similar to a list, which we will cover soon.\nPython makes it easy to manipulate string in complex ways.\nThis is very useful for data wrangling tasks such as web scraping and converting unstructured text files into structured data sets.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#escape-characters",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#escape-characters",
    "title": "Strings",
    "section": "Escape Characters",
    "text": "Escape Characters\nPython supports special “escape characters” within quoted strings that produce effects when printed.\nThese are characters prefixed with a backslash \\.\n\\\\     Backslash (\\)\n\\'     Single quote (')\n\\\"     Double quote (\")\n\\n     Line break\n\\t     Tab\nNote that these escape characters are not unique to Python. They are part of almost all languages.\nHere is a string with the tab character \\t:\n\n\"Hello,\\tWorld! (With a tab character)\"\n\n'Hello,\\tWorld! (With a tab character)'\n\n\nHere is the string interpreted by print():\n\nprint(\"Hello,\\tWorld! (With a tab character)\")\n\nHello,  World! (With a tab character)\n\n\nHere we insert the new line character \\n:\n\nprint(\"Line one\\nLine two, with newline character\")\n\nLine one\nLine two, with newline character\n\n\nRemember that to concatenate strings, you may use the plus sign +:\n\nprint(\"Concatenation,\" + \"\\t\" + \"in strings with tab in middle\")\n\nConcatenation,  in strings with tab in middle",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#quotes-in-quotes",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#quotes-in-quotes",
    "title": "Strings",
    "section": "Quotes in Quotes",
    "text": "Quotes in Quotes\nIf you wanted to print quotes in a string, you can alternate singles and doubles:\n\nprint('Printing \"quotes\" within a string')\n\nPrinting \"quotes\" within a string\n\n\n\nprint(\"Printing 'quotes' within a string\")\n\nPrinting 'quotes' within a string\n\n\nOr you can escape the qoute:\n\nprint(\"Printing \\\"quotes\\\" within a string\")\n\nPrinting \"quotes\" within a string",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#spaces",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#spaces",
    "title": "Strings",
    "section": "Spaces",
    "text": "Spaces\nBy default, the print function puts spaces between strings and a newline at the end, but you can change that:\n\nprint(\"This\", \"is\", \"a\", \"sentence\")\n\nThis is a sentence\n\n\n\nprint(\"This\", \"is\", \"a\", \"sentence\", sep=\"|\")\n\nThis|is|a|sentence\n\n\n\nprint(\"This\", \"is\", \"a\", \"sentence\", end=\" -- \")\nprint(\"This\", \"is\", \"a\", \"sentence\")\n\nThis is a sentence -- This is a sentence",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#f-strings",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#f-strings",
    "title": "Strings",
    "section": "f strings",
    "text": "f strings\nPrefixing a string with f (for ‘formatted’) allows variable interpolation — inplace evaluation of variables in strings.\n\npeople = 'knights'\ngreeting = 'Ni'\n\n\nprint(f'We are the {people} who say {greeting}!')\n\nWe are the knights who say Ni!\n\n\nThe brackets and characters within them (called format fields) are replaced with the passed objects.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#r-strings",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#r-strings",
    "title": "Strings",
    "section": "r strings",
    "text": "r strings\nPrefixing a string with r (for ‘raw’) causes escape characters to be uninterpreted.\n\nprint(\"Sentence one.\\nSentence two.\")\n\nSentence one.\nSentence two.\n\n\n\nprint(r\"Sentence one.\\nSentence two.\")\n\nSentence one.\\nSentence two.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#lower-.upper",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#lower-.upper",
    "title": "Strings",
    "section": ".lower(), .upper()",
    "text": ".lower(), .upper()\nThese will conver the case of a string.\n\n'BOB'.lower()\n\n'bob'\n\n\n\n'carlos'.upper()\n\n'CARLOS'",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#split",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#split",
    "title": "Strings",
    "section": ".split()",
    "text": ".split()\nThis will parse a string based on a delimiter, which defaults to whitespace.\nNOTE: This does not use regular expressions.\nThis returns a list.\n\nmonty_python_quote = 'are.you.suggesting.coconuts.migrate'\n\n\nmonty_python_quote\n\n'are.you.suggesting.coconuts.migrate'\n\n\n\nmonty_python_quote.split('.') \n\n['are', 'you', 'suggesting', 'coconuts', 'migrate']\n\n\nNote that literal strings behave like objects.\n\n'are.you.suggesting.coconuts.migrate'.split('.')\n\n['are', 'you', 'suggesting', 'coconuts', 'migrate']",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#strip-.rstrip-lstrip-strip-methods",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#strip-.rstrip-lstrip-strip-methods",
    "title": "Strings",
    "section": ".strip(), .rstrip(), lstrip() Strip methods",
    "text": ".strip(), .rstrip(), lstrip() Strip methods\nYou remove extra whitespace from strings using strip(), rstrip() and lstrip().\nWhitespace characters are characters that are used for spacing.\nThese include newlines, spaces, tabs, carriage returns, feed, etc.\n.strip() removes white space from anywhere in a string.\n.rstrip() only removes white space from the right-hand-side of the string.\n.lstrip() only removes white space from the left-hand-side of the string.\n\nstr1 = '  hello, world!'    # white space at the beginning\nstr2 = '  hello, world!  '  # white space at both ends\nstr3 = 'hello, world!  '    # white space at the end\n\n\nstr1, str2, str3\n\n('  hello, world!', '  hello, world!  ', 'hello, world!  ')\n\n\n\nstr1.lstrip(), str1.rstrip()\n\n('hello, world!', '  hello, world!')\n\n\n\nstr2.strip(), str2.rstrip()\n\n('hello, world!', '  hello, world!')\n\n\n\nstr2.lstrip(), str3.rstrip()\n\n('hello, world!  ', 'hello, world!')",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#startswith",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#startswith",
    "title": "Strings",
    "section": ".startswith()",
    "text": ".startswith()\nThis lets you see if a string starts with a character or a string.\n\nstatus = 'success'\n\n\nstatus.startswith('a')\n\nFalse\n\n\n\nstatus.endswith('s')\n\nTrue\n\n\n\nstatus.endswith('ss')\n\nTrue",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#replace",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#replace",
    "title": "Strings",
    "section": ".replace()",
    "text": ".replace()\nThis lets you swap out characters or strings.\n\n\"latina\".replace(\"a\", \"x\")\n\n'lxtinx'\n\n\n\n\"good night\".replace(\"night\", \"day\")\n\n'good day'",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#format",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#format",
    "title": "Strings",
    "section": ".format()",
    "text": ".format()\nInstead of using the f string prefix, you can use the format method to embed variables in strings.\nPlace {} in the string in order from left to right. followed by .format(var1, var2, ...)`\n\nepoch = 20\nloss = 1.55\nprint('Epoch: {}, loss: {}'.format(epoch, loss))\n\nEpoch: 20, loss: 1.55\n\n\nThis breaks, as three variables are required based on number of {}\n\nprint('Epoch: {}, loop: {}, loss: {}'.format(epoch, loss))\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[40], line 1\n----&gt; 1 print('Epoch: {}, loop: {}, loss: {}'.format(epoch, loss))\n\nIndexError: Replacement index 2 out of range for positional args tuple",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-04-Strings.html#zfill",
    "href": "notebooks/M02_BasicPython/M02-04-Strings.html#zfill",
    "title": "Strings",
    "section": ".zfill()",
    "text": ".zfill()\nUse this method to pad strings with zeros, which is useful for printing out data sets in raw text form.\n\nprint('12'.zfill(5))       \nprint('3.14'.zfill(7))    \nprint('-3.14'.zfill(7))    \nprint('3.141592'.zfill(3)) # Will not truncate\n\n00012\n0003.14\n-003.14\n3.141592",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html",
    "title": "Data Structures",
    "section": "",
    "text": "Lists\nA list is an ordered sequence of items.\nEach element of a list is associated with an integer that represents the order in which the element appears.\nLists are indexed with brackets [].\nList elements are accessed by providing their order number in the brackets.\nLists are mutable, meaning you can modify them after they have been created.\nThey can contain mixed types.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors",
    "title": "Data Structures",
    "section": "Constructors",
    "text": "Constructors\nThey can be constructed in several ways:\n\nlist1 = []\nlist2 = list()\nlist3 = \"some string\".split()\nnumbers = [1,2,3,4]",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#indexing",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#indexing",
    "title": "Data Structures",
    "section": "Indexing",
    "text": "Indexing\nIndexing refers to how each element in a list is identified and addressed.\nPython has what is called zero-based indexing.\nThis means that for a list mylist,\n\nmylist[0] references the first element.\nmylist[1] references the second element, etc.\n\nFor any list of length \\(N\\):\n\nmylist[:n] will return the first \\(n\\) elements from index \\(0\\) to \\(n-1\\).\n\nmylist[-n:] will return the last \\(n\\) elements from index \\(N - n\\) to \\(N - 1\\).\n\nLet’s llok at an example.\nHere we access first element of numbers:\n\nnumbers\n\n[1, 2, 3, 4]\n\n\n\nnumbers[0]\n\n1\n\n\nAnd here we accesst the last element:\n\nnumbers[-1]\n\n4\n\n\nNote that the elements of a list are values that can be treated like individual variables:\n\nnumbers[0] + numbers[3]\n\n5\n\n\n\ntype(numbers), type(numbers[0])\n\n(list, int)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#slicing",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#slicing",
    "title": "Data Structures",
    "section": "Slicing",
    "text": "Slicing\nSlicing refers to the process of getting a sublist from a list.\nTo do this, we use a colon : like so:\n\nnumbers[0:2]\n\n[1, 2]\n\n\n\nnumbers[1:3]\n\n[2, 3]\n\n\n\nnumbers[2:]\n\n[3, 4]",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#multiply-lists-by-a-scalar",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#multiply-lists-by-a-scalar",
    "title": "Data Structures",
    "section": "Multiply lists by a scalar",
    "text": "Multiply lists by a scalar\nA scalar is a single value number.\n\nnumbers * 2\n\n[1, 2, 3, 4, 1, 2, 3, 4]",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#concatenate-lists-with",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#concatenate-lists-with",
    "title": "Data Structures",
    "section": "Concatenate lists with +",
    "text": "Concatenate lists with +\n\nnumbers2 = [30, 40, 50]\n\n\nnumbers + numbers2\n\n[1, 2, 3, 4, 30, 40, 50]",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#lists-can-mix-types",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#lists-can-mix-types",
    "title": "Data Structures",
    "section": "Lists can mix types",
    "text": "Lists can mix types\n\nmyList = ['coconuts', 777, 7.25, 'Sir Robin', 80.0, True]\n\n\nmyList\n\n['coconuts', 777, 7.25, 'Sir Robin', 80.0, True]\n\n\nWhat happens if we multiply a list with strings?\n\nmyList * 2\n\n['coconuts',\n 777,\n 7.25,\n 'Sir Robin',\n 80.0,\n True,\n 'coconuts',\n 777,\n 7.25,\n 'Sir Robin',\n 80.0,\n True]",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#lists-can-be-nested",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#lists-can-be-nested",
    "title": "Data Structures",
    "section": "Lists can be nested",
    "text": "Lists can be nested\n\nnames = ['Darrell', 'Clayton', ['Billie', 'Arthur'], 'Samantha']\n\n\n  names[0]\n\n'Darrell'\n\n\n\nnames[2]\n\n['Billie', 'Arthur']\n\n\n\nnames[2][0]\n\n'Billie'",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#len-length",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#len-length",
    "title": "Data Structures",
    "section": "len() Length",
    "text": "len() Length\nThis is built-in length funciton tells us how many characters in the string.\nIt also applys to any list-like object, including strings, lists, dicts, sets, and dataframes.\n\nmy_new_tring = 'This is a string'\n\n\nlen(my_new_tring)\n\n16",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#indexing-1",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#indexing-1",
    "title": "Data Structures",
    "section": "Indexing",
    "text": "Indexing\nSince strings are sequences in Python, each character of the string has a unique position that can be indexed.\nIndexes are indicated by suffixed brackets, e.g. foo[]\nThis displays the first character of the string.\n\nmy_new_tring[0]\n\n'T'\n\n\nThis displays the last character. Negatives count backwords.\n\nmy_new_tring[-1]\n\n'g'",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#slicing-1",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#slicing-1",
    "title": "Data Structures",
    "section": "Slicing",
    "text": "Slicing\nWe can used the colon to ‘slice’ strings (and lists)\nThe first four characters, i.e. index positions \\(0\\) to \\(3\\).\n\nmy_new_tring[0:4]\n\n'This'\n\n\nThe same thing; \\(0\\) is implied.\n\nmy_new_tring[:4]\n\n'This'\n\n\nThe fifth character and onwards until the end of the string.\n\nmy_new_tring[4:]\n\n' is a string'\n\n\nNote that it is not possible to re-assign elements of a string.\nThis is because Python strings are immutable.\n\nmy_new_tring[0] = 't'\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[78], line 1\n----&gt; 1 my_new_tring[0] = 't'\n\nTypeError: 'str' object does not support item assignment",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors-1",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors-1",
    "title": "Data Structures",
    "section": "Constructors",
    "text": "Constructors\nA list may be constructed by putting a sequence of colon-delimitted key/value pairs within a pair of braces:\n\ndict1 = {\n    'a': 1,\n    'b': 2,\n    'c': 3\n}\n\nOr we may call the dict() function:\n\ndict2 = dict(x=55, y=29, z=99)\n\nNote the absence of quotes around keys.\n\ndict2\n\n{'x': 55, 'y': 29, 'z': 99}\n\n\nHere we demonstrate the keys can be strings, numbers, or tuples:\n\ndict3 = {'A': 'foo', 99: 'bar', (1,2): 'baz'}\n\n\ndict3\n\n{'A': 'foo', 99: 'bar', (1, 2): 'baz'}\n\n\nNote that values can be anything, just like the elements of a list.\n\ndict4 = {'a': 1, 'b': dict3}\n\n\ndict4\n\n{'a': 1, 'b': {'A': 'foo', 99: 'bar', (1, 2): 'baz'}}",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#retrieving-a-value",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#retrieving-a-value",
    "title": "Data Structures",
    "section": "Retrieving a value",
    "text": "Retrieving a value\nJust use a key as the index.\n\nphonelist = {'Tom':123, 'Bob':456, 'Sam':897}\n\n\nphonelist['Bob']\n\n456\n\n\nGetting a list of keys, values, or both.\nUse the .keys(), .values(), or .items() methods.\n\nphonelist.keys()\n\ndict_keys(['Tom', 'Bob', 'Sam'])\n\n\n\nphonelist.values()\n\ndict_values([123, 456, 897])\n\n\n\nphonelist.items()\n\ndict_items([('Tom', 123), ('Bob', 456), ('Sam', 897)])\n\n\n\nphonelist\n\n{'Tom': 123, 'Bob': 456, 'Sam': 897}",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors-2",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors-2",
    "title": "Data Structures",
    "section": "Constructors",
    "text": "Constructors\nTuples may be created with comma-separated values, with or without parenthesis.\n\nletters = 'a', 'b', 'c', 'd'\n\n\nletters\n\n('a', 'b', 'c', 'd')\n\n\n\nnumbers = (1, 2, 3, 4)\n\n\nnumbers\n\n(1, 2, 3, 4)\n\n\n\nlen(numbers)\n\n4\n\n\nA single valued tuple must include a comma ,.\nOtherwise, Python will interpret it as a simple expression.\n\ntuple0 = (29)\n\n\ntuple0, type(tuple0)\n\n(29, int)\n\n\n\ntuple1 = (29,)\n\n\ntuple1, type(tuple1)\n\n((29,), tuple)\n\n\nYou can’t re-assign a value to a tuple element.\nThey are immutable.\n\ntuple1[0] = 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[95], line 1\n----&gt; 1 tuple1[0] = 5\n\nTypeError: 'tuple' object does not support item assignment",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#len",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#len",
    "title": "Data Structures",
    "section": "len()",
    "text": "len()\n\nlen(numbers), len(tuple1), len(dict1)\n\n(4, 1, 3)",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#membership-with-in",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#membership-with-in",
    "title": "Data Structures",
    "section": "Membership with in",
    "text": "Membership with in\n\n'Sam' in phonelist\n\nTrue",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors-3",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#constructors-3",
    "title": "Data Structures",
    "section": "Constructors",
    "text": "Constructors\nLike dictionaries, sets are constructed with braces {}, but unlike dictionaries elements are not key value pairs separated by a colon :.\n\npeanuts = {'snoopy','snoopy','woodstock'}\n\n\npeanuts\n\n{'snoopy', 'woodstock'}\n\n\nNote the set is “de-duped.”\nSets also don’t have an index. This will break:\n\npeanuts[0]\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[98], line 1\n----&gt; 1 peanuts[0]\n\nTypeError: 'set' object is not subscriptable\n\n\n\nYou can check if a value is in the set using in:\n\n'snoopy' in peanuts\n\nTrue",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#set-operations",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#set-operations",
    "title": "Data Structures",
    "section": "Set operations",
    "text": "Set operations\nTo combine two set sets is to get their union:\n\nset1 = {'python','R'}\nset2 = {'R','SQL'}\n\n\nset1.union(set2)\n\n{'R', 'SQL', 'python'}\n\n\nNote that the + operator is not overloaded in this case.\nThis fails:\n\nset1 + set2\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[45], line 1\n----&gt; 1 set1 + set2\n\nTypeError: unsupported operand type(s) for +: 'set' and 'set'\n\n\n\nTo get the set intersection, do this:\n\nset1.intersection(set2)\n\n{'R'}\n\n\nAnd the difference, i.e. removing from one set the shared elements in another set:\n\nset1.difference(set2)\n\n{'python'}\n\n\n\nset2.difference(set1)\n\n{'SQL'}\n\n\nInterestingly, the - operator is overloaded to compute the difference:\n\nset1 - set2\n\n{'python'}\n\n\n\nset2 - set1\n\n{'SQL'}",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#try-with-dict",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#try-with-dict",
    "title": "Data Structures",
    "section": "Try with dict",
    "text": "Try with dict\n\nwords = {}\nfor word in source_data:\n    words[word] += 1\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[58], line 3\n      1 words = {}\n      2 for word in source_data:\n----&gt; 3     words[word] += 1\n\nKeyError: 'Lorem'",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#use-try-and-except",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#use-try-and-except",
    "title": "Data Structures",
    "section": "Use try and except",
    "text": "Use try and except\nThis is how we “trap” errors.\nWe’ll cover this later in the course.\n\nfor word in source_data:\n    try:\n        words[word] += 1\n    except KeyError:\n        words[word] = 1\n\n\nprint(words)\n\n{'Lorem': 8, 'Ipsum': 6, 'is': 2, 'simply': 2, 'dummy': 4, 'text': 4, 'of': 8, 'the': 12, 'printing': 2, 'and': 6, 'typesetting': 2, 'industry.': 2, 'has': 4, 'been': 2, \"industry's\": 2, 'standard': 2, 'ever': 2, 'since': 2, '1500s,': 2, 'when': 2, 'an': 2, 'unknown': 2, 'printer': 2, 'took': 2, 'a': 4, 'galley': 2, 'type': 4, 'scrambled': 2, 'it': 2, 'to': 2, 'make': 2, 'specimen': 2, 'book.': 2, 'It': 4, 'survived': 2, 'not': 2, 'only': 2, 'five': 2, 'centuries,': 2, 'but': 2, 'also': 2, 'leap': 2, 'into': 2, 'electronic': 2, 'typesetting,': 2, 'remaining': 2, 'essentially': 2, 'unchanged.': 2, 'was': 2, 'popularised': 2, 'in': 2, '1960s': 2, 'with': 4, 'release': 2, 'Letraset': 2, 'sheets': 2, 'containing': 2, 'passages,': 2, 'more': 2, 'recently': 2, 'desktop': 2, 'publishing': 2, 'software': 2, 'like': 2, 'Aldus': 2, 'PageMaker': 2, 'including': 2, 'versions': 2, 'Ipsum.': 2}",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#use-.get",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#use-.get",
    "title": "Data Structures",
    "section": "Use .get()",
    "text": "Use .get()\n\nfor word in source_data:\n    words[word] = words.get(word, 0) + 1",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-05-Structures.html#use-collections.defaultdict",
    "href": "notebooks/M02_BasicPython/M02-05-Structures.html#use-collections.defaultdict",
    "title": "Data Structures",
    "section": "Use collections.defaultdict",
    "text": "Use collections.defaultdict\n\nfrom collections import defaultdict\n\n\nwords2 = defaultdict(int) # Note the data type must be set\n\n\nfor word in source_data:\n    words2[word] += 1\n\n\nprint(words2)\n\ndefaultdict(&lt;class 'int'&gt;, {'Lorem': 4, 'Ipsum': 3, 'is': 1, 'simply': 1, 'dummy': 2, 'text': 2, 'of': 4, 'the': 6, 'printing': 1, 'and': 3, 'typesetting': 1, 'industry.': 1, 'has': 2, 'been': 1, \"industry's\": 1, 'standard': 1, 'ever': 1, 'since': 1, '1500s,': 1, 'when': 1, 'an': 1, 'unknown': 1, 'printer': 1, 'took': 1, 'a': 2, 'galley': 1, 'type': 2, 'scrambled': 1, 'it': 1, 'to': 1, 'make': 1, 'specimen': 1, 'book.': 1, 'It': 2, 'survived': 1, 'not': 1, 'only': 1, 'five': 1, 'centuries,': 1, 'but': 1, 'also': 1, 'leap': 1, 'into': 1, 'electronic': 1, 'typesetting,': 1, 'remaining': 1, 'essentially': 1, 'unchanged.': 1, 'was': 1, 'popularised': 1, 'in': 1, '1960s': 1, 'with': 2, 'release': 1, 'Letraset': 1, 'sheets': 1, 'containing': 1, 'passages,': 1, 'more': 1, 'recently': 1, 'desktop': 1, 'publishing': 1, 'software': 1, 'like': 1, 'Aldus': 1, 'PageMaker': 1, 'including': 1, 'versions': 1, 'Ipsum.': 1})",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-06-AsideOnImmutables.html",
    "href": "notebooks/M02_BasicPython/M02-06-AsideOnImmutables.html",
    "title": "Aside On Immutables",
    "section": "",
    "text": "What Immutable Means\nA mutable object is a data structure whose internal values can be changed.\nFor example, tuples are immutable, lists are not. That is, lists are mutable.\nLet’s see how this works in practice.\nHere, we mutate a list by appending a value to it.\na = [1,2,3,4,5]\na.append(10)\nprint(a)\n\n[1, 2, 3, 4, 5, 10]\na[0] = 5\nprint(a)\n\n[5, 2, 3, 4, 5, 10]\nIf we try the same things with a tuple, we get an error.\nb = (1,2,3,4,5)\nb.append(10)\nprint(b)\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[40], line 2\n      1 b = (1,2,3,4,5)\n----&gt; 2 b.append(10)\n      3 print(b)\n\nAttributeError: 'tuple' object has no attribute 'append'\nb[0] = 5\nprint(b)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[41], line 1\n----&gt; 1 b[0] = 5\n      2 print(b)\n\nTypeError: 'tuple' object does not support item assignment\nThis, on the other hand, is not mutation:\na = [1,2,3,4,5,10] # A list\nb = (1,2,3,4,5,10) # A tuple\nprint(a)\nprint(b)\n\n[1, 2, 3, 4, 5, 10]\n(1, 2, 3, 4, 5, 10)\nWe are just re-assigning a new value to the variable.\nThe new value just replaces the old one.\nIn mutation, the same data structure remains in place but its contents are changed.\nNote, however, that this works with tuples:\nb += (11,)\nprint(b)\n\n(1, 2, 3, 4, 5, 10, 11)\nIt looks like mutation, but it’s not.\nThis is because we are replacing b with a new tuple value.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Aside On Immutables</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-06-AsideOnImmutables.html#behavior-differences",
    "href": "notebooks/M02_BasicPython/M02-06-AsideOnImmutables.html#behavior-differences",
    "title": "Aside On Immutables",
    "section": "Behavior Differences",
    "text": "Behavior Differences\nRelatedly, mutable and immutable objects behave differently in the context of variable assignment.\nFor example, when you assign a variable to another variable of a mutable datatype, any changes to the data are reflected by both variables.\nThe new variable is just an alias for the old variable.\nThis is only true for mutable datatypes.\nLets explore how + operator behaves differently between mutables and immutables.\nFirst, let’s create a function that will allow us to compare the objects as we modify them.\n\ndef compare_objects(trial:int, obj1:str, obj2:str):\n    o1 = eval(obj1)\n    o2 = eval(obj2)\n    print(f\"t{trial} {obj1} {o1} {id(o1)}\")\n    print(f\"t{trial} {obj2} {o2} {id(o2)}\")\n    print(f\"{obj1} == {obj2}:\", o1 == o2)\n\nList t1\nWe initialize a list and make a copy of it.\nNote that the two variables share the same id.\n\na0 = [1,2,3,4,5]\na1 = a0 # Make a copy of a list\ncompare_objects(1, 'a0', 'a1')\n\nt1 a0 [1, 2, 3, 4, 5] 139842806146944\nt1 a1 [1, 2, 3, 4, 5] 139842806146944\na0 == a1: True\n\n\nList t2\nNow we add to the copy and note the effects on the original.\nThe original value is also changed.\nThis is because both variables point to the same object.\n\na1 += [12] # Extend the copy\ncompare_objects(2, 'a0', 'a1')\n\nt2 a0 [1, 2, 3, 4, 5, 12] 139842806146944\nt2 a1 [1, 2, 3, 4, 5, 12] 139842806146944\na0 == a1: True\n\n\nList t3\nNote, however, that if we don’t use the unary operator,\nthen a1 becomes a different object!\nLutz goes into the difference between the += and the + in Ch 11 pages 360-363.\n\n\n\nimage.png\n\n\n\na1 = a1 + [12] # Extend the copy\ncompare_objects(3, 'a0', 'a1')\n\nt3 a0 [1, 2, 3, 4, 5, 12] 139842806146944\nt3 a1 [1, 2, 3, 4, 5, 12, 12] 139842804350592\na0 == a1: False\n\n\nList t4\nTry it with a new object copy, to avoid any possible inference between t2 and t3.\n\na2 = a0\na2 = a2 + [12] # Extend the copy\ncompare_objects(4, 'a0', 'a2')\n\nt4 a0 [1, 2, 3, 4, 5, 12] 139842806146944\nt4 a2 [1, 2, 3, 4, 5, 12, 12] 139842804515456\na0 == a2: False\n\n\nWe get the same result.\nTuple t1\nLet’s try this with a tuple.\nWe see again that both variables have the same id.\n\nb0 = (1,2,3,4,5)\nb1 = b0 # Make a copy of a tuple\ncompare_objects(1, 'b0', 'b1')\n\nt1 b0 (1, 2, 3, 4, 5) 139842804681360\nt1 b1 (1, 2, 3, 4, 5) 139842804681360\nb0 == b1: True\n\n\nTuple t2\nHowever, if extend the tuple with the unary operator, b1 becomes a new object.\nNote how this differs from the list behavior.\n\nb1 += (12,) # Extend the copy\ncompare_objects(2, 'b0', 'b1')\n\nt2 b0 (1, 2, 3, 4, 5) 139842804681360\nt2 b1 (1, 2, 3, 4, 5, 12) 139842804315424\nb0 == b1: False\n\n\nTuple t3\nIf we don’t use the unary operator, the same thing happens again.\nThe value of b1 becomes a new object because the variable has been reassigned.\n\nb1 = b1 + (12,) # Extend the copy\ncompare_objects(3, 'b0', 'b1')\n\nt3 b0 (1, 2, 3, 4, 5) 139842804681360\nt3 b1 (1, 2, 3, 4, 5, 12, 12) 139842804316096\nb0 == b1: False\n\n\nLet’s look at another example.\nHere is a list:\n\nfoo = ['hi']\nbar = foo\ncompare_objects(1, 'foo', 'bar')\n\nt1 foo ['hi'] 139842804665216\nt1 bar ['hi'] 139842804665216\nfoo == bar: True\n\n\n\nbar += ['bye']\ncompare_objects(2, 'foo', 'bar')\n\nt2 foo ['hi', 'bye'] 139842804665216\nt2 bar ['hi', 'bye'] 139842804665216\nfoo == bar: True\n\n\n\nbar = bar + ['bye']\ncompare_objects(2, 'foo', 'bar')\n\nt2 foo ['hi', 'bye'] 139842804665216\nt2 bar ['hi', 'bye', 'bye'] 139842805379520\nfoo == bar: False\n\n\nAnd here is a tuple:\n\nfoo1 = ('hi')\nbar1 = foo1\ncompare_objects(1, 'foo1', 'bar1')\n\nt1 foo1 hi 139843849783920\nt1 bar1 hi 139843849783920\nfoo1 == bar1: True\n\n\n\nbar1 += ('bye')\ncompare_objects(2, 'foo1', 'bar1')\n\nt2 foo1 hi 139843849783920\nt2 bar1 hibye 139842806205616\nfoo1 == bar1: False",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Aside On Immutables</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html",
    "href": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html",
    "title": "Control Structures",
    "section": "",
    "text": "Introducing Control Structures\nPython includes structures to control the flow of data in a program.\nThese structures are made of code blocks that provide looping and branching capabilities to your code, based on boolean conditions.\nControl structures are fundamental to creating algorithms that can process and respond to data as it flows through and is transformed by a program.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html#conditions",
    "href": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html#conditions",
    "title": "Control Structures",
    "section": "Conditions",
    "text": "Conditions\nConditions are boolean checkpoints in a program, switching a process based on wheter some condition is true or not.\nThe if and else keywords can be used to create branches in your code based on conditions.\nThis is called conditional processing.\nHere is a very simple example.\n\nval = -2\n\nif val &gt;= 0:\n    print(val)\nelse:\n    print(-val)\n\n2\n\n\n\nA Note about Indentation\nNote the indenation pattern in the code:\nif val &gt;= 0:\n    print(val)\nelse:\n    print(-val)\nThis is where Python differs from most languages.\nTo define control structures, and functional blocks of code in general, most languages use either characters like braces { and } or key words like IF ... END IF.\nFor example, here is how this control structure might look in other languages:\n\nif (val &lt;= 0) {\n    print(val);\n} \nelse {\n    print(-val);\n}\nOr:\nIF val &lt;= 0\n    PRINT val\nELSE\n    PRINT -val\nEND IF\nPython uses tabs — spaces, actually — to signify logical blocks off code.\nIt is therefore imperative to understand and get a feel for indentation.\n\n\n\nelif\nelif is reached when the previous statements are not.\nNote that if one succeeds, those that follow are not processed.\nThis is unlike a series of if statements.\n\nval = -2\n\nif -10 &lt; val &lt; -5:\n    print('bucket 1')\nelif -5 &lt;= val &lt; -2:\n    print('bucket 2')\nelif val == -2:\n    print('bucket 3')\n\nbucket 3\n\n\n\n\nelse\nelse can be used as a catch-all for situation when no condition is met.\n\nval = 5\n\nif -10 &lt; val &lt; -5:\n    print('bucket 1')\nelif -5 &lt;= val &lt; -2:\n    print('bucket 2')\nelif val == -2:\n    print('bucket 3')\nelse:\n    print('bucket 4')\n\nbucket 4\n\n\nIt’s a good practice to include an else statement.\n\n\nif and else as one-liners\nPython provides a short-hand way of defining if statements.\n\nx = 3\n\nprint('odd') if x % 2 == 1 else print('even')\n\nodd\n\n\nThe general form:\nACTION1 if CONDITION else ACTION2\nBoth if and else are required. This breaks:\n\nprint('odd') if x % 2 == 1\n\n\n  Cell In[14], line 1\n    print('odd') if x % 2 == 1\n    ^\nSyntaxError: expected 'else' after 'if' expression\n\n\n\n\nEssentially, then, this is an either/or construct.\n\n\nUsing multiple conditions\nIf statements can be complex combinations of expressions. Use parentheses to keep order of operations correct.\nCorrect:\n\nprint(1) if (-2 &lt; val &lt; 2) or (val &gt; 10) else print(2)\n\n2\n\n\nIncorrect:\n\nprint(1) if (-2 &lt; val) &lt; 2 or val &gt; 10 else print(2)\n\n1\n\n\nThe problem is that the condition line is interpreted as True &lt; 2, where True is cast to integer value \\(1\\).",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html#loops",
    "href": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html#loops",
    "title": "Control Structures",
    "section": "Loops",
    "text": "Loops\nLoops are fundamental constructs in programming.\nThey allow for the repeated application of a set of operations on a series of values to compute a result.\nThe repetition of a process as the data changes is called iteration.\nA loop is an algorithmic pattern designed to process data stored in a seqeuence of some kind, such as provided by a list or range.\nLoops exemplify a premise of this course that data structures imply algorithms. Using the term ‘list’ broadly, we may say that Lists imply loops.\nThere are two main kinds of loops in Python: while and for.\n\nwhile loops\nWhile loops iterate while some condition is true. It stops when the condition is false.\nHere is a simple example:\n\nix = 1\nix_list = []\nwhile ix &lt; 10:\n    ix *= 2\n    ix_list.append(ix)\nprint(ix)\nprint(ix_list)\nprint(ix_list[-1])\n\n16\n[2, 4, 8, 16]\n16\n\n\nNote that it is possible for while loops to be unending.\nFor example:\nwhile 1:\n    print(\"This is so annoying\")\nThis is why it is important to make sure that your looping condition can be met.\nYou may also break out of a loop by other means.\n\n\nbreak\nSometimes you want to quit the loop early, if some condition is met.\nTo do this, put break in an if statement.\n\nix = 1\nwhile ix &lt; 10:\n    ix = ix * 2\n    if ix == 4:\n        break\nprint(ix)\n\n4\n\n\nThe break causes the loop to end early\n\n\ncontinue\nSometimes you want to introduce skipping behavior in the loop.\nTo do this, put continue in an if statement.\n\nix = 1\nwhile ix &lt; 10:\n    ix = ix * 2\n    if ix == 4:\n        print('skipping 4...')\n        continue\n    print(ix)\n\n2\nskipping 4...\n8\n16\n\n\nSee how continue causes the loop to skip printing \\(4\\).\n\n\nfor\nIn contrast to while loops, for loops iterate over an iterable data structure, such as a list.\nThey stop when the list is finished.\n\ncities = ['Charlottesville','New York','SF','BOS','LA']\n\nfor city in cities:\n    print(f'\"{city.lower()}\"', end=' ')\n\n\"charlottesville\" \"new york\" \"sf\" \"bos\" \"la\" \n\n\nConditions can be used inside of if statements to skip within or stop the loop.\nQuit early if SF reached, using break:\n\ncities = ['Charlottesville','New York','SF','BOS','LA']\n\nfor city in cities:  \n    if city == 'SF':\n        break\n    print(f'\"{city.lower()}\"', end=' ')\n\n\"charlottesville\" \"new york\" \n\n\nSkip over SF if reached, using continue:\n\ncities = ['Charlottesville','New York','SF','BOS','LA']\n\nfor city in cities:\n    if city == 'SF':\n        continue\n    print(f'\"{city.lower()}\"', end=' ')        \n\n\"charlottesville\" \"new york\" \"bos\" \"la\"",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html#while-vs-for",
    "href": "notebooks/M03_ControlStructures/M03-01-ControlStructures.html#while-vs-for",
    "title": "Control Structures",
    "section": "while vs for",
    "text": "while vs for\nWhen choosing between for and while loops, consider this:\n\nfor loops are used to loop through a list of values or an operation in which the number of iterations is known in advance.\nwhile loops are when you don’t know how many interations it will take — you are depending on some condition to be met.\n\nThe former is often used when processing data, the latter when performing algorithmic modeling tasks, such as optimization and convergence.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html",
    "title": "Iterables and Iterators",
    "section": "",
    "text": "Iterables and Iteration\nWe have seen that sequential data structures like lists and tuples have a natural affinity to loops.\nSequences imply loops and loops expect sequences.\nIn Python, this relationship is captured by the resonance between the words iteration and iterables.\nIterable data structures that can be iterated over, meaning they can return their elements one at a time.\nExamples of iterable objects include lists, tuples, sets, dictionaries, and strings.\nTypically we iterate over iterables using for loops, as we saw when reviewed control structures.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#lists",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#lists",
    "title": "Iterables and Iterators",
    "section": "Lists",
    "text": "Lists",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#iterating-using-for",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#iterating-using-for",
    "title": "Iterables and Iterators",
    "section": "iterating using for",
    "text": "iterating using for\nFirst, let’s review iteration by means of a for loop.\n\ntokens = ['living room', 'was', 'quite', 'large']\nfor tok in tokens:\n    print(tok)\n\nliving room\nwas\nquite\nlarge",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#iterators",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#iterators",
    "title": "Iterables and Iterators",
    "section": "Iterators",
    "text": "Iterators\nPython introduces a kind of object call an iterator designed to make iteration — sequence processing — fast and efficient.\nAn iterator is a specific object that represents an interable stream of data.\nIt is used to iterate over iterable objects by removing one element at a time from the iterables.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#iterating-with-iterators",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#iterating-with-iterators",
    "title": "Iterables and Iterators",
    "section": "Iterating with Iterators",
    "text": "Iterating with Iterators\nAn iterator works by popping out and removing a value at each iteration.\nThis means than when iterating through an iterable object you empty it as you go, leaving an empty data structure at the end.\nThis is useful in situations where you want to save memory.\nMany functions in Python return iterables so it’s helpful to understand them even if you don’t create any yourself.\n\nUsing iter() and next()\nTo use an iterator, you convert a sequence to an iterator object using iter().\nThen you use next() to get the next item from the iterator.\n\ntokens = ['living room','was','quite','large']\nmyit = iter(tokens)\nprint(next(myit)) \nprint(next(myit)) \nprint(next(myit)) \nprint(next(myit)) \n\nliving room\nwas\nquite\nlarge\n\n\nCalling next() when the iterator has reached the end of the list produces an exception:\n\nnext(myit)\n\n\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 next(myit)\n\nStopIteration: \n\n\n\nNote that when used with an iterable created by iter(), for implicitly executes next() on each loop iteration.\n\nmyit = iter(tokens) # Reset the iterator\nfor next_it in myit:\n    print(next_it)\n\nliving room\nwas\nquite\nlarge",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#sequences-and-collections",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#sequences-and-collections",
    "title": "Iterables and Iterators",
    "section": "Sequences and Collections",
    "text": "Sequences and Collections\nSo far, we iterated over a list.\nNow let’s look at sets, strings, tuples, dictionaries, and ranges.\nLists, tuples, and strings are sequences. Sequences are designed so that elements come out of them in the same order they were put in.\nSets and dictionaries are not sequences per se, since they the order of their elements is not as important as their names. They are called collections.\nNote that prior to Python 3.7, the order of elements in sets and dictionaries was arbitrary. Now, dictionaries preserve the order in which they were populated, and sets are sorted.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#sets",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#sets",
    "title": "Iterables and Iterators",
    "section": "Sets",
    "text": "Sets\nIterating using for:\n\nprincesses = {'belle', 'cinderella', 'rapunzel'}\nfor princess in princesses:\n    print(princess)\n\nrapunzel\nbelle\ncinderella\n\n\nIterating using iter() and next():\n\nprincesses_i = iter(princesses)\nprint(next(princesses_i))\nprint(next(princesses_i))\nprint(next(princesses_i))\n\nrapunzel\nbelle\ncinderella\n\n\n\ntype(princesses_i)\n\nset_iterator",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#strings",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#strings",
    "title": "Iterables and Iterators",
    "section": "Strings",
    "text": "Strings\nIterating using for:\n\nstr1 = 'data'\nfor my_char in str1:\n    print(my_char)\n\nd\na\nt\na\n\n\nIterating using iter() and next():\n\nstr1_i = iter(str1)\nprint(next(str1_i))\nprint(next(str1_i))\nprint(next(str1_i))\nprint(next(str1_i))\n\nd\na\nt\na\n\n\n\ntype(str1_i)\n\nstr_ascii_iterator",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#tuples",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#tuples",
    "title": "Iterables and Iterators",
    "section": "Tuples",
    "text": "Tuples\nIterating using for:\n\nmetrics = ('auc','recall','precision','support')\nfor met in metrics:\n    print(met)\n\nauc\nrecall\nprecision\nsupport\n\n\nIterating using iter() and next():\n\nmetrics = ('auc','recall','precision','support')\nmetrics_i = iter(metrics)\nprint(next(metrics_i))\nprint(next(metrics_i))\nprint(next(metrics_i))\nprint(next(metrics_i))\n\nauc\nrecall\nprecision\nsupport\n\n\n\ntype(metrics_i)\n\ntuple_iterator",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#dictionaries",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#dictionaries",
    "title": "Iterables and Iterators",
    "section": "Dictionaries",
    "text": "Dictionaries\nIterating using for:\n\ncourses = {'fall': ['regression','python'], 'spring': ['capstone','pyspark','nlp']}\n\n\nfor k in courses:\n    print(k)\n\nfall\nspring\n\n\n\nfor k in courses.keys():\n    print(k)\n\nfall\nspring\n\n\n\nfor v in courses.values():\n    print(v)\n\n['regression', 'python']\n['capstone', 'pyspark', 'nlp']\n\n\n\nfor k, v in courses.items():\n    print(f\"{k.upper()}:\\t{', '.join(v)}\")\n\nFALL:   regression, python\nSPRING: capstone, pyspark, nlp\n\n\n\nfor k in courses.keys():\n    print(f\"{k.upper()}:\\t{', '.join(courses[k])}\") # index into the dict with the key\n\nFALL:   regression, python\nSPRING: capstone, pyspark, nlp",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#ranges",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#ranges",
    "title": "Iterables and Iterators",
    "section": "Ranges",
    "text": "Ranges\nIterating using for:\n\nfor i in range(10):\n    print(str(i+1).zfill(2), (i+1)**2 * '|')\n\n01 |\n02 ||||\n03 |||||||||\n04 ||||||||||||||||\n05 |||||||||||||||||||||||||\n06 ||||||||||||||||||||||||||||||||||||\n07 |||||||||||||||||||||||||||||||||||||||||||||||||\n08 ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n09 |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n10 ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#get-iteration-number-with-enumerate",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#get-iteration-number-with-enumerate",
    "title": "Iterables and Iterators",
    "section": "Get iteration number with enumerate()",
    "text": "Get iteration number with enumerate()\nVery often you will want to know iteration number you are on in a loop.\nThis can be used to name files or dict keys, for example.\nenumerate() will return the index and key for each iteration.\n\ncourses\n\n{'fall': ['regression', 'python'], 'spring': ['capstone', 'pyspark', 'nlp']}\n\n\n\nfor i, semester in enumerate(courses):\n    course_name = f\"{str(i).zfill(2)}_{semester}:\\t{'-'.join(courses[semester])}\"\n    print(course_name)\n\n00_fall:    regression-python\n01_spring:  capstone-pyspark-nlp",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#nested-loops",
    "href": "notebooks/M03_ControlStructures/M03-02-IterablesAndIterators.html#nested-loops",
    "title": "Iterables and Iterators",
    "section": "Nested Loops",
    "text": "Nested Loops\nIterations can be nested — this is very powerful.\nThis works well with nested data structures, like dictionaries within dictionaries.\nThis is basically how JSON files are handled, BTW.\nBe careful, though – these can get deep and complicated.\n\nfor i, semester in enumerate(courses):\n    print(f\"{i+1}. {semester.upper()}:\")\n    for j, course in enumerate(courses[semester]):\n        print(f\"\\t{i+1}.{j+1}. {course}\")\n\n1. FALL:\n    1.1. regression\n    1.2. python\n2. SPRING:\n    2.1. capstone\n    2.2. pyspark\n    2.3. nlp\n\n\nUsed nested loops to get the cartesian product.\n\ndie = range(1,7)\ndie_rolls = []\nfor face1 in die:\n    for face2 in die:\n        die_rolls.append((face1, face2))\nprint(die_rolls)\n\n[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]\n\n\nNow get the frequency of die roll sums.\n\ndie_roll_sums = {}\n\n\nfor my_die_roll in die_rolls:\n    my_die_roll_sum = sum(my_die_roll)\n    die_roll_sums[my_die_roll_sum] = die_roll_sums.get(my_die_roll_sum, 0) + 1\n\n\nfor k, v in die_roll_sums.items():\n    print(str(k).zfill(2), v, '|' * v)\n\n02 1 |\n03 2 ||\n04 3 |||\n05 4 ||||\n06 5 |||||\n07 6 ||||||\n08 5 |||||\n09 4 ||||\n10 3 |||\n11 2 ||\n12 1 |",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Iterables and Iterators</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-03-Comprehensions.html",
    "href": "notebooks/M03_ControlStructures/M03-03-Comprehensions.html",
    "title": "Comprehensions",
    "section": "",
    "text": "List Comprehensions\nConsider the following task.\nCheck if each integer in a list is odd and save the results (true or false) in a list.\nWith a standard for loop, you could do this:\nvals = [1,5,6,8,12,15]\nis_odd = []\nfor val in vals:   \n    if val % 2:\n        is_odd.append(True)\n    else:       \n        is_odd.append(False)\nis_odd\n\n[True, True, False, False, False, True]\nNow let’s do the same thing with a list comprehension:\nis_odd_comp = [val % 2 == 1 for val in vals]\nis_odd_comp\n\n[True, True, False, False, False, True]\nMuch shorter, and if you understand the syntax, quicker to interpet.\nHere’s how you might save all the even numbers in a list:\nodd_vals = [val for val in vals if val % 2 == 1]\nodd_vals\n\n[1, 5, 15]\nThis introduces how comprehensions may include a boolean condition to filter what gets included in the result.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-03-Comprehensions.html#removing-stopwords",
    "href": "notebooks/M03_ControlStructures/M03-03-Comprehensions.html#removing-stopwords",
    "title": "Comprehensions",
    "section": "Removing Stopwords",
    "text": "Removing Stopwords\nDefine a sentence and a list of stop words.\nFilter out the stop words (considered not important).\n\nsentence = \"I am not a fan of this film\"\nstop_words = ['a','am','an','i','the','of']\n\n\nclean_words = [word for word in sentence.split() if word.lower() not in stop_words]\nclean_words\n\n['not', 'fan', 'this', 'film']\n\n\nHere is a color-coded version of the list comprehension to show its parts:\n[word   for word in sentence.split()  if word not in stop_words]\nSide note: This task can also be done with sets, if you are not concerned with mulitple instances of the same word:\n\ns1 = set(stop_words)\ns2 = set(sentence.lower().split())\ns3 = s2 - s1\n\n\ns3\n\n{'fan', 'film', 'not', 'this'}",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-03-Comprehensions.html#selecting-tokens-containing-units",
    "href": "notebooks/M03_ControlStructures/M03-03-Comprehensions.html#selecting-tokens-containing-units",
    "title": "Comprehensions",
    "section": "Selecting Tokens Containing Units",
    "text": "Selecting Tokens Containing Units\nGiven a list of measurements, retain elements containing \\(mmHg\\) (millimeters of mercury)\n\nunits = 'mmHg'\nmeasures = ['20', '115mmHg', '5mg', '10 mg', '7.5dl', '120 mmHg']\nmeasures_mmhg = [measure for measure in measures if units in measure]\n\n\nmeasures_mmhg   \n\n['115mmHg', '120 mmHg']\n\n\nFiltering on two conditions\n\nunits1 = 'mmHg'\nunits2 = 'dl'\nmeas_mmhg_dl = [meas for meas in measures if units1 in meas or units2 in meas]\n\n\nmeas_mmhg_dl\n\n['115mmHg', '7.5dl', '120 mmHg']\n\n\nThis can be written differently for clarity:\n\n[meas \n for meas in measures \n if units1 in meas \n or units2 in meas]\n\n['115mmHg', '7.5dl', '120 mmHg']",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Comprehensions</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-04-NestedComprehensions.html",
    "href": "notebooks/M03_ControlStructures/M03-04-NestedComprehensions.html",
    "title": "Nested Comprehensions",
    "section": "",
    "text": "Programming for Data Science\nRecall that nested loops are the algorithmic complement to nested data structures.\nJust as we can nest loops using for loops, we can do so with comprehensions.\nHere are some examples.\nThis notebook is adapted from GeeksForGeeks.\n\n\nExample 1: Creating a Matrix\nHere is how we can make a matrix — a two-dimensional data structure where each element is of the same data type — using plain old for loops.\n\nmatrix1 = [] # Matrix created\nfor i in range(5):\n    matrix1.append([]) # Row created\n    for j in range(5):\n        matrix1[i].append(j) # Cell populated\n\n\nmatrix1\n\n[[0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4]]\n\n\nHere’s how we can do this with a nested list comprehension:\n\nmatrix2 = [[j for j in range(5)] for i in range(5)]\n\n\nmatrix2\n\n[[0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4],\n [0, 1, 2, 3, 4]]\n\n\nWe replace five lines of code with one.\n\n\nExample 2: Filtering a Nested List\nLet create a filter to extract some things we want from a matrix.\nIn this case, we want to pull out all of the odd numbers and save them as a list.\n\nmatrix3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nodd_numbers1 = []\nfor row in matrix3:\n    for element in row:\n        if element % 2 != 0:\n            odd_numbers1.append(element)\n\n\nodd_numbers1\n\n[1, 3, 5, 7, 9]\n\n\n\nodd_numbers2 = [element for row in matrix3 for element in row if element % 2 != 0]\n\n\nodd_numbers2\n\n[1, 3, 5, 7, 9]\n\n\nHere’s a closer look at how nesting is represented in a comprehension compared to the traditional way.\nTraditional for loop:\nfor row in matrix3:\n    for element in row:\n        if element % 2 != 0:\n            odd_numbers1.append(element) # This is hoised to the top\n                                         # and implicitly appended\nComprehension (inside []):\nelement                        \n    for row in matrix3 \n        for element in row \n            if element % 2 != 0\nSee how they are the same, except that the kernel operation — appending filtered values to a result list — is hoisted to the top in the case of the comprehension.\n\n\nExample 3: Flattening Nested Sub-Lists\nHere we take a nested structure and flatten it out.\n\nnested_list = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]\nflat_list1 = []\nfor sub_list in nested_list:\n    for val in sub_list:\n        flat_list1.append(val)\n\n\nflat_list1\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nflat_list2 = [val for sub_list in nested_list for val in sub_list]\n\n\nflat_list2\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nExample 4: Manipulating Matrix Values\nFinally, we demonstrate how to manipulate each value in a matrix of words.\nIn this case, we simply capitalize each string.\n\nmatrix4 = [[\"apple\", \"banana\", \"cherry\"],\n        [\"date\", \"fig\", \"grape\"],\n        [\"kiwi\", \"lemon\", \"mango\"]]\nmodified_matrix1 = []\nfor row in matrix4:\n    modified_row = []\n    for fruit in row:\n        modified_row.append(fruit.capitalize())\n    modified_matrix1.append(modified_row)\n\n\nmodified_matrix1\n\n[['Apple', 'Banana', 'Cherry'],\n ['Date', 'Fig', 'Grape'],\n ['Kiwi', 'Lemon', 'Mango']]\n\n\n\nmodified_matrix2 = [[fruit.capitalize() for fruit in row] for row in matrix4]\n\n\nmodified_matrix2\n\n[['Apple', 'Banana', 'Cherry'],\n ['Date', 'Fig', 'Grape'],\n ['Kiwi', 'Lemon', 'Mango']]",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Nested Comprehensions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html",
    "title": "Introduction to Functions",
    "section": "",
    "text": "What is a Function?\nA function is piece of code, separate fom the larger program, that performs a specific task.\nThis piece of code is given a name and can be called from the main program.\nFunctions are the verbs of a programming language. They signify action, and take subjects and objects (as it were).",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#how-do-they-work",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#how-do-they-work",
    "title": "Introduction to Functions",
    "section": "How do they Work?",
    "text": "How do they Work?\nFunctions take input data and produce output data.\n\nFunction inputs are called both parameters and arguments.\nOutputs are called return values\n\nFunctions are always written with parentheses at the end of their names, e.g.\nlen(some_list)\ntime()\nInternally, they contain a block of code to do their work.\nOften the produce a transformation … e.g. from simple to complex.\nWhen you use a function, we say you call a function. Programmers speak of “function calls” and “callbacks.”",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#why-use-them",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#why-use-them",
    "title": "Introduction to Functions",
    "section": "Why Use Them?",
    "text": "Why Use Them?\nReduce complex tasks into simpler tasks.\nEliminate duplicate code — no need to re-write, reuse function as needed.\nMake code reusable. Once function is written, you can reuse it in any other program.\nDistribute tasks to multiple programmers. For example, each function can be written by someone.\nHide implementation details, i.e. abstraction.\nIncrease code readability.\nImprove debugging by improving traceability. Things are easier to follow; you can jump from function to function.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#built-in-functions",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#built-in-functions",
    "title": "Introduction to Functions",
    "section": "Built-in Functions",
    "text": "Built-in Functions\nPython provides many built-in functions. See Python built-in functions.\nWe’ve looked at many of these already.\nThese are functions that are available to use any time your are running Python.\nTo take one simple example, this is a built-in function: bool().\nTakes an argument \\(x\\) and returns a boolean value, i.e. True or False.\n\nbool(0), bool(500)\n\n(False, True)",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#imported-functions",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#imported-functions",
    "title": "Introduction to Functions",
    "section": "Imported Functions",
    "text": "Imported Functions\nPython is meant to be a highly modular language.\nIt is not designed to have a lot of special purpose functions built into it.\nThese keeps it light and highly customizable.\nMany functions can be imported into a program to add to the functions that you can call in a script.\n\nimport math\n\nmath.log(256, 2)\n\n8.0",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#user-defined-functions",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#user-defined-functions",
    "title": "Introduction to Functions",
    "section": "User-Defined Functions",
    "text": "User-Defined Functions\nPython makes it easy for you to write your own functions. These are called user-defined functions.\nLet’s write a function to compare the list against a threshold.\n\ndef vals_greater_than_or_equal_to_threshold(vals, thresh):\n    '''\n    This is the \"docstring\" of a function. It is optional but expected. It describes it's \n    purpose and the nature of the input and return values, as well as a sense of what it does.\n    More elaborate information should appear in external documentation packages with the function.\n    \n    PURPOSE: Given a list of values, compare each value against a threshold\n    \n    INPUTS\n    vals    list of ints or floats\n    thresh  int or float\n    \n    OUTPUT\n    bools  list of booleans\n    '''\n    \n    filtered_vals = [val &gt;= thresh for val in vals]\n    \n    return filtered_vals\n\nLet’s break down the components\nThe function definition starts with def, followed by name, one or more arguments in parenthesis, and then a colon.\nNext comes a docstring to provide information to users about how and why to use the function.\nThe function body follows.\nLastly is a return statement\nThe function call allows for the function to be used.\nIt consists of function name and required arguments:\nvals_greater_than_or_equal_to_threshold(arg1, arg2) where arg1, arg2 are arbitrary names.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#about-the-docstring",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#about-the-docstring",
    "title": "Introduction to Functions",
    "section": "About the docstring",
    "text": "About the docstring\nA docstring occurs as first statement in module, function, class, or method definition.\nInternally, it is saved in __doc__ attribute of the function object.\nIt needs to be indented, i.e. part of the code block associated with the function.\nIt can be a single line or a multi-line string.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#users-can-print-the-docstring",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#users-can-print-the-docstring",
    "title": "Introduction to Functions",
    "section": "Users can print the docstring",
    "text": "Users can print the docstring\n\nprint(vals_greater_than_or_equal_to_threshold.__doc__)\n\n\n    This is the \"docstring\" of a function. It is optional but expected. It describes it's \n    purpose and the nature of the input and return values, as well as a sense of what it does.\n    More elaborate information should appear in external documentation packages with the function.\n    \n    PURPOSE: Given a list of values, compare each value against a threshold\n    \n    INPUTS\n    vals    list of ints or floats\n    thresh  int or float\n    \n    OUTPUT\n    bools  list of booleans\n    \n\n\nPrint the docstring using help():\n\nhelp(vals_greater_than_or_equal_to_threshold)\n\nHelp on function vals_greater_than_or_equal_to_threshold in module __main__:\n\nvals_greater_than_or_equal_to_threshold(vals, thresh)\n    This is the \"docstring\" of a function. It is optional but expected. It describes it's \n    purpose and the nature of the input and return values, as well as a sense of what it does.\n    More elaborate information should appear in external documentation packages with the function.\n    \n    PURPOSE: Given a list of values, compare each value against a threshold\n    \n    INPUTS\n    vals    list of ints or floats\n    thresh  int or float\n    \n    OUTPUT\n    bools  list of booleans\n\n\n\nOr, use the ? prefix in a Jupyter notebook:\n\n?vals_greater_than_or_equal_to_threshold\n\n\nSignature: vals_greater_than_or_equal_to_threshold(vals, thresh)\nDocstring:\nThis is the \"docstring\" of a function. It is optional but expected. It describes it's \npurpose and the nature of the input and return values, as well as a sense of what it does.\nMore elaborate information should appear in external documentation packages with the function.\nPURPOSE: Given a list of values, compare each value against a threshold\nINPUTS\nvals    list of ints or floats\nthresh  int or float\nOUTPUT\nbools  list of booleans\nFile:      /tmp/ipykernel_133200/392258855.py\nType:      function\n\n\n\nOr suffix …\n\nvals_greater_than_or_equal_to_threshold?\n\n\nSignature: vals_greater_than_or_equal_to_threshold(vals, thresh)\nDocstring:\nThis is the \"docstring\" of a function. It is optional but expected. It describes it's \npurpose and the nature of the input and return values, as well as a sense of what it does.\nMore elaborate information should appear in external documentation packages with the function.\nPURPOSE: Given a list of values, compare each value against a threshold\nINPUTS\nvals    list of ints or floats\nthresh  int or float\nOUTPUT\nbools  list of booleans\nFile:      /tmp/ipykernel_133200/392258855.py\nType:      function",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#calling-our-function",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#calling-our-function",
    "title": "Introduction to Functions",
    "section": "Calling Our Function",
    "text": "Calling Our Function\nLet’s use, or “call,” our function.\nThe function body uses a list comprehensionto perform a filtering operation:\n[val &gt;= thresh for val in vals]\nValidate that it works for integers:\n\nx = [3, 4]\nthr = 4\n\nvals_greater_than_or_equal_to_threshold(x, thr)\n\n[False, True]\n\n\nValidate that it works for floats:\n\nx = [3.0, 4.2]\nthr = 4.2\n\nvals_greater_than_or_equal_to_threshold(x, thr)\n\n[False, True]\n\n\nThis gives correct results and does exactly what we want.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#passing-parameters",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#passing-parameters",
    "title": "Introduction to Functions",
    "section": "Passing Parameters",
    "text": "Passing Parameters\nAll functions may take \\(0\\) or more arguments, also called parameters.\nFunctions need to be called with correct number of parameters.\nThis function requires two parameters, but the function call includes only one parameter.\n\ndef func_with_args(x, y):\n    return x + y\n\n\nfunc_with_args(10)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 func_with_args(10)\n\nTypeError: func_with_args() missing 1 required positional argument: 'y'",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#parameter-order",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#parameter-order",
    "title": "Introduction to Functions",
    "section": "Parameter Order",
    "text": "Parameter Order\nWhen calling a function, parameter order matters.\n\ndef fcn_swapped_args(x, y):\n    out = 5 * x + y\n    return out\n\n\nx = 1\ny = 2\n\n\nfcn_swapped_args(x, y)\n\n7\n\n\n\nfcn_swapped_args(y, x)\n\n11",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#named-parameters",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#named-parameters",
    "title": "Introduction to Functions",
    "section": "Named Parameters",
    "text": "Named Parameters\nGenerally it’s best to keep parameters in order.\nHowever, You can swap the order by putting the parameter names in the function call.\n\nfcn_swapped_args(y=y, x=x)",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#weirdness-alert",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#weirdness-alert",
    "title": "Introduction to Functions",
    "section": "Weirdness Alert",
    "text": "Weirdness Alert\nNote that the same name can be used for the parameter names and the variables passed to them.\nThe names themselves have nothng to do with each other!\nIn other words, just because a function names an argument foo,\nthe variables passed to it don’t have to name foo or anything like it.\nThey can even be named the same thing—it does not matter.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#default-arguments",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#default-arguments",
    "title": "Introduction to Functions",
    "section": "Default Arguments",
    "text": "Default Arguments\nUse default arguments to set the value of arguments.\nThis allows users to call functions with fewer (or no) arguments.\nDefaults are often set for the most common cases.\n\ndef show_results(precision, printing=True):\n    precision = round(precision, 2)\n    if printing:\n      print('precision =', precision)\n    return precision\n\n\npr = 0.912\nres = show_results(pr)\n\nprecision = 0.91\n\n\nThe function call didn’t specify printing, so it defaulted to True.\n\nfoo = show_results(pr, False)\n\nNOTE: Default arguments must follow non-default arguments in function definition.\nThis causes trouble:\n\ndef show_results(precision, printing=True, uhoh):\n    precision = round(precision, 2)\n    if printing:\n      print('precision =', precision)\n    return precision\n\n\n  Cell In[30], line 1\n    def show_results(precision, printing=True, uhoh):\n                                               ^\nSyntaxError: non-default argument follows default argument",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#returning-values",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#returning-values",
    "title": "Introduction to Functions",
    "section": "Returning Values",
    "text": "Returning Values\nFunctions are not required to have return statement but it is a good idea to have one.\nIf there is no return statement, a function returns None.\nFunctions can return no value (None), one value, or many.\nMany values are returned as a tuple.\nAny Python object can be returned.\nThis returns None.\n\ndef fcn_nothing_to_return(x, y):\n    out = 'nothing to see here!'\n    print(out)\n\n\nfcn_nothing_to_return(x, y)\n\nnothing to see here!\n\n\n\nr = fcn_nothing_to_return(1, 1)\n\nnothing to see here!\n\n\n\nr\n\n\nprint(r)\n\nNone\n\n\nThis returns three values.\n\ndef negate_coords(x, y, z):\n    return -x, -y, -z \n\n\na, b, c = negate_coords(10, 20, 30)\n\n\na, b, c\n\n(-10, -20, -30)\n\n\n\nfoo = negate_coords(10, 20, 30)\n\n\nfoo\n\n(-10, -20, -30)\n\n\nIf you don’t need an output, use the dummy variable _.\n\nd, e, _ = negate_coords(10,20,30)\n\n\nd, e\n\n(-10, -20)\n\n\nNote: It’s generally a good idea to include return statements, even if not returning a value.\nThis shows that you did not forget to consider the return value.\nYou can use return or return None.\nFunctions can contain multiple return statements.\nThese may be used under different logical conditions.\n\ndef absolute_value(num):\n    if num &gt;= 0:\n        return num\n    return -num\n\n\nabsolute_value(-4), absolute_value(4)\n\n(4, 4)",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#unpacking-list-likes-with-args",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#unpacking-list-likes-with-args",
    "title": "Introduction to Functions",
    "section": "Unpacking List-likes with *args",
    "text": "Unpacking List-likes with *args\nThe * prefix operator can be passed to avoid specifying the arguments individually.\n\ndef show_arg_expansion1(models):\n    print(models)\n\nWe can pass a tuple of values to the function …\n\nshow_arg_expansion1(\"logreg\", \"naive_bayes\", \"gbm\")\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[92], line 1\n----&gt; 1 show_arg_expansion1(\"logreg\", \"naive_bayes\", \"gbm\")\n\nTypeError: show_arg_expansion1() takes 1 positional argument but 3 were given\n\n\n\n\ndef show_arg_expansion2(*models):\n    print(models)\n\n\nshow_arg_expansion2(\"logreg\", \"naive_bayes\", \"gbm\")\n\n('logreg', 'naive_bayes', 'gbm')\n\n\nThis also allows for an unspecified number of arguments, such as how print() works.\nYou can also pass a list to the function.\nIf you want the elements unpacked, put * before the list.\n\nmodels = [\"logreg\", \"naive_bayes\", \"gbm\"]\nshow_arg_expansion2(*models)\n\n('logreg', 'naive_bayes', 'gbm')\n\n\nThis approach allows your function to accept an arbitrary number of arguments.\nNote you can prefix a string with an asterisk *:\n\nshow_arg_expansion2(*'abcdefg')\n\n('a', 'b', 'c', 'd', 'e', 'f', 'g')\n\n\nOr a string operation that returns a list:\n\nshow_arg_expansion2(*'a b c d e f g'.split())\n\n('a', 'b', 'c', 'd', 'e', 'f', 'g')\n\n\nYou can use the * prefix to pass list-like objects to a function with a defined number of arguments.\n\ndef arg_expansion_example(x, y):\n    return x**y\n\n\nmy_args = [2, 8]\narg_expansion_example(*my_args)\n\n256\n\n\nBut, the passed object must be the right length.\n\nmy_args2 = [2, 8, 5]\narg_expansion_example(*my_args2)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[75], line 2\n      1 my_args2 = [2, 8, 5]\n----&gt; 2 arg_expansion_example(*my_args2)\n\nTypeError: arg_expansion_example() takes 2 positional arguments but 3 were given",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-01-Functions.html#function-design",
    "href": "notebooks/M04_PythonFunctions/M04-01-Functions.html#function-design",
    "title": "Introduction to Functions",
    "section": "Function Design",
    "text": "Function Design\nA function is not just a bag of code!\nDesign a function to do one thing.\nMake them as simple as possible. This makes them:\n\nmore comprehensible\neasier to maintain\nreusable\n\nThis helps avoid situations where a team has 20 variations of similar functions.\nGive your function a good name.\n\nIt should reflect the action it performs.\nBe consistent in your naming conventions.\nA name like compute_variances_sort_save_print suggests the function is overworked!\n\nIf the function compute_variances also produces plots and updates variables, it will cause confusion.\nAlways give your function a docstring\n\nParticularly important since indicating data types is not required.\n\nAs a side note, you can include this information by using type annotation.\n\nYou may be interested to learn some of the formatting languages that have been developed to write docstrings. See Lutz 2019 and this web page about Documenting Python Code for more info.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Introduction to Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html",
    "title": "Importing Functions",
    "section": "",
    "text": "Importing\nPreviously we saw that we can extend the functions available to use in a Python program by importing them.\nFor example, we imported the Math module to make its log function available.\nIn this notebook, we cover some basic properties of import statements.\nWe’ll go into greater detail when we cover Modules.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html#importing",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html#importing",
    "title": "Importing Functions",
    "section": "",
    "text": "import math",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html#quick-example",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html#quick-example",
    "title": "Importing Functions",
    "section": "Quick Example",
    "text": "Quick Example\nRecall that calling a function from the import math object is straightforward:\nFor example, to get the square root of \\(12\\) we can now do this:\n\nimport math\n\nmath.sqrt(12)\n\n3.4641016151377544\n\n\n\nmath.floor(2.5)\n\n2\n\n\nHere’s an example using the Random module.\n\nimport random\n\n\nrandom.random()\n\n0.602481588733838\n\n\n\nrandom.randint(1, 100)\n\n8",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html#dot-notation",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html#dot-notation",
    "title": "Importing Functions",
    "section": "Dot Notation",
    "text": "Dot Notation\nWe call functions from imported modules by object using “dot” notation.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html#importing-more-than-one-module",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html#importing-more-than-one-module",
    "title": "Importing Functions",
    "section": "Importing More than One Module",
    "text": "Importing More than One Module\nYou can import as many modules into your code as you’d like.\nWe can do this as follows:\nimport math, random\nOr one import per line:\nimport math\nimport random\nIt is generally preferred to separate import statements by line.\nThis makes you code more readable and modular.\nRegarding modularity, with one import per line, you can do things like this:\nimport math\n# import random\nHere’s we quickly comment out an import statement without having to rewrite our code.\nIt is also a standard practice to put all of your import statements at the very top of your code, before any other code.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html#importing-specific-functions",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html#importing-specific-functions",
    "title": "Importing Functions",
    "section": "Importing Specific Functions",
    "text": "Importing Specific Functions\nIf you know what to use a specific function from an imported module, you can import them directly, like so:\n\nfrom math import sqrt\n\n\nsqrt(99)\n\n9.9498743710662\n\n\nThis reduces the memory used by the library in your program, since it is not importing all of the module’s code.\nIt also allows you to call the function directly, with the object dot notation.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-02-Importing.html#aliasing-imported-functions",
    "href": "notebooks/M04_PythonFunctions/M04-02-Importing.html#aliasing-imported-functions",
    "title": "Importing Functions",
    "section": "Aliasing Imported Functions",
    "text": "Aliasing Imported Functions\nYou can alias the imported function.\nThis avoids having the function name conflict with an existing function in your program.\n\nfrom math import sqrt as SquareRoot\n\n\nSquareRoot(65000)\n\n254.95097567963924",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Importing Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html",
    "href": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html",
    "title": "Lambda Functions",
    "section": "",
    "text": "What’s a Lambda Function?\nPython lambda functions are small functions that can be written on one line.\nLike the one line if/else statement and comprehensions, they represent Python’s lean code writing tradition.\nLambda functions don’t need to be assigned to a variable — you can put them directly in places that expect functions the return, or expressions that evaluate to, values.\nThey sometimes called “anonymous” functions because they don’t have to have a name.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lambda Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html#how-do-you-define-a-lambda-function",
    "href": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html#how-do-you-define-a-lambda-function",
    "title": "Lambda Functions",
    "section": "How Do You Define a Lambda Function?",
    "text": "How Do You Define a Lambda Function?\nThe general form of a lambda function is as follows:\nlambda x: x + 1\nthe first x is the argument, and the x after the colon is the body of the function.\nHere we just add one to the argument.\nThere is no return statement; the function just returns what body of the function evaluates to.\nYou can call the function like this:\n\n(lambda x: x + 1)(2)\n\n3\n\n\nNote how we treat it as an expression by wrapping it in parentheses.\nSince it evaluates to a function, we can use function parentheses at the end.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lambda Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html#assigning-to-a-variable",
    "href": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html#assigning-to-a-variable",
    "title": "Lambda Functions",
    "section": "Assigning to a Variable",
    "text": "Assigning to a Variable\nYou can assign a lambda function to a variable.\nFor example, here are three lambda functions assigned to variables.\n\nsum_two_vars = lambda x, y: x + y\nis_non_negative = lambda x: x &gt;= 0\nis_dirty = lambda txt: 'dirty' in txt\n\n\nsum_two_vars(2, 4)\n\n6\n\n\n\nis_non_negative(-9)\n\nFalse\n\n\n\nis_dirty('dirty dishes')\n\nTrue\n\n\nLambda functions let us do things like this:\n\nfoo = {\n    'addone': lambda x: x + 1,\n    'square': lambda x: x * x,\n    'invert': lambda x: 1 / x\n}\n\nbar = 5 \n\nfor f in foo:\n    print(bar, f, '-&gt;', foo[f](bar))\n\n5 addone -&gt; 6\n5 square -&gt; 25\n5 invert -&gt; 0.2\n\n\nNote, you can also assign function names to variables, but of course you need to define them first.\n\ndef addone(x):\n    return x + 1\ndef square(x):\n    return x * x\ndef invert(x):\n    return 1/x\n\nfoo2 = [add_one, square, invert]\n\nfor f in foo2:\n    print(f(1))\n\n2\n1\n1.0",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lambda Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html#use-cases-for-lambda",
    "href": "notebooks/M04_PythonFunctions/M04-03-LambdaFunctions.html#use-cases-for-lambda",
    "title": "Lambda Functions",
    "section": "Use Cases for Lambda",
    "text": "Use Cases for Lambda\nLambda functions are often used when you need use a function only once.\nSome prefer them for their ability to be part of one-liners.\nLambda functions are often used in Pandas.\nWe will discuss their use in more detail when we get to that topic.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lambda Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html",
    "title": "Recursion",
    "section": "",
    "text": "What is Recursion?\nRecursion in the context of programming occurs when a function calls to itsef.\nThis seems strange, since you’d think that to be called, a function must first be defined … And yet the definition contains a the function!\nThis is a bit like having a dictionary definition use the word it’s trying to define.\nHowever, a function definition is not like a dictionary definition.\nIt does not define a thing. It defines a set of instructions.\nSo, in effect, when a function calls itself, the instruction is:\nEach time the function goes back to the beginning, Python keeps track of the nested function calls in a call stack.\nThis will become clearer with examples.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#what-is-recursion",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#what-is-recursion",
    "title": "Recursion",
    "section": "",
    "text": "“Go back to the beginning of the code block with a new set of argument values.”",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#a-formal-definition",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#a-formal-definition",
    "title": "Recursion",
    "section": "A Formal Definition",
    "text": "A Formal Definition\nIn mathematics and computer science, a class of objects or methods exhibits recursive behavior when it can be defined by two properties:\n\nA simple base case or condition: a terminating scenario that does not use recursion to produce an answer.\nA recursive step: a set of rules that reduces all successive cases toward the base case.\n\nEvery recursive function must have a base condition that stops the recursion or else the function calls itself infinitely.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#a-note-of-caution",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#a-note-of-caution",
    "title": "Recursion",
    "section": "A Note of Caution",
    "text": "A Note of Caution\nIn practice, the Python interpreter limits the depths of recursion to help avoid infinite recursions, resulting in stack overflows.\nWhen excessive memory consumption occurs on the call stack, it results in a stack overflow error.\nRecursion is cool, but is expensive and complicated.\nRecursive functions can usually be implemented by traditional loops.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#example-computing-factorials",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#example-computing-factorials",
    "title": "Recursion",
    "section": "Example: Computing Factorials",
    "text": "Example: Computing Factorials\nThe factorial of a number \\(n\\) is the product of all the integers from \\(1\\) to \\(n\\).\nFor example, the factorial of \\(5\\) (denoted as \\(5!\\)) is \\(1\\times2\\times3\\times4\\times5 = 120\\).\nLet’s implement this in code using a recursive function.\n\ndef factorial(x):\n    \"Finds the factorial of an integer using recursion\"\n    \n    # Base condition\n    if x == 1: \n        return 1\n\n    # Recursive step\n    else:\n        return x * factorial(x - 1) # Self-reference\n\nNote how x gets smaller in the recursive step until it meets the base condition.\n\nn = 5\nfactorial(n)\n\n120\n\n\nThe same thing can be done as a while loop:\n\ndef factorial_while(x):\n    \"Finds the factorial of an integer using a while loop\"\n    result = x\n    while x &gt; 1:\n        x -= 1\n        result *= x\n    return result\n\n\nfactorial_while(n)\n\n120\n\n\nAnd as a for loop:\n\ndef factorial_for(x):\n    \"Finds the factorial of an integer using a for loop\"\n    result = 1\n    for i in range(1, x+1):\n        result *= i\n    return result\n\n\nfactorial_for(n)\n\n120",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#example-the-fibonacci-sequence",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#example-the-fibonacci-sequence",
    "title": "Recursion",
    "section": "Example: The Fibonacci sequence",
    "text": "Example: The Fibonacci sequence\nThe Fibonacci sequence is defined by a series of numbers that equal the sum of the two previous numbers.\nMathematically, we define it as follows:\n\\(Fib(1) = 0\\) (base case 1)\n\\(Fib(2) = 1\\) (base case 2)\nFor all integers \\(n &gt; 2\\), \\(Fib(n) = Fib(n − 1) + Fib(n − 2)\\)\n\nFor \\(n = 8\\) the sequence is \\(0, 1, 1, 2, 3, 5, 8, 13\\).\n\n\ndef fibonacci(n):\n    \"Compute a Fibonacci value using recursion\"\n    if n &lt;= 0:\n        print(\"Incorrect input. Value must be 1 or greater.\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\nHere get the F number for a given positive integer:\n\nn = 8\nfibonacci(n)\n\n13\n\n\nHere we compute the sequence itself:\n\nprint(*[fibonacci(i) for i in range(1, n + 1)])\n\n0 1 1 2 3 5 8 13\n\n\nAs a for loop:\n\ndef fibber(n):\n    \"\"\"\n    Computes a Fibonacci Sequence using a for loop. \n    Returns a string of the series.\n    \"\"\"\n    F = [0,1] \n    for i in range(2, n):\n        F.append(F[i-1] + F[i-2])\n    print(*F)\n\n\nfibber(n)\n\n0 1 1 2 3 5 8 13\n\n\nNote that here, we are letting the data structure do the work.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#aside-a-general-sequence-function",
    "href": "notebooks/M04_PythonFunctions/M04-04-RecursiveFunctions.html#aside-a-general-sequence-function",
    "title": "Recursion",
    "section": "Aside: A General Sequence Function",
    "text": "Aside: A General Sequence Function\nRecursive functions are often used to produce mathematical sequences, but since they have limits on depth, they are of limited use for this purpose.\nHere is a function that can combine many sequences using two sequence parameters: * The initial state of the sequence, represented as the list seq. * For example, in the Fibonacci sequence, seq is [0, 1] * The function to apply to the sequence at each iteration, represneted as a lambda function with the arguments x and i for the the sequence list seq and the iteration number respectively. * For example, in the Fibonacci sequence the kernel function is lambda x, i: x[i-1] + x[i-2]\n\ndef sequencer(n = 10, seq=[1, 1, 2], kernel=lambda x, i: x[i-1] + x[i-2]):\n    \"\"\"\n    Computes a Sequence using a for loop. \n    \n    n: an integer which must be &gt; 3. Defaults to 10.\n    seq: is a list in the initial state of the sequence. \n        Must have at least one value. Defaults to Fibonacci [1,1,2]\n    kernel: the function applied to the series at each iteration. \n        x stands for the seq list, \n        i to the iteration number. \n        Defaults to lambda x, i: x[i-1] + x[i-2]\n    \n    Prints the series as an undelimited string.\n    \"\"\"\n    \n    for i in range(len(seq), n): \n        seq.append(kernel(seq, i))\n        \n    print(*seq)\n\nThe series of positive integers\n\nn = 8\n\n\nsequencer(n, [1], lambda x, i: x[i-1] + 1)\n\n1 2 3 4 5 6 7 8\n\n\nThe series of even numbers\n\nsequencer(n, [2], lambda x, i: x[i-1] + 2)\n\n2 4 6 8 10 12 14 16\n\n\nThe series of odd numbers\n\nsequencer(n, [1], lambda x, i: x[i-1] + 2)\n\n1 3 5 7 9 11 13 15\n\n\nThe series of Fibonacci numbers\n\nsequencer(n, [0,1], lambda x, i: x[i-1] + x[i-2])\n\n0 1 1 2 3 5 8 13\n\n\nThe series of Squares\n\nsequencer(n, [2], lambda x, i: x[i-1]**2)\n\n2 4 16 256 65536 4294967296 18446744073709551616 340282366920938463463374607431768211456",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Recursion</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html",
    "title": "Scope",
    "section": "",
    "text": "What is Scope?\nScope is a fundamental concept in computer programming.\nScope is a property of a variable or other object that refers to where it can be seen in a program.\nTo be seen, or visible, means to be available or usable.\nIf a variable is in scope to a function, it is visible to the function.\nIf it is out of scope to a function, it is not visible to the function.\nScope hinges on the fact that programs have regions within which variables can be assigned.\nThese regions consist of nested code blocks.\nWe saw this distinction when looking at how function arguments work.\nIn the code below, x, y, and z are inside the function, while a, b, and c are outside of it.\nThe code inside the function block is local to the function.\nThe code outside the function block is global to the program.\nTo put it visuallly, the area contained by the red rectangle is local and the area of the green rectangle is global.\nNot that indentation does the work of defining the regions by which scope is defined.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#what-is-scope",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#what-is-scope",
    "title": "Scope",
    "section": "",
    "text": "def my_function(x, y):\n    z = x + y\n    return z\n\na = 10\nb = 20\nc = my_function(x=a, y=b)\n\n\n\n\n\n\nscope.png",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#lutz-on-scoping",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#lutz-on-scoping",
    "title": "Scope",
    "section": "Lutz on Scoping",
    "text": "Lutz on Scoping\nHere’s an excerpt from Lutz, Chapter 17. Please read the whole thing.\nThe enclosing module is a global scope. Each module is a global scope—that is, a namespace in which variables created (assigned) at the top level of the module file live. Global variables become attributes of a module object to the outside world after imports but can also be used as simple variables within the module file itself.\nThe global scope spans a single file only. Don’t be fooled by the word “global” here—names at the top level of a file are global to code within that single file only. There is really no notion of a single, all-encompassing global file-based scope in Python. Instead, names are partitioned into modules, and you must always import a module explicitly if you want to be able to use the names its file defines. When you hear “global” in Python, think “module.”\nAssigned names are local unless declared global or nonlocal. By default, all the names assigned inside a function definition are put in the local scope (the namespace associated with the function call). If you need to assign a name that lives at the top level of the module enclosing the function, you can do so by declaring it in a global statement inside the function. If you need to assign a name that lives in an enclosing def, as of Python 3.X you can do so by declaring it in a nonlocal statement.\nAll other names are enclosing function locals, globals, or built-ins. Names not assigned a value in the function definition are assumed to be enclosing scope locals, defined in a physically surrounding def statement; globals that live in the enclosing module’s namespace; or built-ins in the predefined built-ins module Python provides.\nEach call to a function creates a new local scope. Every time you call a function, you create a new local scope—that is, a namespace in which the names created inside that function will usually live. You can think of each def statement (and lambda expression) as defining a new local scope, but the local scope actually corresponds to a function call. Because Python allows functions to call themselves to loop—an advanced technique known as recursion and noted briefly in Chapter 9 when we explored comparisons—each active call receives its own copy of the function’s local variables. Recursion is useful in functions we write as well, to process structures whose shapes can’t be predicted ahead of time; we’ll explore it more fully in Chapter 19.\nThere are actually other scope levels.\nHere is a nice visualization of them:\n\n\n\nScope Levels\n\n\nPlease read Lutz, Chapter 17 for a good overview of scoping.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#the-tinted-glass-metaphor",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#the-tinted-glass-metaphor",
    "title": "Scope",
    "section": "The Tinted Glass Metaphor",
    "text": "The Tinted Glass Metaphor\n\nCode regions in a program are like vehicles with tinted glass:\n\nPassengers can see outside, but outsiders can’t see inside.\nPassengers in a vehicle can let outsiders look in by lowering the window.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-1",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-1",
    "title": "Scope",
    "section": "Example 1",
    "text": "Example 1\nA variable x i defined outside a function but used inside of it.\nIn the code below x is global and seen from inside the function.\nThe variable a is local to the function.\nTrying to print outside function throws error.\n\nx = 10\n\ndef scope_func1(a):\n    out = x + a\n    return out\n\nThe following works because x is global and functions can access globals so long as they don’t reassign the variable name.\n\ny = scope_func1(6)\nprint(y)\n\n16\n\n\nThe following fails because a local and not visible outside the function.\n\nprint(a)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n/tmp/ipykernel_833819/1189138062.py in &lt;module&gt;\n----&gt; 1 print(a)\n\nNameError: name 'a' is not defined",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-2",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-2",
    "title": "Scope",
    "section": "Example 2",
    "text": "Example 2\nA variable x defined both outside and inside function, and used inside the function.\nThis function reassigns x, so it becomes local.\nA variable becomes local once it is used in an assignment statement within a function, or if it is the name of an argument.\n\nx = 10 # Global\n\ndef scope_func2(a):\n    x = 20 # Local\n    print('x from inside:', x)\n    out = x + a\n    return out\n\n\ny = scope_func2(6)\nprint(y)\nprint('x from outside:', x)\n\nx from inside: 20\n26\nx from outside: 10",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-2a",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-2a",
    "title": "Scope",
    "section": "Example 2a",
    "text": "Example 2a\nHere we define x as an argument.\nThis has the same effect as defining it in the body of the function.\n\nx = 10 # Global\n\ndef scope_func2a(a, x=20): # Argment variables are local\n    print('x from inside:', x)\n    out = x + a\n    return out\n\n\ny = scope_func2a(6)\nprint(y)\nprint('x from outside:', x)\n\nx from inside: 20\n26\nx from outside: 10\n\n\nAs an argument, though, it can be assigned the value of the global.\nNevertheless, only the value is being passed between the global and local versions of x.\n\nx = 10 # Global\n\ndef scope_func2a(a, x=20):\n\n    print('x from inside before incremenet:', x)\n    x += 10\n    print('x from inside after incremenet:', x)\n    \n    out = x + a\n    \n    return out\n\n\ny = scope_func2a(6, x=x)\nprint(y)\nprint('x from outside :', x)\n\nx from inside before incremenet: 10\nx from inside after incremenet: 20\n26\nx from outside : 10",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-3",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#example-3",
    "title": "Scope",
    "section": "Example 3",
    "text": "Example 3\nA variable x defined both outside and inside function, and used inside the function in both global and local modes.\nThis one is interesting. It fails, but it’s not clear why at first.\n\nx = 10\n\ndef scope_func3(a):\n    print('x from fcn, before local definition:', x) # Global use of x\n    x = 20 # Local use of x\n    print('x from fcn, after local definition:', x)\n    out = x + a\n    return out\n\n\nprint('x from outside before local definition:', x)\nscope_func3(6)\nprint('x from outside after local definition:', x)\n\nx from outside before local definition: 30\n\n\n\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n/tmp/ipykernel_833819/2019026568.py in &lt;module&gt;\n      1 print('x from outside before local definition:', x)\n----&gt; 2 scope_func3(6)\n      3 print('x from outside after local definition:', x)\n\n/tmp/ipykernel_833819/3644353993.py in scope_func3(a)\n      2 \n      3 def scope_func3(a):\n----&gt; 4     print('x from fcn, before local definition:', x) # Global use of x\n      5     x = 20 # Local use of x\n      6     print('x from fcn, after local definition:', x)\n\nUnboundLocalError: local variable 'x' referenced before assignment\n\n\n\nThe problem is that Python knows you are assigning x within the local scope of the function, so it won’t allow you to use it until it is defined.\nThe error can be fixed by referencing x as global inside function.\n\nx = 10\n\ndef scope_func4(a):\n    global x\n    \n    print('x from inside, before local definition:', x)\n    x = 20\n    print('x from inside, after local definition:', x)\n    \n    out = x + a\n    return out\n\n\ny = scope_func4(6)\nprint(y)\nprint('x from outside:', x)\n\nx from inside, before local definition: 10\nx from inside, after local definition: 20\n26\nx from outside: 20",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#local-global-conflicts",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#local-global-conflicts",
    "title": "Scope",
    "section": "Local / global conflicts",
    "text": "Local / global conflicts\nWhat will calling guess() do?\n\nx = 10\n\ndef guess():\n    x += 10 \n    print(x)\n\n\nguess()\n\n\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n/tmp/ipykernel_833819/2016184111.py in &lt;module&gt;\n----&gt; 1 guess()\n\n/tmp/ipykernel_833819/3992268873.py in guess()\n      2 \n      3 def guess():\n----&gt; 4     x += 10\n      5     print(x)\n\nUnboundLocalError: local variable 'x' referenced before assignment\n\n\n\nConsider the following expression, which is the same as the unary operation inside of the function guess().\n\nx = x + 10\n\nThe x on the left is local, since it is being defined inside the function.\nHowever, the x on the right is assumed to already be defined, and so is global.\nIn effect, Python is presented with a contradiction and so throws an error.\nWe will see that R does not do this; it just goes with the global.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#nonlocal",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#nonlocal",
    "title": "Scope",
    "section": "Nonlocal",
    "text": "Nonlocal\nIf a variable is assigned in an enclosing def, it is nonlocal to nested functions.\nThe nonlocal keyword is similar to global, except that it refers to the scope of the enclosing function, not the script that contains the funtions.\n\nx = 10 # Global\ndef func1(): # Enclosing function\n    x = 20 # Local to function; \"Nonlocal\" to nested function\n    def func1a():\n        x = 30 # Local to nested function\n        print(x)\n    func1a()\n    print(x)\n\n\nprint(x)\nfunc1()\nprint(x)\n\n10\n30\n20\n10\n\n\n\nx = 10\ndef func2():\n    x = 20\n    def func2a():\n        nonlocal x\n        x = 30\n        print(x)\n    func2a()\n    print(x)\n\n\nprint(x) # 1\nfunc2()\nprint(x) # 4\n\n10\n30\n30\n10\n\n\n\nx = 10\ndef func3():\n    x = 20\n    def func3a():\n        global x\n        x = 30\n        print(x)\n    func3a()\n    print(x)\n\n\nprint(x)\nfunc3()\nprint(x)\n\n10\n30\n20\n30",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#namespaces",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#namespaces",
    "title": "Scope",
    "section": "Namespaces",
    "text": "Namespaces\nYou may wonder how Python keeps track to two variables with the same name in a program.\nFor example, when x is defined both globally and locally within the same program.\nPython solves this problem by giving each region a name.\nThe region becomes a namespace.\nWith namespaces, a unique name to associated with each and every object in a Python program.\nNamespacea work like the file system on a computer.\nJust as you can have many files of the same name as long as they are in different folders.\nThe complete name of the file is actually the filename and the names of its parent folders, i.e. the path to the file in the file system.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#globals-and-locals",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#globals-and-locals",
    "title": "Scope",
    "section": "globals() and locals()",
    "text": "globals() and locals()\nPython keeps track of objects and namespaces in a dictionary. You can access local and global variables with globals() and locals().\n\ndef foo():\n    x = 1\n    print(locals())\n\n\nfoo()\n\n{'x': 1}\n\n\n\nG = globals()\n\n\nG['foo']\n\n&lt;function __main__.foo()&gt;\n\n\n\n[key for key in globals().keys() if not key.startswith('_')]\n\n['In',\n 'Out',\n 'get_ipython',\n 'exit',\n 'quit',\n 'x',\n 'scope_func2',\n 'y',\n 'scope_func2a',\n 'scope_func1',\n 'scope_func3',\n 'scope_func4',\n 'guess',\n 'func1',\n 'func2',\n 'func3',\n 'foo',\n 'G']",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-05-Scope.html#some-visualizations",
    "href": "notebooks/M04_PythonFunctions/M04-05-Scope.html#some-visualizations",
    "title": "Scope",
    "section": "Some Visualizations",
    "text": "Some Visualizations\n\nThe same object name can be present in multiple namespaces as isolation between the same name is maintained by their namespace.\n\nSource: “Namespaces and Scope in Python” (GFG).",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Scope</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html",
    "href": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html",
    "title": "Function Groups",
    "section": "",
    "text": "Example 1: Converting Temperatures\nHere are three functions that work together to make a temperature converter.\nNotice how the last function integrates the first two.\ndef f_to_c(temp):  \n    \"\"\"\n    Converts F to C and returns a rounded result.\n    Expects an integer and returns an integer.\n    \"\"\"\n    return round((temp - 32) * (5/9))\n    \ndef c_to_f(temp):  \n    \"\"\"\n    Converts C to F and returns a rounded result.\n    Expects an integer and returns an integer.\n    \"\"\"\n    return round(temp * (9/5) + 32)\n    \ndef convert(temp, scale): \n    \"\"\"\n    Combines conversion functions into a two-way converter.\n    Expects a souce temp (int) and a target scale ('f' or 'c').\n    \"\"\"\n    if scale.lower() == \"c\":\n        return f_to_c(temp)  # function call to f_to_c\n    else:\n        return c_to_f(temp)  # function call to c_to_f\nNow, here is function that combines the above functions into a user-facing interface to the other functions.\ndef convert_app():\n    \"\"\"\n    Provides a user-interface to the the conversion functions.\n    \"\"\"\n    \n    # Get user input\n    temp = int(input(\"Enter a temperature: \"))                \n    scale = input(\"Enter the scale to convert to: (c or f) \")[0].lower()\n    \n    # Infer source scale, to be used in the output message\n    if scale == 'c':\n        current_scale = 'f'\n    else:\n        current_scale = 'c'\n    \n    # Do the conversion\n    converted = convert(temp, scale)\n    \n    # Print results for user\n    print(f\"{temp}{current_scale.upper()} is equal to {converted}{scale.upper()}.\")\nconvert_app()\n\nEnter a temperature:  45\nEnter the scale to convert to: (c or f)  f\n45C is equal to 113F.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Function Groups</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#example-1-converting-temperatures",
    "href": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#example-1-converting-temperatures",
    "title": "Function Groups",
    "section": "",
    "text": "A More Pythonic Solution\nWe replace if/then statements with dictionary keys.\nThe keys represent the target temperature scale to which we are converting.\nEssentially, we put your logic in the data structure.\n\nconverters = {\n    'c': lambda t: (t - 32) * (5/9),\n    'f': lambda t: t * (9/5) + 32\n}\n\n\ndef convert_app2():\n    \n    # Input from user\n    source_temp  = int(input(\"Enter a temperature: \"))                \n    target_scale = input(\"Enter the scale to convert to: (c or f) \")\n    \n    # Convert from one scale to the other\n    target_temp  = converters[target_scale](source_temp)\n\n    # Get the source scale for display purposes\n    source_scale = list(set(converters.keys()) - set(target_scale))[0]\n    \n    # Output to user\n    print(source_temp, source_scale, \"converted becomes:\" , round(target_temp), target_scale)\n\n\nconvert_app2()\n\nEnter a temperature:  45\nEnter the scale to convert to: (c or f)  f\n45 c converted becomes: 113 f",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Function Groups</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#example-2-counting-vowels",
    "href": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#example-2-counting-vowels",
    "title": "Function Groups",
    "section": "Example 2: Counting Vowels",
    "text": "Example 2: Counting Vowels\nHere is another example of functions calling each other in increasing levels of complexity.\n\ndef is_vowel(letter):\n    \"Tests if a letter is a vowel.\"\n    return letter in \"aeiou\"\n        \ndef num_vowels(my_string):\n    \"Counts the number of vowels in a string.\"    \n    my_string = my_string.lower()\n    count = 0\n    for i in range(len(my_string)): # for each character\n        if is_vowel(my_string[i]):  # call function above\n            count += 1              # increment count if true\n    return count\n\n    # A more concise way:\n    # return sum([is_vowel(letter) for letter in my_string.lower()])\n    \ndef vowel_counter():\n    \"User interface to return the number of vowels in a given string.\"\n    my_str = input(\"Enter a string: \")\n    vcount = num_vowels(my_str)\n    print(f\"There are {vcount} vowels in the string.\")\n\n\nvowel_counter()\n\nEnter a string:  This is a string.\nThere are 4 vowels in the string.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Function Groups</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#example-3-calculating-tax",
    "href": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#example-3-calculating-tax",
    "title": "Function Groups",
    "section": "Example 3: Calculating Tax",
    "text": "Example 3: Calculating Tax\nIn this example, we define a group of functions to perform a more complicated task. We want to compute the taxes owed for an income and a tax rate. We want our user to enter an income and to get their tax bill back.\nTo compute tax, we have these data:\ngross_pay    tax_rate\n---------------------\n0   - 240    0%\n241 - 480    15%\n481 - more   28% \nWe write two related functions:\n\nOne to compute the tax based on a gross pay and a tax rate.\nOne to compute the net pay using the previous function.\n\nIn addition, we write functions that use these functions to interact with a user.\n\nOne to get the input value of the gross pay and print the tax.\nOne to print the net pay based on the previous function.\n\nNote the division of labor, or “separation of concerns”, in these functions:\n\nSome do calculative work.\nSome do interactive work.\n\nTo meet these requirements, we create a group of functions that expect some global variables to exist and use these instead of return statements.\n\ndef compute_tax():\n    \"\"\"\n    Computes tax rate and applies to gross pay to get tax.\n    Expects gross_pay to be defined globally.\n    Adds tax_rate and tax to globals for use by other functins.\n    \"\"\"\n    global tax_rate, tax\n    # Get rate by lower bound\n    if gross_pay &gt; 480:\n        tax_rate = .28\n    elif gross_pay &gt; 240:\n        tax_rate = .15\n    else:\n        tax_rate = 0\n    tax = gross_pay * tax_rate\n            \ndef compute_net_pay():\n    \"\"\"\n    Computes net pay based on globals produced by compute_tax().\n    Expects gross_pay and tax to be defined globally.\n    Adds net_pay to to globals.\n    \"\"\"\n    global net_pay\n    net_pay = gross_pay - tax\n\ndef get_tax():   \n    \"\"\"\n    Computes and prints tax based on user input.\n    Essentially a wrapper around compute_tax().\n    Adds gross_pay to globals.\n    \"\"\"\n    global gross_pay\n    gross_pay = int(input(\"Enter your gross pay in dollars: \"))                            \n    compute_tax()\n    print(f\"Based on a tax rate of {round(tax_rate * 100)}%, the tax you owe on ${gross_pay} is ${round(tax)}.\")\n    \ndef get_net_pay():\n    \"\"\"\n    Computes and prints net pay based on globals.\n    \"\"\"\n    compute_net_pay()\n    print(f\"Your take home (net) pay is ${round(net_pay)}.\")\n    \ndef do_all():\n    \"Runs both user-facing functions.\"\n    get_tax()\n    get_net_pay()\n\n\nget_tax()\n\nEnter your gross pay in dollars:  1000000\nBased on a tax rate of 28%, the tax you owe on $1000000 is $280000.\n\n\n\nget_net_pay()\n\nYour take home (net) pay is $720000.\n\n\n\ndo_all()\n\nEnter your gross pay in dollars:  1000000\nBased on a tax rate of 28%, the tax you owe on $1000000 is $280000.\nYour take home (net) pay is $720000.\n\n\nNotice how none of the functions return a value.\nNor do they take arguments.\nInstead, they give and take from the global namespace.\nThis is effective when our global environment — the containing script — contains only these functions.\nLater in this course, we will look at mechanisms to segment our code in this way.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Function Groups</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#concluding-observations",
    "href": "notebooks/M04_PythonFunctions/M04-06-FunctionsCallingFunctions.html#concluding-observations",
    "title": "Function Groups",
    "section": "Concluding Observations",
    "text": "Concluding Observations\nNotice how each example has functions that build on each other.\nThese functions share both data and a general goal.\nThe fact that data and functions go together is the motivation for creating classes.",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Function Groups</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-00-Time.html",
    "href": "notebooks/M05_NumPy/M05-00-Time.html",
    "title": "Python Timing",
    "section": "",
    "text": "The time module\nOne way to to measure how long it takes a block of code to run is to use the time module.\nThis module provides a number of functions to get and compute time.\nThe simplest function is time(), which returns the number of seconds elapsed since the Epoch.\nThe Epoch is 00:00:00 UTC on 1 January 1970, excluding leapseconds.\nIt corresponds roughly to when Unix was invented.\nTo get the time of a block, we get the time before the code runs \\(t_0\\) and substract it from the time the code finishes \\(t_1\\). Let’s try this by comparing a simple loop and comprehension.\nfrom time import time\nt0 = time() # START\nfor i in range(10):\n    print(i, end=' ')\nt1 = time() # END\n\n0 1 2 3 4 5 6 7 8 9\nt3 = time()\n_ = [print(i, end=' ') for i in range(10)]\nt4 = time()\n\n0 1 2 3 4 5 6 7 8 9\ndelta_loop = t1 - t0\ndelta_comp = t4 - t3\nprint('loop:', delta_for)\nprint('comp:', delta_comp)\nprint('loop/comp:', round(delta_loop/delta_comp, 2))\n\nloop: 8.58306884765625e-05\ncomp: 9.298324584960938e-05\nloop/comp: 0.92\nInterestingly, the for loop is faster than the comprehension.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Python Timing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-00-Time.html#using-timeit",
    "href": "notebooks/M05_NumPy/M05-00-Time.html#using-timeit",
    "title": "Python Timing",
    "section": "Using timeit",
    "text": "Using timeit\nTo get a better measure of runtime, we can use the timeit module.\nThie module measures timing across many runs.\nSince timeit() will return the runtime across all runs, we divide by the number of runs to get the mean runtime.\ntimeit() works by evaluating code blocks written as strings.\nLet’s compare two funcitons using timeit:\n\nfrom timeit import timeit\n  \nnum_runs = 100\n\nloop_code = ''' \nvals = []\nfor i in range(1, 100001):\n    if i % 2 == 1:\n        i *= -1\n    vals.append(i)\n'''\n\ncomp_code = ''' \nvals = [i * -1 if i % 2 == 1 else i for i in range(1, 100001)]\n'''\n\nloop_mean_time = timeit(stmt = loop_code, number = num_runs) / num_runs\ncomp_mean_time = timeit(stmt = comp_code, number = num_runs) / num_runs\nt_diff = loop_mean_time / comp_mean_time\nprint('loop =', loop_mean_time)\nprint('comp =', comp_mean_time)\nprint('loop/list =', t_diff)\nprint('list/loop =', 1/t_diff)\n\nloop = 0.005688848439604044\ncomp = 0.0046883809473365545\nloop/list = 1.2133929609188114\nlist/loop = 0.8241353231872839",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Python Timing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-00-Time.html#using-magic",
    "href": "notebooks/M05_NumPy/M05-00-Time.html#using-magic",
    "title": "Python Timing",
    "section": "Using Magic",
    "text": "Using Magic\nInstead of calling time and timeit directly, we can use the so-called magic commands.\nMagic commands are % or %% prefixed commands that work in Jupyter notebooks and other IPython environments.\n% commands apply to single lines; they go at the beginning of the line.\n%% commands apply to cell blocks; they go at the top of the cell.\nPlacing %%timeit or %%time at the top of a cell will appy these functions to the cell block.\nPlacing %timeit or %time as the first item on a line of code will apply the to a single line.\nNote that magic commands can take arguments.\nFor more on this topic, see Chapter 3 of Wes McKinney’s Python for Data Analysis and the official documentation\nLet’s look at an example, similar to those above, comparing a loop to a comprehension.\ntime\n\nimax = 10000\n\n\n%%time\nvals = []\nfor i in range(1, imax+1):\n    if i % 2 == 1:\n        i *= -1\n    vals.append(i)\n\nCPU times: user 1.17 ms, sys: 0 ns, total: 1.17 ms\nWall time: 1.18 ms\n\n\n\n%time vals = [i*-1 if i % 2 == 1 else i for i in range(1,imax+1)] \n\nCPU times: user 528 µs, sys: 0 ns, total: 528 µs\nWall time: 538 µs\n\n\ntimeit\n\n%%timeit\n\nvals = []\nimax = 10000\nfor i in range(1, imax+1):\n    if i % 2 == 1:\n        i *= -1\n    vals.append(i)\n\n507 µs ± 1.28 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\n%timeit vals = [i*-1 if i % 2 == 1 else i for i in range(1,imax+1)] \n\n469 µs ± 1.04 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Python Timing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-00-Time.html#types-of-time",
    "href": "notebooks/M05_NumPy/M05-00-Time.html#types-of-time",
    "title": "Python Timing",
    "section": "Types of Time",
    "text": "Types of Time\nNote that the return values of time contain a detailed description of results, including three kinds of CPU time and wall time.\nWall time measures how much time has passed, as if you were looking at the clock on your wall.\nCPU time refers to how many seconds the CPU was actually busy.\nIn CPU time, user time is the amount of time a processor spends running application code.\nSystem time is the amount of time it spends running operating system functions related to the application.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Python Timing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html",
    "title": "Basic File I/O",
    "section": "",
    "text": "Motivation\nAnother useful topic that we will introduce now concerns how to read and write data to and from sources external to your program.\nExternal sources include the file system, the web, or an external database.\nWe call reading your data to and from files file I/O, where I/O stands for input and output.\nPython provides a function for file i/o — open().\nWe will discuss this along with a use case of importing structured data from a file.\nThis will motivate the use of more sophisticated tools such as we will encounter with NumPy and Pandas.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#open-files-with-open",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#open-files-with-open",
    "title": "Basic File I/O",
    "section": "Open Files with open()",
    "text": "Open Files with open()\nPython’s open() function allows you to read and write files from the file system, or, as we sometimes say, “from disk.”\nA common use case is opening up a text file containing data you want to work with, such as a CSV file.\nCSV means “Comma Separated Values.”\nA CSV file is a plain text file where each line has a list of data items separated (i.e. delimitied) by a comma (or other character, such as tab).\nEach row should have the same number of delimited items.\nOften, but not always, the first line contains the names of the columns for the delimited data.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#biostats-data",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#biostats-data",
    "title": "Basic File I/O",
    "section": "Biostats Data",
    "text": "Biostats Data\nLet’s open a sample CSV file, biostats.csv.\nBecause we want to convert it into a Python data structure, we need to know something about how the source file is structured. Here are some basic facts about the file:\n\nIt has some biometric statistics for a group of office workers.\nThere are 18 records, recording Name, Sex, Age, Height, Weight\nThere is an initial header line.\n\nThis file was downloaded from https://people.sc.fsu.edu/~jburkardt/data/csv/csv.html and modified slightly.\nLet’s open a downloaded version.\n\nsrc_file_name = \"./sample_data_files/biostats.csv\"\nfile_handle = open(src_file_name, 'r')\n\nThe open() function takes two parameters:\n\nThe name of the file we want to open.\nThe mode in which the file is opened. It defaults to r which means open for reading in text mode. Other common values are:\n\nw for writing (truncating the file if it already exists)\nx for creating and writing to a new file\na for appending\n\n\nThis returns a file an iterator.\nWe sometimes call the file object a file “handle.”\nTo get the contents of the file into the program, we have a couple of options.\n.read() reads in the file as one long string.\n.readlines() reads in the file as a list of lines, created by the hard returns \\n in the source file.\nLet’s look at the first function:\n\nfile_as_big_string = file_handle.read()\n\n\nfile_as_big_string[:1000]\n\n'\"Name\",     \"Sex\", \"Age\", \"Height (in)\", \"Weight (lbs)\"\\n\"Alex\",       \"M\",   41,       74,      170\\n\"Bert\",       \"M\",   42,       68,      166\\n\"Carl\",       \"M\",   32,       70,      155\\n\"Dave\",       \"M\",   39,       72,      167\\n\"Elly\",       \"F\",   30,       66,      124\\n\"Fran\",       \"F\",   33,       66,      115\\n\"Gwen\",       \"F\",   26,       64,      121\\n\"Hank\",       \"M\",   30,       71,      158\\n\"Ivan\",       \"M\",   53,       72,      175\\n\"Jake\",       \"M\",   32,       69,      143\\n\"Kate\",       \"F\",   47,       69,      139\\n\"Luke\",       \"M\",   34,       72,      163\\n\"Myra\",       \"F\",   23,       62,       98\\n\"Neil\",       \"M\",   36,       75,      160\\n\"Omar\",       \"M\",   38,       70,      145\\n\"Page\",       \"F\",   31,       67,      135\\n\"Quin\",       \"M\",   29,       71,      176\\n\"Ruth\",       \"F\",   28,       65,      131'\n\n\nSince the file object is an iterator, we can’t get the string again from the object.\n\nfile_as_big_string = file_handle.read()\nfile_as_big_string[:1000]\n\n''\n\n\nSo, let’s create a new handle, read in the contents again, and then parse our string by newlines using .split(\"\\n\").\n\nfile_handle = open(\"./sample_data_files/biostats.csv\", 'r')\nfile_as_big_string = file_handle.read()\nfile_as_big_string.split(\"\\n\")\n\n['\"Name\",     \"Sex\", \"Age\", \"Height (in)\", \"Weight (lbs)\"',\n '\"Alex\",       \"M\",   41,       74,      170',\n '\"Bert\",       \"M\",   42,       68,      166',\n '\"Carl\",       \"M\",   32,       70,      155',\n '\"Dave\",       \"M\",   39,       72,      167',\n '\"Elly\",       \"F\",   30,       66,      124',\n '\"Fran\",       \"F\",   33,       66,      115',\n '\"Gwen\",       \"F\",   26,       64,      121',\n '\"Hank\",       \"M\",   30,       71,      158',\n '\"Ivan\",       \"M\",   53,       72,      175',\n '\"Jake\",       \"M\",   32,       69,      143',\n '\"Kate\",       \"F\",   47,       69,      139',\n '\"Luke\",       \"M\",   34,       72,      163',\n '\"Myra\",       \"F\",   23,       62,       98',\n '\"Neil\",       \"M\",   36,       75,      160',\n '\"Omar\",       \"M\",   38,       70,      145',\n '\"Page\",       \"F\",   31,       67,      135',\n '\"Quin\",       \"M\",   29,       71,      176',\n '\"Ruth\",       \"F\",   28,       65,      131']\n\n\nThis creates a list of lines, each containing a string of delimited data.\nA short-cut to this process is to call the .readlines() method, which returns a pre-made list of lines.\n\nfile_handle = open(src_file_name, 'r')\nfile_as_list_of_strings = file_handle.readlines()\nfile_as_list_of_strings\n\n['\"Name\",     \"Sex\", \"Age\", \"Height (in)\", \"Weight (lbs)\"\\n',\n '\"Alex\",       \"M\",   41,       74,      170\\n',\n '\"Bert\",       \"M\",   42,       68,      166\\n',\n '\"Carl\",       \"M\",   32,       70,      155\\n',\n '\"Dave\",       \"M\",   39,       72,      167\\n',\n '\"Elly\",       \"F\",   30,       66,      124\\n',\n '\"Fran\",       \"F\",   33,       66,      115\\n',\n '\"Gwen\",       \"F\",   26,       64,      121\\n',\n '\"Hank\",       \"M\",   30,       71,      158\\n',\n '\"Ivan\",       \"M\",   53,       72,      175\\n',\n '\"Jake\",       \"M\",   32,       69,      143\\n',\n '\"Kate\",       \"F\",   47,       69,      139\\n',\n '\"Luke\",       \"M\",   34,       72,      163\\n',\n '\"Myra\",       \"F\",   23,       62,       98\\n',\n '\"Neil\",       \"M\",   36,       75,      160\\n',\n '\"Omar\",       \"M\",   38,       70,      145\\n',\n '\"Page\",       \"F\",   31,       67,      135\\n',\n '\"Quin\",       \"M\",   29,       71,      176\\n',\n '\"Ruth\",       \"F\",   28,       65,      131']\n\n\nNote that the newlines are preserved in this case.\nWe could fix this by opening the file in a comprehension, like so:\n\nfile_handle = open(src_file_name, 'r')\nfile_as_list_of_strings = [line.rstrip() for line in file_handle.readlines()]\nfile_as_list_of_strings  \n\n['\"Name\",     \"Sex\", \"Age\", \"Height (in)\", \"Weight (lbs)\"',\n '\"Alex\",       \"M\",   41,       74,      170',\n '\"Bert\",       \"M\",   42,       68,      166',\n '\"Carl\",       \"M\",   32,       70,      155',\n '\"Dave\",       \"M\",   39,       72,      167',\n '\"Elly\",       \"F\",   30,       66,      124',\n '\"Fran\",       \"F\",   33,       66,      115',\n '\"Gwen\",       \"F\",   26,       64,      121',\n '\"Hank\",       \"M\",   30,       71,      158',\n '\"Ivan\",       \"M\",   53,       72,      175',\n '\"Jake\",       \"M\",   32,       69,      143',\n '\"Kate\",       \"F\",   47,       69,      139',\n '\"Luke\",       \"M\",   34,       72,      163',\n '\"Myra\",       \"F\",   23,       62,       98',\n '\"Neil\",       \"M\",   36,       75,      160',\n '\"Omar\",       \"M\",   38,       70,      145',\n '\"Page\",       \"F\",   31,       67,      135',\n '\"Quin\",       \"M\",   29,       71,      176',\n '\"Ruth\",       \"F\",   28,       65,      131']\n\n\nFile objects should be closed when you are done with them.\n\nfile_handle.close()",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#using-a-with-block",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#using-a-with-block",
    "title": "Basic File I/O",
    "section": "Using a with block",
    "text": "Using a with block\nTo automatically open and close the file i/o object, we can use a with block.\nThis automatically closes the file handle once the program moves out of the block.\n\nwith open(src_file_name, 'r') as infile:\n    file_as_list = [line.rstrip() for line in infile.readlines()]\n\n\nfile_as_list\n\n['\"Name\",     \"Sex\", \"Age\", \"Height (in)\", \"Weight (lbs)\"',\n '\"Alex\",       \"M\",   41,       74,      170',\n '\"Bert\",       \"M\",   42,       68,      166',\n '\"Carl\",       \"M\",   32,       70,      155',\n '\"Dave\",       \"M\",   39,       72,      167',\n '\"Elly\",       \"F\",   30,       66,      124',\n '\"Fran\",       \"F\",   33,       66,      115',\n '\"Gwen\",       \"F\",   26,       64,      121',\n '\"Hank\",       \"M\",   30,       71,      158',\n '\"Ivan\",       \"M\",   53,       72,      175',\n '\"Jake\",       \"M\",   32,       69,      143',\n '\"Kate\",       \"F\",   47,       69,      139',\n '\"Luke\",       \"M\",   34,       72,      163',\n '\"Myra\",       \"F\",   23,       62,       98',\n '\"Neil\",       \"M\",   36,       75,      160',\n '\"Omar\",       \"M\",   38,       70,      145',\n '\"Page\",       \"F\",   31,       67,      135',\n '\"Quin\",       \"M\",   29,       71,      176',\n '\"Ruth\",       \"F\",   28,       65,      131']\n\n\nwith blocks can be used with other handles, too, like database connections.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#converting-to-a-2d-list",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#converting-to-a-2d-list",
    "title": "Basic File I/O",
    "section": "Converting to a 2D list",
    "text": "Converting to a 2D list\nLet’s convert our list of strings to a list of lists, where each element of the first list is a row and each element of the second list is a cell containing data.\nThe shared index positions of the cells in the rows can be thought of as columns.\n\nlist_2d = []\nwith open(src_file_name, 'r') as infile:\n    for line in infile.readlines():\n        row = line.rstrip().split(\",\")   \n        new_row = []\n        for cell in row:\n            new_row.append(cell.strip().replace('\"', ''))\n        list_2d.append(new_row)\n\n\nlist_2d[:5]\n\n[['Name', 'Sex', 'Age', 'Height (in)', 'Weight (lbs)'],\n ['Alex', 'M', '41', '74', '170'],\n ['Bert', 'M', '42', '68', '166'],\n ['Carl', 'M', '32', '70', '155'],\n ['Dave', 'M', '39', '72', '167']]",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#using-a-nested-comprehension",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#using-a-nested-comprehension",
    "title": "Basic File I/O",
    "section": "Using a Nested Comprehension",
    "text": "Using a Nested Comprehension\nWe can replace the entire code block above nested list comprehensions.\nRemember, you can put any expression into the first part of a comprehension, even another comprehension.\n\nlist_2d = [[cell.strip() \n            for cell in line.rstrip().replace('\"', '').split(\",\")] \n            for line in open(src_file_name, 'r').readlines()]\n\n\nlist_2d\n\n[['Name', 'Sex', 'Age', 'Height (in)', 'Weight (lbs)'],\n ['Alex', 'M', '41', '74', '170'],\n ['Bert', 'M', '42', '68', '166'],\n ['Carl', 'M', '32', '70', '155'],\n ['Dave', 'M', '39', '72', '167'],\n ['Elly', 'F', '30', '66', '124'],\n ['Fran', 'F', '33', '66', '115'],\n ['Gwen', 'F', '26', '64', '121'],\n ['Hank', 'M', '30', '71', '158'],\n ['Ivan', 'M', '53', '72', '175'],\n ['Jake', 'M', '32', '69', '143'],\n ['Kate', 'F', '47', '69', '139'],\n ['Luke', 'M', '34', '72', '163'],\n ['Myra', 'F', '23', '62', '98'],\n ['Neil', 'M', '36', '75', '160'],\n ['Omar', 'M', '38', '70', '145'],\n ['Page', 'F', '31', '67', '135'],\n ['Quin', 'M', '29', '71', '176'],\n ['Ruth', 'F', '28', '65', '131']]",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#converting-to-data-types",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#converting-to-data-types",
    "title": "Basic File I/O",
    "section": "Converting to Data Types",
    "text": "Converting to Data Types\nIf we were to continue the process of importing this data set, we’d need to convert the data into their proper types.\nWe can see that there are three data types in the set: Strings, Categories, and Integers.\nWe’d have to write a another segment of code to identify data type by row position and use casting functions, such as int(), to do this. Also, since basic Python doesn’t have a data type for categories, we’d have to think about we handle M and F.\n[['Name', 'Sex', 'Age', 'Height (in)', 'Weight (lbs)'],\n ['Alex', 'M', '41', '74', '170'],\n ['Bert', 'M', '42', '68', '166'],\n ['Carl', 'M', '32', '70', '155'],\n ['Dave', 'M', '39', '72', '167'],\n ['Elly', 'F', '30', '66', '124'],\n ['Fran', 'F', '33', '66', '115'],\n ['Gwen', 'F', '26', '64', '121'],\n ['Hank', 'M', '30', '71', '158'],\n ['Ivan', 'M', '53', '72', '175'],\n ['Jake', 'M', '32', '69', '143'],\n ['Kate', 'F', '47', '69', '139'],\n ['Luke', 'M', '34', '72', '163'],\n ['Myra', 'F', '23', '62', '98'],\n ['Neil', 'M', '36', '75', '160'],\n ['Omar', 'M', '38', '70', '145'],\n ['Page', 'F', '31', '67', '135'],\n ['Quin', 'M', '29', '71', '176'],\n ['Ruth', 'F', '28', '65', '131']]\nAt this point, it might be better to find some tools that do all this automatically.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#observations",
    "href": "notebooks/M05_NumPy/M05-01-BasicFileIO.html#observations",
    "title": "Basic File I/O",
    "section": "Observations",
    "text": "Observations\nIt is pretty easy to import and process CSV files this way, but you will encounter some issues if you use this as your default pattern for importing data.\nHere are just a few:\n\nNot all sources are well-formed. They may have delimitters that are complex to parse, and the the data themselve may be hard to parse.\nYou have to keep the column names in a separate list or vector and then associate them with the data if and when necessary.\nYou have to convert each column vector into its appropriate data type yourself. Or, you have to create separate 2D arrays for each collection of columns with a common data type. This process also invovles human inspection of the file, as opposed to have a program try to figure it out for you.\n\nFor these reasons, other tools such as NumPy and Pandas were created to make the work of a data scientist a bit easier and more productive.\nPlus, they are faster!",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Basic File I/O</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html",
    "title": "Introducing NumPy",
    "section": "",
    "text": "What is NumPy?\nNumPy stands for Numerical Python.\nIt is designed for high-performance numerical computing in Python.\nNumerical methods are computational and data-driven techniques used to find approximate solutions to continuous mathematical processes that cannot be solved analytically.\nFor example, differential equations, integrals, derivatives, or optimization problems often require a numerical solution.\nBecause numerical methods are so important to the sciences, NumPy is the basis of what is called the scientific “stack” in Python.\nMajor packages in this stack include SciPy, Matplotlib, SciKitLearn, and Pandas.\nUnderstanding what NumPy does and how it works is essential for almost anything data science related in Python.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#a-new-data-structure",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#a-new-data-structure",
    "title": "Introducing NumPy",
    "section": "A New Data Structure",
    "text": "A New Data Structure\nLet’s begin with looking at NumPy’s fundamental design.\nEssentially, NumPy introduces a new data structure to Python — the n-dimensional array.\nAlong with with this data structure, it introduces a collection of operations, functions, and methods that take advantage of this data structure.\nNumPy also provides a new way of applying functions to data made possible by the data structure – vectorized functions.\nVectorized functions replace the use of loops and comprehensions to apply a function to a set of data.\nNumPy also introduces a bunch of new data types.\nLet’s take a look at it.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#importing-the-library",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#importing-the-library",
    "title": "Introducing NumPy",
    "section": "Importing the Library",
    "text": "Importing the Library\nTo import NumPy, we typically alias it as np.\n\nimport numpy as np\n\nNumPy is by widespread convention aliased as np.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#the-ndarray",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#the-ndarray",
    "title": "Introducing NumPy",
    "section": "The ndarray",
    "text": "The ndarray\nThe data structure that NumPy introduces is called the ndarray.\nNote we will sometimes call ndarrays just arrays.\nThe ndarray is a multi-dimensional array object.\nUnlike Python lists, ndarrays enforce a data type among elements.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#about-dimensions",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#about-dimensions",
    "title": "Introducing NumPy",
    "section": "About Dimensions",
    "text": "About Dimensions\nThe term “dimension” is ambiguous.\nSometimes it refers to the dimensions of things in the world, such as space and time.\nSometimes it refers to the dimensions of a data structure, independent of what it represents in the world.\nNote that you can represent multiple world dimensions in a two-dimensional data structure — each column can be dimension in this sense.\nFor example, three-dimensional space can be represented as three columns in a two-dimensional table or as three axes in a data cube.\nThe dimensions of data structures are sometimes called axes.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#creating-arrays",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#creating-arrays",
    "title": "Introducing NumPy",
    "section": "Creating Arrays",
    "text": "Creating Arrays\nThere are many ways to create arrays in NumPy.\nYou can create them by passing plain old Pythin lists:\n\ndata1 = [6, 7.5, 8, 0, 1]\narr1 = np.array(data1)\narr1\n\narray([6. , 7.5, 8. , 0. , 1. ])\n\n\nFrom a list of lists:\n\ndata2 = [[1, 2, 3, 4], [5, 6, 7, 8]]\narr2 = np.array(data2)\narr2\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\narr2.shape\n\n(2, 4)\n\n\n\narr2.ndim\n\n2\n\n\nNumPy also offers convenience functions to initial arrays with a specific value, such as \\(0\\):\n\nnp.zeros(10)\n\narray([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\n\n\n\nnp.zeros((3, 6))\n\narray([[0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.]])\n\n\n.empty() will generate an array of uninitialized values.\n\nnp.empty((2, 3, 2))\n\narray([[[0.44681451, 1.63001338],\n        [0.21062093, 0.01193108],\n        [0.39271709, 0.98894578]],\n\n       [[0.62764938, 0.48666047],\n        [0.60804881, 0.21196292],\n        [0.83234622, 1.11412825]]])\n\n\n.arange() works like range() and will generate a sequence of numbers.\n\nnp.arange(15)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\n\n\nWe can also create new arrays with randomaly generated data.\nnp.random.randn() will create a new array by drawing samples from the “standard normal” distribution.\nHere, we create an array of two dimensions: \\(2\\) rows by \\(3\\) columns:\n\nnp.random.randn(2, 3)\n\narray([[-0.50784086, -0.25623129, -1.47942678],\n       [ 1.35502514,  1.26259653,  0.19764551]])\n\n\nAnd here we use .randint to generate 20 random integers between \\(1\\) and \\(6\\):\n\nnp.random.randint(1, 7, 20)\n\narray([5, 4, 4, 1, 1, 5, 4, 2, 2, 1, 6, 6, 3, 5, 3, 3, 5, 4, 5, 2])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#data-types",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#data-types",
    "title": "Introducing NumPy",
    "section": "Data Types",
    "text": "Data Types\nUnlike any of the previous data structures we have seen in Python, ndarrays must have a single data type associated with the scalar data they contain.\nNumPy introduces 24 new fundamental types to describe different types of scalars.\nThese derive from the C programming language with which NumPy is built.\n\nSee the NumPy docs.\nHere we initialize a couple of arrays as different data types (dtypes).\n\narr1 = np.array([1, 2, 3], dtype=np.float64)\narr1.dtype\n\ndtype('float64')\n\n\n\narr2 = np.array([1, 2, 3], dtype=np.int32)\narr2.dtype\n\ndtype('int32')\n\n\nNote that dtypes are defined by a set of constants attached to the NumPy object, e.g. np.float64.\nWe can also refer to them as strings in some contexts, such in the constructor below:\n\nnp.array([1, 2, 3], dtype='float64')\n\narray([1., 2., 3.])\n\n\nNote that integer arrays default to int64:\n\narr = np.array([1, 2, 3, 4, 5])\narr.dtype\n\ndtype('int64')\n\n\nArrays can be cast, too:\n\narr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])\narr\n\narray([ 3.7, -1.2, -2.6,  0.5, 12.9, 10.1])\n\n\nHere we cast from floats to ints:\n\narr.astype(np.int32)\n\narray([ 3, -1, -2,  0, 12, 10], dtype=int32)\n\n\nAnd from strings to floats:\n\nnumeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)\nnumeric_strings.astype(float)\n\narray([ 1.25, -9.6 , 42.  ])\n\n\nNote that NumPy converts data types to make the array uniform:\n\nnon_uniform = np.array([1.25, -9.6, 42])\nnon_uniform, non_uniform.dtype\n\n(array([ 1.25, -9.6 , 42.  ]), dtype('float64'))\n\n\nRanges default to integers:\n\nint_array = np.arange(10)\n\n\nint_array\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\nWe can use the dtype on one array to cast another:\n\ncalibers = np.array([.22, .270, .357, .380, .44, .50], dtype=np.float64)\nint_array.astype(calibers.dtype)\n\narray([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])\n\n\nAnd here is an empty array of unsigned integers:\n\nempty_uint32 = np.empty(8, dtype='u4')\nempty_uint32\n\narray([         0, 1075314688,          0, 1075707904,          0,\n       1075838976,          0, 1072693248], dtype=uint32)",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#shape",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#shape",
    "title": "Introducing NumPy",
    "section": "Shape",
    "text": "Shape\nThe number and size of the dimensions of an array is called the shape of the array.\nShape is represented by a tuple, e.g. (n, m) for a 2D array.\nThe length of the tuple is the number of dimensions.\nThe values of the tuple are the number of elements in each dimension.\nThe shape property of the array object tells us that the array has \\(2\\) dimensions — the number of elements in the tuple — with \\(2\\) elements in the first dimension and \\(3\\) in the second.\nHere we create an array of \\(3\\) dimensions:\n\ndata3 = np.random.randn(2, 3, 2)\n\n\ndata3\n\narray([[[ 0.44681451,  1.63001338],\n        [ 0.21062093,  0.01193108],\n        [ 0.39271709,  0.98894578]],\n\n       [[ 0.62764938,  0.48666047],\n        [-0.60804881, -0.21196292],\n        [ 0.83234622, -1.11412825]]])\n\n\n\ndata3.shape\n\n(2, 3, 2)",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#d-matrix-vs-vector",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#d-matrix-vs-vector",
    "title": "Introducing NumPy",
    "section": "1-D Matrix vs Vector",
    "text": "1-D Matrix vs Vector\nNote that there is a difference between a \\(1\\)-dimensional array, i.e. a vector, and a single column or row \\(2\\)-dimensional array, i.e. a matrix.\nConsider the following example.\n\none_row_matrix = np.array([[1,2,3,4]])\none_d_vector = np.array([1,2,3,4])\n\n\none_row_matrix, one_row_matrix.shape\n\n(array([[1, 2, 3, 4]]), (1, 4))\n\n\n\none_d_vector, one_d_vector.shape\n\n(array([1, 2, 3, 4]), (4,))\n\n\nWe will encounter this difference when we learn about selecting parts of arrays with indexing.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#reshaping",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#reshaping",
    "title": "Introducing NumPy",
    "section": "Reshaping",
    "text": "Reshaping\nIf we want to make it into a 1-column matrix, we need to reshape it using np.reshape().\nHere we convert an array from \\(3\\) to \\(2\\) dimensions.\n\ndata3\n\narray([[[ 0.44681451,  1.63001338],\n        [ 0.21062093,  0.01193108],\n        [ 0.39271709,  0.98894578]],\n\n       [[ 0.62764938,  0.48666047],\n        [-0.60804881, -0.21196292],\n        [ 0.83234622, -1.11412825]]])\n\n\n\ndata3.shape\n\n(2, 3, 2)\n\n\n\ndata4 = np.reshape(data3, (4,3))\ndata4\n\narray([[ 0.44681451,  1.63001338,  0.21062093],\n       [ 0.01193108,  0.39271709,  0.98894578],\n       [ 0.62764938,  0.48666047, -0.60804881],\n       [-0.21196292,  0.83234622, -1.11412825]])\n\n\nBecause sometimes a function wants to work with a single column (or row) matrix, and not a vector, do this to accomplish the trick:\n\nnp.reshape(one_d_vector, (-1, 1))\n\narray([[1],\n       [2],\n       [3],\n       [4]])\n\n\n\nnp.reshape(one_d_vector, (1, -1))\n\narray([[1, 2, 3, 4]])\n\n\nNote the use of \\(-1\\) in the argument. This means use the length of the vector that is passed to it.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#transposing-arrays-and-swapping-axes",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#transposing-arrays-and-swapping-axes",
    "title": "Introducing NumPy",
    "section": "Transposing Arrays and Swapping Axes",
    "text": "Transposing Arrays and Swapping Axes\nTransposing is a special form of reshaping.\nArrays have the transpose method and also the special T attribute:\n\narr = np.arange(15).reshape((3, 5))\narr\n\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])\n\n\n\narr.T\n\narray([[ 0,  5, 10],\n       [ 1,  6, 11],\n       [ 2,  7, 12],\n       [ 3,  8, 13],\n       [ 4,  9, 14]])\n\n\n\narr.shape, arr.T.shape\n\n((3, 5), (5, 3))\n\n\nTransposing is often used when computing the dot product between two arrays.\nHere’s an example.\n\narr = np.random.randn(6, 3)\narr\n\narray([[ 0.11479688,  0.33156395,  0.59524203],\n       [ 1.15646137, -0.08704862,  0.86381333],\n       [-0.51155823, -1.01358134,  1.27705313],\n       [ 2.25510406,  0.74727944,  1.91715758],\n       [ 0.49557844,  0.07061821, -0.1338661 ],\n       [ 1.77220434, -0.88452654,  1.09233716]])\n\n\n\nnp.dot(arr.T, arr)\n\narray([[10.08407358,  0.608528  ,  6.60690496],\n       [ 0.608528  ,  2.49065994, -0.71523233],\n       [ 6.60690496, -0.71523233,  7.61796502]])\n\n\nFor higher dimensional arrays, transpose will accept a tuple of axis numbers to permute the axes.\nWarning — this can get confusing to conceptualize and visualize!\n\narr = np.arange(16).reshape((2, 2, 4))\narr\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7]],\n\n       [[ 8,  9, 10, 11],\n        [12, 13, 14, 15]]])\n\n\n\narr.transpose((1, 0, 2))\n\narray([[[ 0,  1,  2,  3],\n        [ 8,  9, 10, 11]],\n\n       [[ 4,  5,  6,  7],\n        [12, 13, 14, 15]]])\n\n\nSimple transposing with .T is just a special case of swapping axes. ndarray has the method swapaxes which takes a pair of axis numbers:\n\narr\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7]],\n\n       [[ 8,  9, 10, 11],\n        [12, 13, 14, 15]]])\n\n\n\narr.swapaxes(1, 2)\n\narray([[[ 0,  4],\n        [ 1,  5],\n        [ 2,  6],\n        [ 3,  7]],\n\n       [[ 8, 12],\n        [ 9, 13],\n        [10, 14],\n        [11, 15]]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#example-the-normal-equation",
    "href": "notebooks/M05_NumPy/M05-02-NumpyDesign.html#example-the-normal-equation",
    "title": "Introducing NumPy",
    "section": "Example: The Normal Equation",
    "text": "Example: The Normal Equation\nSometimes, you need to convert vectors into 1-column matrices to make certain linear algebraic functions work.\nConsider two random variables, \\(x\\) and \\(y\\), represented as 1-dimensional arrays (vectors).\n\nx = np.random.randn(100)\ny = np.random.randn(100)\n\n\nx\n\narray([-1.16413841,  1.16865536,  0.4525609 , -0.2722449 , -1.27289815,\n       -0.71810371,  1.883716  ,  0.03320101,  0.71014505,  1.04896451,\n       -0.50324909,  0.79188057,  0.13946271, -0.42061852,  0.51837663,\n       -1.93336155,  0.13682373, -0.49900861,  0.11101955, -0.043336  ,\n        1.08324475, -0.40746863, -0.47573543, -1.27514158, -0.49048658,\n       -0.31183165, -1.11826591, -1.45995636, -0.32890325, -0.45732548,\n       -0.50317275,  0.9888555 , -0.70226293, -0.74463256, -0.8641995 ,\n        2.38039087,  0.19828622,  0.80782525, -0.63194502, -1.09783542,\n       -0.14037333, -0.2037294 , -0.22198999,  0.76775486,  0.02113618,\n       -1.79746008,  0.00301634,  0.35150085, -1.53745733,  0.32611821,\n        0.03922539,  0.75065704, -2.52018155, -0.9952756 , -1.79767193,\n       -0.77861022,  0.40698474,  0.38372067, -0.47768404, -0.57599198,\n        0.73162153, -0.79905799,  0.24235914,  0.99268306, -2.27122081,\n       -1.17120308,  0.03414284, -1.22661171,  2.54755592,  0.71555315,\n       -0.94570815, -1.04452765,  2.0568699 , -2.50169467,  0.49334793,\n       -0.25377387,  1.30137339, -0.65796591,  1.76859461,  1.13154259,\n       -1.47131984, -0.63181831, -1.64419554, -0.51849102, -0.32154684,\n        0.36314129,  1.22479289,  0.65814452,  0.44473066, -0.36370147,\n        0.37352288,  0.46538978,  1.64700262, -0.3771522 , -0.37349846,\n       -0.93680174, -0.20787435,  0.68835535,  0.8968693 , -0.29039299])\n\n\n\nfrom matplotlib.pyplot import plot\nplot(x, linestyle='None', marker='.');\n\n\n\n\n\n\n\n\nWe can fit a regression line using the normal equation, which appears in this week’s homework.\n\\(\\begin{aligned} \\hat\\beta_i=(x^Tx)^{−1}x^Ty \\end{aligned}\\)\nHere is a standard way of expressing it in NumPy:\n\nget_beta1 = lambda x, y: (np.linalg.inv(x.T.dot(x))) * (x.T.dot(y))\n\nHowever, it will fail if we pass it our two variables, x and y.\nThe reason is that it expects x to be a matrix, since it is designed to handle n-dimension predictor variables, usually represented as \\(\\textbf{X}\\).\n\nx.shape, y.shape\n\n((100,), (100,))\n\n\n\nget_beta1(x, y)\n\n\n---------------------------------------------------------------------------\nLinAlgError                               Traceback (most recent call last)\nCell In[48], line 1\n----&gt; 1 get_beta1(x, y)\n\nCell In[46], line 1, in &lt;lambda&gt;(x, y)\n----&gt; 1 get_beta1 = lambda x, y: (np.linalg.inv(x.T.dot(x))) * (x.T.dot(y))\n\nFile &lt;__array_function__ internals&gt;:200, in inv(*args, **kwargs)\n\nFile /apps/software/standard/core/jupyterlab/3.6.3-py3.11/lib/python3.11/site-packages/numpy/linalg/linalg.py:532, in inv(a)\n    471 \"\"\"\n    472 Compute the (multiplicative) inverse of a matrix.\n    473 \n   (...)\n    529 \n    530 \"\"\"\n    531 a, wrap = _makearray(a)\n--&gt; 532 _assert_stacked_2d(a)\n    533 _assert_stacked_square(a)\n    534 t, result_t = _commonType(a)\n\nFile /apps/software/standard/core/jupyterlab/3.6.3-py3.11/lib/python3.11/site-packages/numpy/linalg/linalg.py:183, in _assert_stacked_2d(*arrays)\n    181 for a in arrays:\n    182     if a.ndim &lt; 2:\n--&gt; 183         raise LinAlgError('%d-dimensional array given. Array must be '\n    184                 'at least two-dimensional' % a.ndim)\n\nLinAlgError: 0-dimensional array given. Array must be at least two-dimensional\n\n\n\nThe revised function will work with a vector as x:\n\\(\\hat\\beta_i = \\large\\frac{1}{x^Tx} \\small(x^Ty)\\)\n\nget_beta2 = lambda x, y: (1 / x.T.dot(x)) * (x.T.dot(y))\n\n\nget_beta2(x, y)\n\n0.06399264800571315\n\n\nWe can fix the problem in the general case by converting our vector into a 1-column matrix using np.reshape().\n\nx_as_matrix = np.reshape(x, (-1, 1))\n\n\nget_beta1(x_as_matrix, y)\n\narray([[0.06399265]])\n\n\n\nget_beta1(x_as_matrix, y)[0][0]\n\n0.06399264800571315\n\n\n\nget_beta1(x_as_matrix, y)[0][0] == get_beta2(x, y)\n\nTrue",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Introducing NumPy</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html",
    "title": "NumPy Indexing",
    "section": "",
    "text": "Indexing\nNow that we have learned about the basic structure of NumPy’s multidimensional arrays, let’s look at how to access and extract subsets of data from them.\nHere is a \\(2\\)-D array, or matrix, initialized from a list of lists.\nimport numpy as np\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\narr2d\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\nIf we wanted to get the third row of the matrix, we can do this:\narr2d[2]\n\narray([7, 8, 9])\nThis is called indexing, and it is similar to what we learned about accessing data from lists, tuples, and other sequences in basic Python.\nIndexing into an axis produces lower-order arrays.\nHere we returned a \\(1\\)-D array from a \\(2\\)-D one.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#simplified-notation",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#simplified-notation",
    "title": "NumPy Indexing",
    "section": "Simplified Notation",
    "text": "Simplified Notation\nLet’s say we wanted to extract a single scalar from the matrix.\nWe could do this to get the third cell from the first row:\n\narr2d[0][2]\n\n3\n\n\nNumPy offers a simpler way to index mulitple axes.\nInstead of x[a][b][c] you can write x[a, b, c].\nThink of this as similar to how NumPy represents shape as a tuple.\nEach element of the array has an index tuple, which is really a coordinate.\nSo, in this case, we could do this:\n\narr2d[0, 2]\n\n3\n\n\nOr, thinking of the cell as a point in \\(2\\)-D space:\n\nmy_cell_coord = (0,2)\narr2d[my_cell_coord]\n\n3\n\n\nLet’s look at a cube:\n\narr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\n\narr3d\n\narray([[[ 1,  2,  3],\n        [ 4,  5,  6]],\n\n       [[ 7,  8,  9],\n        [10, 11, 12]]])\n\n\nThis is how we could access the (1,0,2) coordinate:\n\narr3d[1, 0, 2]\n\n9",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#visualizing-array-structure",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#visualizing-array-structure",
    "title": "NumPy Indexing",
    "section": "Visualizing Array Structure",
    "text": "Visualizing Array Structure\nHere is a way to help you visualize 3 and higher dimensional data:\n[ # AXIS 0                       AXIS 0: CONTAINS 2 matrices\n    [ # AXIS 1                   AXIS 1: EACH MEMBER CONTAINS 2 vectors\n        [1, 2, 3],   # AXIS 2    AXIS 2: EACH MEMBER CONTAINS 3 scalars\n        [4, 5, 6]    # AXIS 2\n    ],  \n    [ # AXIS 1\n        [7, 8, 9],   # AXIS 2\n        [10, 11, 12] # AXIS 2\n    ]\n]\nEach axis is a level in the nested hierarchy, like a tree or DAG (directed-acyclic graph).\nEach axis is a container of a lower-order array — the cube contains matrices with contain vectors which contain scalars.\nThere is only one top container.\nOnly the bottom containers have scalar data — the numbers.\nSo, if you omit later indices of an array, the returned object will be a lower-dimensional array consisting of all the data contained by the higher indexed dimension.\nSo, with arr3d, selecting an element from the first axis, we get a matrix from a cube:\n\narr3d[0]\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\nSimilarly, arr3d[1, 0] gives you all of the values whose indices start with (1, 0), forming a 1-dimensional array:\n\narr3d[1, 0]\n\narray([7, 8, 9])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#slicing",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#slicing",
    "title": "NumPy Indexing",
    "section": "Slicing",
    "text": "Slicing\nSlicing refers to selecting subsets of arrays.\nIt is like selecting in SQL — you ask for parts of an array.\nLet’s look at some examples.\nHere is a vector.\n\narr1d = np.random.randint(1, 100, 10)\narr1d\n\narray([76, 46, 76, 64, 37, 11, 43, 75, 42, 71])\n\n\nBy using the colon : notation, we can select a vector with the second through the fifth elements.\n\narr1d[1:6]\n\narray([46, 76, 64, 37, 11])\n\n\nHere is a matrix.\n\narr2d\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\nBy omitting the first number, NumPy defaults to the beginning \\(0\\).\nThis returns the first two elements of the top level, which means two rows:\n\narr2d[:2]\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\nHere we grab the first two rows, and then, for each row, we omit the first element:\n\narr2d[:2, 1:]\n\narray([[2, 3],\n       [5, 6]])\n\n\nAnd here are some more examples of slicing into a matrix:\n\narr2d[1, :2]\n\narray([4, 5])\n\n\n\narr2d[:2, 2]\n\narray([3, 6])\n\n\n\narr2d[:, :1]\n\narray([[1],\n       [4],\n       [7]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#shapes",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#shapes",
    "title": "NumPy Indexing",
    "section": "Shapes",
    "text": "Shapes\nRecall that there is a difference between a \\(1\\)-dimensional array and an \\(2\\)-dimensional array with one row or column.\nThis comes up again in slices.\nConsider the following examples.\nHere we compare a slice that extracts a single row, and a simple index that extracts a the same row.\n\narr2d[0:1], arr2d[0]\n\n(array([[1, 2, 3]]), array([1, 2, 3]))\n\n\n\narr2d[0:1].shape, arr2d[0].shape\n\n((1, 3), (3,))\n\n\nNote the difference in shape.\nA range, even of length \\(1\\), returns a slice, which is always a sequence.\nIn this case, the range selects a 1-element sequence of vectors, while the simple index selects the element itself.\nLet’s look at a higher-order array.\nIn the first axis selector, we use a scalar in one case and a slice in the other.\n\narr3d[1, :], arr3d[1:, :]\n\n(array([[ 7,  8,  9],\n        [10, 11, 12]]),\n array([[[ 7,  8,  9],\n         [10, 11, 12]]]))\n\n\n\narr3d[1, :].shape, arr3d[1:, :].shape\n\n((2, 3), (1, 2, 3))",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#another-visual",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#another-visual",
    "title": "NumPy Indexing",
    "section": "Another Visual",
    "text": "Another Visual\nHere is a nice visualization of how slicing works, taken from McKinney 2017, Chapter 4.\n\n\n\n\nConsider the following \\(2\\)-D array. Each cell is labeled by its address.\n\n \n\n\n\nHere are some slices and their return values.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#altering-values",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#altering-values",
    "title": "NumPy Indexing",
    "section": "Altering Values",
    "text": "Altering Values\nSlices can be used to extract subsets of data, but we may also use them to alter subsets as well.\nHere we set all the values of a slice to \\(0\\).\n\narr2d[:2, 1:] = 0\narr2d\n\narray([[1, 0, 0],\n       [4, 0, 0],\n       [7, 8, 9]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#views",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#views",
    "title": "NumPy Indexing",
    "section": "Views",
    "text": "Views\nIt is crucial to understand when altering the results of a slicing or indexing operation , NumPy returns views to the source object, not copies of it.\nThat is the two variables both point to the same object.\nThis means if we assign a slice to a variable and alter the new variable, we also alter the original!\nLet’s illustrate this with an example. See what happens when we change a view.\nHere we assign a slice to a variable.\n\narr_slice = arr2d[2:3]\narr_slice\n\narray([[7, 8, 9]])\n\n\nThen we alter the data in the variable.\n\narr_slice[0,2] = 12345\n\nBut notice how it changes our original:\n\narr2d\n\narray([[    1,     0,     0],\n       [    4,     0,     0],\n       [    7,     8, 12345]])\n\n\nHere’s another example, to reinforce the point.\n\narr_slice[:] = 64\n\n\narr_slice\n\narray([[64, 64, 64]])\n\n\n\narr2d\n\narray([[ 1,  0,  0],\n       [ 4,  0,  0],\n       [64, 64, 64]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#copies",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#copies",
    "title": "NumPy Indexing",
    "section": "Copies",
    "text": "Copies\nNumPy defaults to views rather than copies because copies are expensive.\nThis is because NumPy is designed with large data use cases in mind.\nIf you want a copy of a slice of an array instead of a view, use .copy().\nHere’s an example:\n\narr_slice_copy = arr2d[2:3].copy()\narr_slice_copy\n\narray([[64, 64, 64]])\n\n\n\narr_slice_copy[:] = 99\narr_slice_copy\n\narray([[99, 99, 99]])\n\n\nNote how the original array is unchanged:\n\narr2d\n\narray([[ 1,  0,  0],\n       [ 4,  0,  0],\n       [64, 64, 64]])\n\n\nOne pattern to follow is to save data before modifying an array.\n\narr3d[0]\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n\nsaved_data = arr3d[0].copy()\narr3d[0] = 42\narr3d\n\narray([[[42, 42, 42],\n        [42, 42, 42]],\n\n       [[ 7,  8,  9],\n        [10, 11, 12]]])\n\n\nPutting the data back.\n\narr3d[0] = saved_data\narr3d\n\narray([[[ 1,  2,  3],\n        [ 4,  5,  6]],\n\n       [[ 7,  8,  9],\n        [10, 11, 12]]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#fancy-indexing",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#fancy-indexing",
    "title": "NumPy Indexing",
    "section": "Fancy Indexing",
    "text": "Fancy Indexing\nIn addition to passing integers and slices to the array indexer, we can pass lists of array index numbers for each axis.\nThis is called fancy indexing.\nThis can be used to both sub-select and re-order data from an array.\nHere’s an example.\nWe create an empty \\(8 \\times 4\\) array and then immediately re-populate it.\n\narr = np.empty((8, 4))\nfor i in range(arr.shape[0]):\n    arr[i] = i\narr\n\narray([[0., 0., 0., 0.],\n       [1., 1., 1., 1.],\n       [2., 2., 2., 2.],\n       [3., 3., 3., 3.],\n       [4., 4., 4., 4.],\n       [5., 5., 5., 5.],\n       [6., 6., 6., 6.],\n       [7., 7., 7., 7.]])\n\n\nThe following fancy index selects rows 4, 3, 0, and 6, in that order:\n\narr[[4, 3, 0, 6]]\n\narray([[4., 4., 4., 4.],\n       [3., 3., 3., 3.],\n       [0., 0., 0., 0.],\n       [6., 6., 6., 6.]])\n\n\nWe can also go backwards, just as we can index elements of a list.\n\narr[[-3, -5, -7]]\n\narray([[5., 5., 5., 5.],\n       [3., 3., 3., 3.],\n       [1., 1., 1., 1.]])\n\n\nWe can also use lists to perform some complex indexing.\n\narr = np.arange(32).reshape((8, 4))\narr\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19],\n       [20, 21, 22, 23],\n       [24, 25, 26, 27],\n       [28, 29, 30, 31]])\n\n\nHere we grab rows, then select columns from each row.\n\narr[[1, 5, 7, 2], [0, 3, 1, 2]]\n\narray([ 4, 23, 29, 10])\n\n\nAnd here we grab some rows in a particular order, then re-order the columns.\n\narr[[1, 5, 7, 2]][:, [0, 3, 1, 2]] \n\narray([[ 4,  7,  5,  6],\n       [20, 23, 21, 22],\n       [28, 31, 29, 30],\n       [ 8, 11,  9, 10]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#something-to-be-aware-of",
    "href": "notebooks/M05_NumPy/M05-03-NumPyIndexing.html#something-to-be-aware-of",
    "title": "NumPy Indexing",
    "section": "Something to be Aware of",
    "text": "Something to be Aware of\nThere is a difference between doing this arr[1:, :2] …\nand doing this arr[1:][:2].\nThe first case operates on both axes simultaneousy, slicing both rows and columns.\nThe second case operates on the axes sequentially, slicing rows then rows again.\nThis may be confusing, since the two notations are the same when we are not using slices.\nHere is an example.\n\nfoo = np.random.randn(3,5)\n\n\nfoo\n\narray([[ 0.88095771,  0.17701757,  0.69125263,  0.67894113,  0.1763698 ],\n       [ 0.17465033, -0.25317231,  0.45904164,  0.21024919,  1.11688081],\n       [-0.52672375, -0.09234619, -0.46120961, -0.1940446 , -0.28382698]])\n\n\nNow, this slices rows and columns:\n\nfoo[1:, :2]\n\narray([[ 0.17465033, -0.25317231],\n       [-0.52672375, -0.09234619]])\n\n\nAnd this slices rows, then rows again on the result:\n\nfoo[1:][:2]\n\narray([[ 0.17465033, -0.25317231,  0.45904164,  0.21024919,  1.11688081],\n       [-0.52672375, -0.09234619, -0.46120961, -0.1940446 , -0.28382698]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>NumPy Indexing</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-04-NumPyOperating.html",
    "href": "notebooks/M05_NumPy/M05-04-NumPyOperating.html",
    "title": "NumPy Operations",
    "section": "",
    "text": "Element-wise Arithmetic\nNumPy arrays can be transformed with with arithmetic operations.\nThese are all element-wise operations.\nLet’s start with a couple of \\(2\\)-D arrays.\nimport numpy as np\narr1 = np.array([[1., 2., 3.], [4., 5., 6.]])\narr2 = np.array([[0., 4., 1.], [7., 2., 12.]])\narr1, arr2\n\n(array([[1., 2., 3.],\n        [4., 5., 6.]]),\n array([[ 0.,  4.,  1.],\n        [ 7.,  2., 12.]]))\nIf we multiply these two matrices, NumPy performs multiplication on each pair of cells with the same index or coordinate.\narr1 * arr2\n\narray([[ 0.,  8.,  3.],\n       [28., 10., 72.]])\nYou can think of it this way:\nOf course, this works for the other operations, too.\narr1 - arr2\n\narray([[ 1., -2.,  2.],\n       [-3.,  3., -6.]])\narr2 / arr1\n\narray([[0.        , 2.        , 0.33333333],\n       [1.75      , 0.4       , 2.        ]])\n1 / arr1\n\narray([[1.        , 0.5       , 0.33333333],\n       [0.25      , 0.2       , 0.16666667]])\narr1 ** arr2\n\narray([[1.00000000e+00, 1.60000000e+01, 3.00000000e+00],\n       [1.63840000e+04, 2.50000000e+01, 2.17678234e+09]])\narr2 ** 0.5\n\narray([[0.        , 2.        , 1.        ],\n       [2.64575131, 1.41421356, 3.46410162]])\narr2 &gt; arr1\n\narray([[False,  True, False],\n       [ True, False,  True]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>NumPy Operations</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#element-wise-arithmetic",
    "href": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#element-wise-arithmetic",
    "title": "NumPy Operations",
    "section": "",
    "text": "coordinate   arr1   arr2  arr1 * arr2 \n0, 0         1.     0.    0.\n0, 1         2.     4.    8.\n0, 2         3.     1.    3.\n...",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>NumPy Operations</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#broadcasting",
    "href": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#broadcasting",
    "title": "NumPy Operations",
    "section": "Broadcasting",
    "text": "Broadcasting\nWhat happens when you try to perform an element-wise operation on two arrays of different shape?\nNumPy will convert a low-dimensional array into a high-dimensional array to allow the operation to take place.\nThis is called broadcasting.\nLet’s look at an example.\n\nfoo = np.ones((6,4))\n\n\nfoo\n\narray([[1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.]])\n\n\nIf we multiply it by \\(5\\), the scalar is converted into an array of the same shape as foo with the value \\(5\\) “broadcast” to populate the entire array.\n\nfoo * 5\n\narray([[5., 5., 5., 5.],\n       [5., 5., 5., 5.],\n       [5., 5., 5., 5.],\n       [5., 5., 5., 5.],\n       [5., 5., 5., 5.],\n       [5., 5., 5., 5.]])\n\n\nWe actually saw this already when we looked at slices.\nIf we want to multiply an array by a vector, the vector is broadcast to become a 2D array.\n\nfoo * np.array([5, 10, 6, 8])\n\narray([[ 5., 10.,  6.,  8.],\n       [ 5., 10.,  6.,  8.],\n       [ 5., 10.,  6.,  8.],\n       [ 5., 10.,  6.,  8.],\n       [ 5., 10.,  6.,  8.],\n       [ 5., 10.,  6.,  8.]])\n\n\nNote that NumPy can’t always make the adjustment:\n\nfoo * np.array([5, 10])\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 foo * np.array([5, 10])\n\nValueError: operands could not be broadcast together with shapes (6,4) (2,)",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>NumPy Operations</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#boolean-indexing",
    "href": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#boolean-indexing",
    "title": "NumPy Operations",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nAnother crucial topic in NumPy is boolean indexing.\nIn brief, you can pass a boolean array to the array indexer (i.e. the [] suffix) and it will return only those cells that are True.\nThis is a technique we will use frequently in Pandas and R.\nLet’s assume that we have two related arrays:\n\nnames which holds the names associated with the data in each row, or observations, of a table.\ndata which holds the data associated with each feature of a table.\n\nThere are \\(7\\) observations and \\(4\\) features.\n\nnames = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])\nnames\n\narray(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='&lt;U4')\n\n\n\ndata = np.random.randn(7, 4)\ndata\n\narray([[-1.0441337 , -0.8075191 , -1.89069483, -0.9007478 ],\n       [ 1.57167643, -0.50688096,  0.78120542,  0.22558685],\n       [-1.45769989, -0.49824512, -1.2056539 , -0.43596557],\n       [-0.33496411, -0.25575133, -0.61952407,  0.88984652],\n       [-0.59001244, -2.23411426, -0.31123889, -0.86358338],\n       [ 1.23662366, -0.90041871,  0.63348956, -0.58677799],\n       [-3.09362317,  0.92042332,  0.53013723,  0.24224835]])\n\n\nA comparison operation for an array returns an array of booleans.\nLet’s see which names are 'Bob':\n\nnames == 'Bob'\n\narray([ True, False, False,  True, False, False, False])\n\n\nNow, this boolean expression can be passed to an array indexer to the data:\n\ndata[names == 'Bob']\n\narray([[-1.0441337 , -0.8075191 , -1.89069483, -0.9007478 ],\n       [-0.33496411, -0.25575133, -0.61952407,  0.88984652]])\n\n\nAlong the second axis, we can use a slice or integer to select data.\n\ndata[names == 'Bob', 2:]\n\narray([[-1.89069483, -0.9007478 ],\n       [-0.61952407,  0.88984652]])\n\n\n\ndata[names == 'Bob', 3]\n\narray([-0.9007478 ,  0.88984652])\n\n\nIf you know SQL, this is like the query:\nSELECT col3, col4 FROM data WHERE name = 'Bob'",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>NumPy Operations</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#negation",
    "href": "notebooks/M05_NumPy/M05-04-NumPyOperating.html#negation",
    "title": "NumPy Operations",
    "section": "Negation",
    "text": "Negation\nHere are some examples of negated boolean operations being applied.\n\nbix = names != 'Bob'\nbix\n\narray([False,  True,  True, False,  True,  True,  True])\n\n\n\ndata[bix]\n\narray([[ 1.57167643, -0.50688096,  0.78120542,  0.22558685],\n       [-1.45769989, -0.49824512, -1.2056539 , -0.43596557],\n       [-0.59001244, -2.23411426, -0.31123889, -0.86358338],\n       [ 1.23662366, -0.90041871,  0.63348956, -0.58677799],\n       [-3.09362317,  0.92042332,  0.53013723,  0.24224835]])\n\n\n\ndata[~bix] # Back to Bob\n\narray([[-1.0441337 , -0.8075191 , -1.89069483, -0.9007478 ],\n       [-0.33496411, -0.25575133, -0.61952407,  0.88984652]])\n\n\n\ndata[~(names == 'Bob')]\n\narray([[ 1.57167643, -0.50688096,  0.78120542,  0.22558685],\n       [-1.45769989, -0.49824512, -1.2056539 , -0.43596557],\n       [-0.59001244, -2.23411426, -0.31123889, -0.86358338],\n       [ 1.23662366, -0.90041871,  0.63348956, -0.58677799],\n       [-3.09362317,  0.92042332,  0.53013723,  0.24224835]])\n\n\nNote that we don’t use not but instead the tilde ~ sign to negate (flip) a value.\nNor do we use and and or; instead we use & and |.\nAlso, expressions join by these operators must be in parentheses.\n\nmask = (names == 'Bob') | (names == 'Will')\nmask\ndata[mask]\n\narray([[-1.0441337 , -0.8075191 , -1.89069483, -0.9007478 ],\n       [-1.45769989, -0.49824512, -1.2056539 , -0.43596557],\n       [-0.33496411, -0.25575133, -0.61952407,  0.88984652],\n       [-0.59001244, -2.23411426, -0.31123889, -0.86358338]])\n\n\nWe can also do things like this:\n\ndata[data &lt; 0] = 0\ndata\n\narray([[0.        , 0.        , 0.        , 0.        ],\n       [1.57167643, 0.        , 0.78120542, 0.22558685],\n       [0.        , 0.        , 0.        , 0.        ],\n       [0.        , 0.        , 0.        , 0.88984652],\n       [0.        , 0.        , 0.        , 0.        ],\n       [1.23662366, 0.        , 0.63348956, 0.        ],\n       [0.        , 0.92042332, 0.53013723, 0.24224835]])\n\n\nAnd we can alter data with boolean indexing, just as we did with slices.\n\ndata[names != 'Joe'] = 7\ndata\n\narray([[7.        , 7.        , 7.        , 7.        ],\n       [1.57167643, 0.        , 0.78120542, 0.22558685],\n       [7.        , 7.        , 7.        , 7.        ],\n       [7.        , 7.        , 7.        , 7.        ],\n       [7.        , 7.        , 7.        , 7.        ],\n       [1.23662366, 0.        , 0.63348956, 0.        ],\n       [0.        , 0.92042332, 0.53013723, 0.24224835]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>NumPy Operations</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html",
    "title": "NumPy Functions",
    "section": "",
    "text": "Universal Functions\nNumPy introduces the concept of a universal function.\nA universal function, or ufunc, is a function that performs element-wise operations on data in ndarrays.\nUniversal functions use the same pattern we saw with arithmetic operations, applying a function to elements.\nYou may think of these as fast vectorized wrappers for simple functions that take one or more scalar values and produce one or more scalar results.\nLet’s look at some examples.\nimport numpy as np\nLet’s first define an array that we want to operate on.\narr = np.arange(10)\narr\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nTo perform an element-wise square root operation on this, we might do the following:\nfrom math import sqrt\nnp.array([sqrt(x) for x in arr])\n\narray([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,\n       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])\nHowever, NumPy offers a more concise approach:\nnp.sqrt(arr)\n\narray([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,\n       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])\nIt’s also faster:\n%timeit np.array([sqrt(x) for x in arr])\n%timeit np.sqrt(arr)\n\n2.26 µs ± 18.4 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n710 ns ± 3.97 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\nHere’s an element-wise exponent operation:\nnp.exp(arr)\n\narray([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,\n       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,\n       2.98095799e+03, 8.10308393e+03])\nSome vectorized functions can take two arrays.\nx = np.random.randn(8)\ny = np.random.randn(8)\nx, y\n\n(array([-0.02865278, -1.47829863,  0.820916  ,  0.86317255,  0.85184202,\n        -0.52943286,  0.79710862,  0.43352724]),\n array([ 0.79527927,  0.98962373,  0.30685449, -1.88671886,  0.24585142,\n        -0.79768499, -1.30316536,  0.84871309]))\nThis takes the maximum between the corrresponding elements in x and y:\nnp.maximum(x, y)\n\narray([ 0.79527927,  0.98962373,  0.820916  ,  0.86317255,  0.85184202,\n       -0.52943286,  0.79710862,  0.84871309])\nLet’s create another array of random floats and apply the modulus function.\nThis returns two values.\narr_rand = np.random.randn(7) * 5\narr_rand\n\narray([ 6.18511759, -2.17250696,  2.74951073,  3.81623877, -1.56924266,\n        8.44800585,  3.22968695])\nremainder, whole_part = np.modf(arr_rand)\nremainder\n\narray([ 0.18511759, -0.17250696,  0.74951073,  0.81623877, -0.56924266,\n        0.44800585,  0.22968695])\nwhole_part\n\narray([ 6., -2.,  2.,  3., -1.,  8.,  3.])\nWhat happens when we try to get the square root of a negative number?\nnp.sqrt(arr_rand)\n\n/tmp/ipykernel_946251/3237590434.py:1: RuntimeWarning: invalid value encountered in sqrt\n  np.sqrt(arr_rand)\n\n\narray([2.48698966,        nan, 1.65816487, 1.95351959,        nan,\n       2.90654535, 1.79713298])\nnan is a special value in NumPy.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#vectorization",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#vectorization",
    "title": "NumPy Functions",
    "section": "Vectorization",
    "text": "Vectorization\nBeyond universal functions, NumPy expresses many kinds of data processing tasks as concise array-oriented expressions without writing loops.\nThis practice of replacing explicit loops with array expressions is referred to by some people as vectorization.\nVectorized array operations are often significantly faster than their pure Python equivalents.\nThey are also visually concise and elegant, although loops have the virtue of visualizing what’s under the hood in an algorithm.",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#conditional-logic",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#conditional-logic",
    "title": "NumPy Functions",
    "section": "Conditional Logic",
    "text": "Conditional Logic\n\nnp.where()\nThe np.where function is a vectorized version of the ternary expression x if condition else y.\nSuppose we had a boolean array and two arrays of values and we wanted to pick between the two arrays based on the boolean.\nWe might do something like this:\n\nxarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])\nyarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])\ncond = np.array([True, False, True, True, False])\n\n\nresult = [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]\n\n\nresult\n\n[1.1, 2.2, 1.3, 1.4, 2.5]\n\n\nA quick note on zip().\nThis function takes two or more iterables (e.g. lists) of the same length and returns their grouped elements by index.\nIn effect, it binds a group of lists as columns in a table and returns their rows.\nFor example,\n\nA = [1, 2, 3, 4]\nB = ['a', 'b', 'c', 'd']\nC = [(a, b) for a, b in zip(A, B)]\nC\n\n[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]\n\n\nHere is the vectorized version:\n\nresult = np.where(cond, xarr, yarr)\n\n\nresult\n\narray([1.1, 2.2, 1.3, 1.4, 2.5])\n\n\nAnd it’s faster, too:\n\n%timeit [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]\n%timeit np.where(cond, xarr, yarr)\n\n1.42 µs ± 6.33 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\n1.03 µs ± 8.67 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\n\n\nHere is another example, where we use a boolean expression that returns an array to conditionally operate on a \\(2\\)-D array.\n\narr = np.random.randn(4, 4)\narr\n\narray([[-0.37372765, -0.07008402, -0.9804428 , -0.4962722 ],\n       [-0.48452222, -1.63528018,  2.02413952,  0.95929382],\n       [ 0.85871743, -0.32967862, -0.22090242, -0.95784047],\n       [ 0.31219406,  0.98487624,  1.00231528, -0.12983138]])\n\n\n\narr &gt; 0\n\narray([[False, False, False, False],\n       [False, False,  True,  True],\n       [ True, False, False, False],\n       [ True,  True,  True, False]])\n\n\n\nnp.where(arr &gt; 0, 2, -2)\n\narray([[-2, -2, -2, -2],\n       [-2, -2,  2,  2],\n       [ 2, -2, -2, -2],\n       [ 2,  2,  2, -2]])\n\n\n\nnp.where(arr &gt; 0, 2, arr)\n\narray([[-0.37372765, -0.07008402, -0.9804428 , -0.4962722 ],\n       [-0.48452222, -1.63528018,  2.        ,  2.        ],\n       [ 2.        , -0.32967862, -0.22090242, -0.95784047],\n       [ 2.        ,  2.        ,  2.        , -0.12983138]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#mathematical-and-statistical-methods",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#mathematical-and-statistical-methods",
    "title": "NumPy Functions",
    "section": "Mathematical and Statistical Methods",
    "text": "Mathematical and Statistical Methods\nStatistical computations are aggregate functions applied to vectors within an array.\nIn a \\(2\\)-D array, they can be applied to rows or columns, i.e. axis \\(0\\) or axis \\(1\\).\nTo demonstrate, let’s create an array of random values.\nWe can think of it is a table of observations and random variables.\n\narr = np.random.randn(5, 4)\n\n\narr\n\narray([[ 0.85124258,  1.26274113, -1.41403354, -1.92964977],\n       [-0.9302931 ,  0.21807627, -0.19301232, -1.69534407],\n       [ 1.06757947, -0.34279466, -0.33276255,  1.68059036],\n       [ 0.38249005,  0.17731579, -0.46004143, -0.00862738],\n       [-1.7617584 , -0.17263553,  0.56952929, -0.50669218]])\n\n\n\n.mean()\nWe can get the mean of all the numbers in the array by using a method or a function.\n\narr.mean()\n\n-0.17690399891686628\n\n\n\nnp.mean(arr)\n\n-0.17690399891686628\n\n\nHere we get the mean for each row.\n\narr.mean(axis=1)\n\narray([-0.3074249 , -0.6501433 ,  0.51815315,  0.02278426, -0.4678892 ])\n\n\nAnd here for each column.\n\narr.mean(axis=0)\n\narray([-0.07814788,  0.2285406 , -0.36606411, -0.49194461])\n\n\n\n\n.sum()\nWe can do the same with summing.\n\nnp.sum(arr), arr.sum()\n\n(-3.5380799783373256, -3.5380799783373256)\n\n\n\narr.sum(axis=0)\n\narray([-0.39073939,  1.142703  , -1.83032055, -2.45972304])\n\n\n\narr.mean(axis=1)\n\narray([-0.3074249 , -0.6501433 ,  0.51815315,  0.02278426, -0.4678892 ])\n\n\n\n\n.cumsum()\nAnd here is cumulative summing.\n\narr = np.array([0, 1, 2, 3, 4, 5, 6, 7])\narr.cumsum()\n\narray([ 0,  1,  3,  6, 10, 15, 21, 28])\n\n\n\narr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])\narr\n\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n\n\narr.cumsum(axis=0)\n\narray([[ 0,  1,  2],\n       [ 3,  5,  7],\n       [ 9, 12, 15]])\n\n\n\narr.cumprod(axis=1)\n\narray([[  0,   0,   0],\n       [  3,  12,  60],\n       [  6,  42, 336]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#boolean-arrays",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#boolean-arrays",
    "title": "NumPy Functions",
    "section": "Boolean Arrays",
    "text": "Boolean Arrays\n\n.sum()\nSince booleans are \\(0\\)s and \\(1\\), we can sum them to get a total truth count.\n\narr = np.random.randn(100)\n(arr &gt; 0).sum() # Number of positive values\n\n43\n\n\n\nbools = np.array([False, False, True, False])\nbools.sum()\n\n1\n\n\n\n\n.any() and .all()\n\nbools.any(), bools.all()\n\n(True, False)",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#sorting",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#sorting",
    "title": "NumPy Functions",
    "section": "Sorting",
    "text": "Sorting\nNumPy provides several sorting options. Here we look at the most basic forms, the sort function np.sort() and the method .sort().\nHere’s the method option.\n\narr = np.random.randn(6)\narr\n\narray([-0.13048996, -0.72462279, -0.06963874,  0.3639324 ,  2.22785044,\n       -0.47912818])\n\n\n\narr.sort()\narr\n\narray([-0.72462279, -0.47912818, -0.13048996, -0.06963874,  0.3639324 ,\n        2.22785044])\n\n\nNote that this performs an in-place operation — it changes the state of the object.\nThe method also does not return anything.\nIf you just want to get a sorted version of the vector without changing the state of the object, use the function.\nThis does return a value.\n\nnp.sort(arr)\n\narray([-0.72462279, -0.47912818, -0.13048996, -0.06963874,  0.3639324 ,\n        2.22785044])\n\n\nTo reverse sort, you have to slice the result and walk backwords:\n\narr[::-1]\n\narray([ 2.22785044,  0.3639324 , -0.06963874, -0.13048996, -0.47912818,\n       -0.72462279])\n\n\nHere we sort a \\(2\\)-D array by row.\nThat is, each row is sorted.\n\narr = np.random.randn(5, 3)\narr\n\narray([[ 0.75982535, -1.44121737,  0.55483639],\n       [-2.06462226,  1.14922865, -0.18207867],\n       [-2.47882161,  0.16483045,  1.21204657],\n       [ 0.12048109,  0.885755  ,  1.77209294],\n       [-1.39199022,  0.87544244,  1.42260675]])\n\n\n\narr.sort(axis=1)\narr\n\narray([[-1.44121737,  0.55483639,  0.75982535],\n       [-2.06462226, -0.18207867,  1.14922865],\n       [-2.47882161,  0.16483045,  1.21204657],\n       [ 0.12048109,  0.885755  ,  1.77209294],\n       [-1.39199022,  0.87544244,  1.42260675]])\n\n\nNumPy defaults to sorting on the last axis, which you can specify by using \\(-1\\).\n\narr.sort(-1)\narr\n\narray([[-1.44121737,  0.55483639,  0.75982535],\n       [-2.06462226, -0.18207867,  1.14922865],\n       [-2.47882161,  0.16483045,  1.21204657],\n       [ 0.12048109,  0.885755  ,  1.77209294],\n       [-1.39199022,  0.87544244,  1.42260675]])\n\n\nHere we use sort to compute the \\(5\\%\\) quantile of a vector of floats.\n\nlarge_arr = np.random.randn(1000)\nlarge_arr.sort()\nlarge_arr[int(0.05 * len(large_arr))]\n\n-1.6779175381412759\n\n\n\n0.05 * len(large_arr)\n\n50.0",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#set-logic",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#set-logic",
    "title": "NumPy Functions",
    "section": "Set Logic",
    "text": "Set Logic\nNumPy provides some methods to perform set membership operations.\n\nnp.unique()\nThis returns a sorted array of distinct values in an array.\n\nnames = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])\nnp.unique(names)\n\narray(['Bob', 'Joe', 'Will'], dtype='&lt;U4')\n\n\n\nints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])\nnp.unique(ints)\n\narray([1, 2, 3, 4])\n\n\n\n\nnp.in1d()\nThis method tests whether each element of a \\(1\\)-D array is also present in a second array.\n\nvalues = np.array([6, 0, 0, 3, 2, 5, 6])\nnp.in1d(values, [2, 3, 6])\n\narray([ True, False, False,  True,  True, False,  True])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#file-input-and-output",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#file-input-and-output",
    "title": "NumPy Functions",
    "section": "File Input and Output",
    "text": "File Input and Output\nNumPy provides methods and functions to read and write data from disk.\n\nnp.save()\nSave an array to a binary file in NumPy .npy format.\nAutomatically adds the .npy file extension.\n\narr = np.arange(10)\nnp.save('some_array', arr)\n\n\n\nnp.load()\nThis reads in a file in NumPy format.\n\nnp.load('some_array.npy')\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n\n\nnp.savetxt() and np.loadtxt()\nThese read from and write to plain text files.\n\nnp.savetxt('some_array.txt', arr)\n\n\nnp.loadtxt('some_array.txt')\n\narray([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])\n\n\n\n\nnp.savez()\nThis saves several arrays into a single file in uncompressed .npz format.\n\nnp.savez('array_archive.npz', a=arr, b=arr)\n\n\narch = np.load('array_archive.npz')\narch['b']\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\nThis uses a compressed format.\n\nnp.savez_compressed('arrays_compressed.npz', a=arr, b=arr)\n\nClean up …\n\n!rm some_array.npy\n!rm some_array.txt\n!rm array_archive.npz\n!rm arrays_compressed.npz",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#linear-algebra",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#linear-algebra",
    "title": "NumPy Functions",
    "section": "Linear Algebra",
    "text": "Linear Algebra\nNumPy also offers a number of linear algebraic methods.\nBecause linear algebra is so fundamental to numeric analysis, many functions are in the main NumPy namespace. These include: dot, vdot, inner, outer, matmul, tensordot, einsum, einsum_path and kron.\nFunctions present in numpy.linalg are the following:\n\nMatrix and vector products: multi_dot, matrix_power\nDecompositions: cholesky, qr, svd\nMatrix eigenvalues: eig, eigh, eigvals, eigvalsh\nNorms and other numbers: norm, cond, det, matrix_rank, slogdet\nSolving equations and inverting matrices: solve, tensorsolve, lstsq, inv, pinv, tensorinv\nExceptions: LinAlgError\n\nWe’ll look at just a couple of these.\n\n.dot() and np.dot()\nThis gives you the dot product of two arrays.\nIt returns a result based on the shape of the input data.\nSo, given two arrays \\(a\\) and \\(b\\):\n\n\n\nIf\n\n\nThen\n\n\n\n\n\\(a\\) and \\(b\\) are \\(1\\)-D (vector)\n\n\ninner product\n\n\n\n\n\\(a\\) and \\(b\\) are \\(2\\)-D (matrix)\n\n\nmarix multiplaction\n\n\n\n\n\\(a\\) or \\(b\\) are \\(0\\)-D (scalar)\n\n\nequivalent to multiply()\n\n\n\n\n\\(a\\) is \\(N\\)-D and \\(b\\) is \\(1\\)-D\n\n\nsum product over the last axis of \\(a\\) and \\(b\\)\n\n\n\n\n\\(a\\) is \\(N\\)-D and \\(b\\) is \\(M\\)-D (where \\(M &gt;= 2\\))\n\n\nsum product over the last axis of \\(a\\) and the second-to-last axis of \\(b\\):  dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])\n\n\n\n\nLet’s look at an example.\n\nx = np.array([[1., 2., 3.], [4., 5., 6.]])\ny = np.array([[6., 23.], [-1, 7], [8, 9]])\n\n\nx\n\narray([[1., 2., 3.],\n       [4., 5., 6.]])\n\n\n\ny\n\narray([[ 6., 23.],\n       [-1.,  7.],\n       [ 8.,  9.]])\n\n\n\nx.dot(y)\n\narray([[ 28.,  64.],\n       [ 67., 181.]])\n\n\n\nnp.dot(x, y)\n\narray([[ 28.,  64.],\n       [ 67., 181.]])\n\n\nHere we get the dot product of a matrix and a vector.\nThis gets the sum product over the rows of x.\n\nnp.dot(x, np.ones(3))\n\narray([ 6., 15.])\n\n\nWe can also use the the @ operator in NumPy for matrix multiplication.\n\nx @ np.ones(3)\n\narray([ 6., 15.])\n\n\n\n\nnp.linalg.inv()\nComputes the inverse of a matrix.\n\nfrom numpy.linalg import inv, qr\nX = np.random.randn(5, 5)\nX\n\narray([[ 0.00657667,  0.94280294, -0.38778753, -1.27782778,  1.11744125],\n       [ 0.11611194,  0.38160734, -1.14998116,  1.1665558 , -0.41054575],\n       [-1.36436756, -0.56012045,  1.13364082, -0.52002208,  1.65062773],\n       [ 1.3858369 , -0.46831126,  0.07717   ,  0.31919749, -2.12694842],\n       [ 1.54317047,  0.50438473, -0.52536121, -0.1092352 ,  1.24429125]])\n\n\n\ninv(X)\n\narray([[-0.39878244, -0.54773915, -0.46683041, -0.19885435,  0.45676946],\n       [-5.62085111, -7.96286851, -9.36991848, -8.63364179,  0.0922498 ],\n       [-5.14910918, -7.016499  , -7.4090965 , -6.95651434,  0.24652277],\n       [-3.08196362, -3.16558159, -3.87235952, -3.84772023,  0.28306779],\n       [ 0.32842762,  0.66673685,  0.90894543,  0.47139604,  0.32872684]])\n\n\n\n\nnumpy.linalg.qr()\nHere we compute the QR factorization of a matrix.\nThat is, we decompose a matrix into an orthogonal matrix \\(Q\\) and an upper triangular matrix \\(R\\).\n\nQ, R = qr(X)\n\n\nQ\n\narray([[-0.00264618, -0.72711785, -0.38911205, -0.50671846,  0.25123863],\n       [-0.04671863, -0.28092006,  0.81095117,  0.03350105,  0.51003644],\n       [ 0.54896491,  0.27144918, -0.31983195,  0.19796682,  0.69531974],\n       [-0.55760328,  0.52508801, -0.05515592, -0.52941709,  0.36060578],\n       [-0.62090779, -0.20731974, -0.29260103,  0.65010827,  0.25146753]])\n\n\n\nR\n\narray([[-2.48534567, -0.37985398,  0.96025135, -0.44675298,  1.33576317],\n       [ 0.        , -1.29524778,  1.06218467,  0.65051628, -1.62392066],\n       [ 0.        ,  0.        , -0.99479547,  1.62391435, -1.54243298],\n       [ 0.        ,  0.        ,  0.        ,  0.34362934,  1.68175458],\n       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.76497413]])",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#random-number-generation",
    "href": "notebooks/M05_NumPy/M05-05-NumPyFunctions.html#random-number-generation",
    "title": "NumPy Functions",
    "section": "Random Number Generation",
    "text": "Random Number Generation\nWe have already used NumPy to generate random numbers.\nHere’s another function in this domain.\n\nnp.random.normal()\n\nsamples = np.random.normal(size=(4, 4))\nsamples\n\narray([[-0.19696082, -0.26304121,  0.6363801 ,  0.20438421],\n       [-1.55414504,  0.9324663 ,  1.51351311,  0.42318343],\n       [ 0.60250211, -1.26817884,  0.05698393, -0.36026335],\n       [-0.67891835,  0.96903582, -0.7618861 ,  0.60346314]])\n\n\nLet’s compare its speed to a more basic approach.\n\nfrom random import normalvariate\n\nN = 1000000\n%timeit samples = [normalvariate(0, 1) for _ in range(N)]\n%timeit np.random.normal(size=N)\n\n486 ms ± 1.46 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n30.4 ms ± 21.2 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>NumPy Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html",
    "title": "Introducting Pandas",
    "section": "",
    "text": "What is Pandas?\nPandas is a Python library designed to work with dataframes.\nEssentially, it adds a ton of usability features to NumPy.\nIt has become a standard library in data science.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#why-pandas",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#why-pandas",
    "title": "Introducting Pandas",
    "section": "Why Pandas?",
    "text": "Why Pandas?\nSince we already have NumPy as a powerful analytical tool to work with data, why do we need Pandas?\nRecall one of the problems we faced when using NumPy — if we want to work with labeled data, say a matrix with named columns and rows, we have to create separate arrays and manage the relationship between the three arrays in our heads.\nIt would be nice if we could have an object which contained all three together.\nThis is one the things Panda offers.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#structured-arrays",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#structured-arrays",
    "title": "Introducting Pandas",
    "section": "Structured Arrays",
    "text": "Structured Arrays\nIn fairness, NumPy does offer a partial solution to this problem — structured arrays — which we have not covered.\nStructured arrays allow you to create arrays with labeled columns, and these columns may have different data types.\nFor example, here is a simple structured array:\n\nimport numpy as np\n\nmy_data = [('Rex', 9, 81.), ('Fido', 3, 27.), ('Pluto', 4, 55.)]\nmy_struct = np.array(\n    my_data,\n    dtype=[('name', 'U10'), ('age', 'i4'), ('weight', 'f4')]\n)\nmy_struct\n\narray([('Rex', 9, 81.), ('Fido', 3, 27.), ('Pluto', 4, 55.)],\n      dtype=[('name', '&lt;U10'), ('age', '&lt;i4'), ('weight', '&lt;f4')])\n\n\n\nmy_struct['name'] # Gets a column\n\narray(['Rex', 'Fido', 'Pluto'], dtype='&lt;U10')\n\n\n\nmy_struct[my_struct['name'] == 'Pluto'] # Gets a row\n\narray([('Pluto', 4, 55.)],\n      dtype=[('name', '&lt;U10'), ('age', '&lt;i4'), ('weight', '&lt;f4')])\n\n\nHowever, NumPy’s documentation has this warning:\n\nUsers looking to manipulate tabular data, such as stored in csv files, may find other pydata projects more suitable, such as xarray, pandas, or DataArray. These provide a high-level interface for tabular data analysis and are better optimized for that use. For instance, the C-struct-like memory layout of structured arrays in numpy can lead to poor cache behavior in comparison.\nNumPy documentation",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#pandas-data-structures",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#pandas-data-structures",
    "title": "Introducting Pandas",
    "section": "Pandas Data Structures",
    "text": "Pandas Data Structures\nIn a way, Pandas takes the concept of the structured array and runs with it (although the two were developed independently).\nIn doing so, it makes a strong design decision to only work with \\(1\\) and \\(2\\) dimensional arrays:\n\nA \\(1\\)-dimensional labeled array capable of holding any data type is called a Series.\nA \\(2\\)-dimensional labeled array with columns of potentially different types is called a DataFrame.\n\n\nAs a side note, Pandas used to have a \\(3\\)-dimensional structure called a panel, but it has been removed from the library for lack of use.\nIronically, the name “pandas” was partly derived the word “panel”, as in “\\(pan(el)-da(ta)-s\\)”.\nTo handle higher dimensional data, the Pandas team suggests using XArray, which also builds on NumPy arrays.\nThis is important — this decision reflects the fact that data science, to a large extent, is practiced in two-dimensional dataspace.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#data-structure-design",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#data-structure-design",
    "title": "Introducting Pandas",
    "section": "Data Structure Design",
    "text": "Data Structure Design\nLet’s look at how DataFrame and Series objects are designed and built.\nIt is essential to develop a mental model of what you are working with so operations and functions associated with them make sense.\nRemember — data structure design is king.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#the-series",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#the-series",
    "title": "Introducting Pandas",
    "section": "The Series",
    "text": "The Series\nA Series is at heart a one-dimensional array with labels along its axis.\nLabels are essentially names that, ideally, uniquely identify each row (observation).\nIts data must be of a single type, like NumPy arrays (which they are internally).",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#the-index",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#the-index",
    "title": "Introducting Pandas",
    "section": "The Index",
    "text": "The Index\nThe axis labels of a Series are referred to as the index of the Series.\nThink of the index as a separate data structure that is attached to the array.\nThe Series array holds the data.\nThe Series index holds the names of the observations or things that the data are about.\nSome consider the index to be metadata — data about data.\nNote that if an index does not have labels provided, it falls back on the numeric sequence, like a list.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#the-data-frame",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#the-data-frame",
    "title": "Introducting Pandas",
    "section": "The Data Frame",
    "text": "The Data Frame\nYou can think of a DataFrame as a bundle of Series objects that share an index.\nColumn labels (also called the column index) can be thought of as Series names.\n\nHere’s a more detailed illustration from PYnative 2023:\n\nAnd finally here is a nice visualization from Nantasenamat 2021:\n\nLet’s dive into how Pandas objects work in practice.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#using-pandas",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#using-pandas",
    "title": "Introducting Pandas",
    "section": "Using Pandas",
    "text": "Using Pandas\nWe import pandas like this, using the alias pd by convention:\n\nimport pandas as pd\n\nWe almost always import NumPy, too, since we use many of its functions and properties with Pandas.\n\nimport numpy as np",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#versions",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#versions",
    "title": "Introducting Pandas",
    "section": "Versions",
    "text": "Versions\nNote that as of June 2024, NumPy 2.0 has been released, its first major release since 2006.\nThis notebook uses an earlier version.\nTo find out the version of library you are using, you can inspect its .__version__ property.\n\nnp.__version__\n\n'1.24.4'\n\n\nWith respect to Pandas, we are using version 2.0 here.\n\npd.__version__\n\n'2.0.3'",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#series-constructors",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#series-constructors",
    "title": "Introducting Pandas",
    "section": "Series Constructors",
    "text": "Series Constructors\nTo create a Series, you can pass it most any sequence of values.\nHere, we use one of NumPy’s random number generators.\n\nrandos = pd.Series(np.random.randn(10))\nrandos\n\n0   -0.626095\n1    1.039775\n2   -0.943228\n3   -0.785196\n4    1.101974\n5    2.083032\n6    1.141408\n7    0.461128\n8    0.510737\n9    0.530833\ndtype: float64\n\n\nHere we pass a list, and also add an index of labels.\nNot also we can give the Series a name and set a data type.\n\nmy_series = pd.Series(\n    [3, -5, 7, 4], \n    index=['a', 'b', 'c',  'd'],\n    name='feature1',\n    dtype=np.int8\n)\nmy_series\n\na    3\nb   -5\nc    7\nd    4\nName: feature1, dtype: int8\n\n\nSo, now we can access data by label.\n\nmy_series['a']\n\n3\n\n\nNote that although the integer offsets are not shown, they are still there:\n\nmy_series[1]\n\n-5",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#series-properties-and-methods",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#series-properties-and-methods",
    "title": "Introducting Pandas",
    "section": "Series Properties and Methods",
    "text": "Series Properties and Methods\nAs an object, a Series has properties.\n\nmy_series.name, randos.name\n\n('feature1', None)\n\n\n\nmy_series.shape, randos.shape\n\n((4,), (10,))\n\n\n\nmy_series.index\n\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\n\nHere are a sample of methods.\n\nrandos.head() # Get the first five items\n\n0   -0.626095\n1    1.039775\n2   -0.943228\n3   -0.785196\n4    1.101974\ndtype: float64\n\n\n\nrandos.describe() # Computes basic stats\n\ncount    10.000000\nmean      0.451437\nstd       0.974842\nmin      -0.943228\n25%      -0.354289\n50%       0.520785\n75%       1.086424\nmax       2.083032\ndtype: float64\n\n\n\nrandos.sum() # Sums up all the values\n\n4.514367728388432\n\n\nYou can even generate a plot very quickly.\nNumPy combines the functionality of NumPy with Matplotlib.\n\nrandos.plot() # Generates a Matplotlib graph",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#data-frame-constructors",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#data-frame-constructors",
    "title": "Introducting Pandas",
    "section": "Data Frame Constructors",
    "text": "Data Frame Constructors\nThere are several ways to create Pandas DataFrames.\nHere, we create one by passing a dictionary of lists:\n\ndf = pd.DataFrame({\n    'x': [0, 2, 1, 5], \n    'y': [1, 1, 0, 0], \n    'z': [True, False, False, False]\n})\ndf\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\nNote how Jupyter provides a pleasing representation of the DataFrame, using bold to signify the index labels along both axes.\nHere are some properties of DataFrames:\n\ndf.index\n\nRangeIndex(start=0, stop=4, step=1)\n\n\n\nlist(df.index) # We can covert the index object into a list\n\n[0, 1, 2, 3]\n\n\n\ndf.columns\n\nIndex(['x', 'y', 'z'], dtype='object')\n\n\n\nlist(df.columns) # Same with columns\n\n['x', 'y', 'z']\n\n\n\ndf.values # The data themselves\n\narray([[0, 1, True],\n       [2, 1, False],\n       [1, 0, False],\n       [5, 0, False]], dtype=object)\n\n\n\ntype(df.values) # Note that this is a NumPy array\n\nnumpy.ndarray\n\n\nAnother way to construct a DataFrame is to pass the constructor a list of tuples (or lists).\nHere we also define the column names.\n\nmy_data = [\n    ('a', 1, True),\n    ('b', 2, False),\n    ('c', 4, True)\n]\ndf2 = pd.DataFrame(my_data, columns=['f1', 'f2', 'f3'])\ndf2\n\n\n\n\n\n\n\n\nf1\nf2\nf3\n\n\n\n\n0\na\n1\nTrue\n\n\n1\nb\n2\nFalse\n\n\n2\nc\n4\nTrue\n\n\n\n\n\n\n\nWe can also pass an index of labels.\n\ndf3 = pd.DataFrame(\n    columns=['x','y'], \n    index=['A','B','C'], \n    data=[[9,3],[1,2],[4,6]])\ndf3\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\nA\n9\n3\n\n\nB\n1\n2\n\n\nC\n4\n6",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#naming-indexes",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#naming-indexes",
    "title": "Introducting Pandas",
    "section": "Naming indexes",
    "text": "Naming indexes\nIndexes are important in Pandas.\nIt is helpful to name them.\nOne way to do this is to assign the .index.name property after construction.\n\ndf2.index.name = 'obs_id'\ndf2\n\n\n\n\n\n\n\n\nf1\nf2\nf3\n\n\nobs_id\n\n\n\n\n\n\n\n0\na\n1\nTrue\n\n\n1\nb\n2\nFalse\n\n\n2\nc\n4\nTrue\n\n\n\n\n\n\n\nNote how Jupyter represents the index name separately from the column names.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#why-have-an-index",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#why-have-an-index",
    "title": "Introducting Pandas",
    "section": "Why have an index?",
    "text": "Why have an index?\nIndexes provide a way to access elements of the array by name.\nThey also allow series and data frame objects that share index labels to be combined, through joins and other data operations.\nThey allow for all kinds of magic to take place when combining and accessing data.\nBut they are expensive and sometimes hard to work with.\nThey are especially difficult if you are coming from R and expecting dataframes to behave a certain way.\nIn any case, an understanding of them is crucial for the effective use of Pandas.\nTo repeat the point made earlier, a DataFrame is a collection of Series objects with a common index.\nTo this collection of series, the dataframe also adds a labeled index along the horizontal axis.\nThe row index is usually just called the index, while the column index is just called the columns.\nIt is crucial to understand the difference between the index of a dataframe and its data in order to understand how dataframes work.\nMany a headache is caused by not understanding this difference :-)",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#multidimensional-indexes",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#multidimensional-indexes",
    "title": "Introducting Pandas",
    "section": "Multidimensional Indexes",
    "text": "Multidimensional Indexes\nNote that both index and column labels can be multidimensional.\nThese are called Hierarchical Indexes and go the technical name of MultiIndexes.\nAs an example, consider the following table of sentences in a novel:\n\nbooks = pd.DataFrame({\n    'book_id': [105, 105, 105, 105, 105, 105],\n    'chap_id': [1, 1, 1, 1, 1, 1],\n    'para_id': [1, 1, 1, 1, 1, 1],\n    'sent_id': [1, 2, 3, 4, 5, 6],\n    'content': [\n        \"Sir Walter Elliot, of Kellynch Hall, in Somersetshire, was a man who, for his own amusement, never took up any book but the Baronetage; \", \n        \"there he found occupation for an idle hour, and consolation in a distressed one; \", \n        \"there his faculties were roused into admiration and respect, by contemplating the limited remnant of the earliest patents; \",\n        \"there any unwelcome sensations, arising from domestic affairs changed naturally into pity and contempt as he turned over the almost endless creations of the last century; \",\n        \"and there, if every other leaf were powerless, he could read his own history with an interest which never failed. \",\n        \"This was the page at which the favourite volume always opened:\"]\n})\nbooks\n\n\n\n\n\n\n\n\nbook_id\nchap_id\npara_id\nsent_id\ncontent\n\n\n\n\n0\n105\n1\n1\n1\nSir Walter Elliot, of Kellynch Hall, in Somers...\n\n\n1\n105\n1\n1\n2\nthere he found occupation for an idle hour, an...\n\n\n2\n105\n1\n1\n3\nthere his faculties were roused into admiratio...\n\n\n3\n105\n1\n1\n4\nthere any unwelcome sensations, arising from d...\n\n\n4\n105\n1\n1\n5\nand there, if every other leaf were powerless,...\n\n\n5\n105\n1\n1\n6\nThis was the page at which the favourite volum...\n\n\n\n\n\n\n\nHere we use .set_index() to convert some columns to index names.\n\nbooks = books.set_index(list(books.columns[:4]))\nbooks.head()\n\n\n\n\n\n\n\n\n\n\n\ncontent\n\n\nbook_id\nchap_id\npara_id\nsent_id\n\n\n\n\n\n105\n1\n1\n1\nSir Walter Elliot, of Kellynch Hall, in Somers...\n\n\n2\nthere he found occupation for an idle hour, an...\n\n\n3\nthere his faculties were roused into admiratio...\n\n\n4\nthere any unwelcome sensations, arising from d...\n\n\n5\nand there, if every other leaf were powerless,...",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#copying-dataframes",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#copying-dataframes",
    "title": "Introducting Pandas",
    "section": "Copying DataFrames",
    "text": "Copying DataFrames\nAs with NumPy arrays, you need to pay attention to the difference between a view and copy.\nUse .copy() to give the new df a clean break from the original.\nOtherwise, the copied df will point to the same object as the original.\nHere is an example.\n\ndf = pd.DataFrame(\n    {\n        'x':[0,2,1,5], \n        'y':[1,1,0,0], \n        'z':[True,False,False,False]\n    }\n) \n\n\ndf\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\nWe create two copies, one “deep” and one “shallow”.\n\ndf_deep    = df.copy()  # deep copy; changes to df will not pass through\ndf_shallow = df         # shallow copy; changes to df will pass through\n\nIf we alter a value in the original …\n\ndf.x = 1\n\n\ndf\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n1\n1\nTrue\n\n\n1\n1\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n1\n0\nFalse\n\n\n\n\n\n\n\n… then the shallow copy is also changed …\n\ndf_shallow\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n1\n1\nTrue\n\n\n1\n1\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n1\n0\nFalse\n\n\n\n\n\n\n\n… while the deep copy is not.\n\ndf_deep\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\nOf course, the reverse is true too — changes to the shallow copy affect the original:\n\ndf_shallow.y = 99\n\n\ndf\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n1\n99\nTrue\n\n\n1\n1\n99\nFalse\n\n\n2\n1\n99\nFalse\n\n\n3\n1\n99\nFalse\n\n\n\n\n\n\n\nSo, df_shallow mirrors changes to df, since it references its indices and data.\ndf_deep does not reference df, and so changes to df do not impact df_deep.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-data-types",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-data-types",
    "title": "Introducting Pandas",
    "section": "Column Data Types",
    "text": "Column Data Types\nYou can access the data types of the columns in a couple of ways.\n\ndf = pd.DataFrame({'x':[0,2,1,5], 'y':[1,1,0,0], 'z':[True,False,False,False]}) \ndf\n\n\n\n\n\n\n\n\nx\ny\nz\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\n\ndf.dtypes # Show the datatypes of the columns \n\nx    int64\ny    int64\nz     bool\ndtype: object\n\n\n\ndf.info() # Show more detailed information about the DataFrame\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 4 entries, 0 to 3\nData columns (total 3 columns):\n #   Column  Non-Null Count  Dtype\n---  ------  --------------  -----\n 0   x       4 non-null      int64\n 1   y       4 non-null      int64\n 2   z       4 non-null      bool \ndtypes: bool(1), int64(2)\nmemory usage: 200.0 bytes",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-renaming",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-renaming",
    "title": "Introducting Pandas",
    "section": "Column Renaming",
    "text": "Column Renaming\nYou can rename one or more fields at once using a dictionary.\nHere, we rename the field z to is_label:\n\ndf = df.rename(columns={'z': 'is_label'})\n\n\ndf\n\n\n\n\n\n\n\n\nx\ny\nis_label\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\nYou can also change column names by just reassigning the columns property:\n\nold_cols = df.columns # Keep a copy so we can revert\ndf.columns = ['X','Y', 'LABEL']\n\n\ndf\n\n\n\n\n\n\n\n\nX\nY\nLABEL\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\n\ndf.columns = old_cols # Reset things\n\n\ndf\n\n\n\n\n\n\n\n\nx\ny\nis_label\n\n\n\n\n0\n0\n1\nTrue\n\n\n1\n2\n1\nFalse\n\n\n2\n1\n0\nFalse\n\n\n3\n5\n0\nFalse\n\n\n\n\n\n\n\nYou can also transform column named easily:\n\ndf3\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\nA\n9\n3\n\n\nB\n1\n2\n\n\nC\n4\n6\n\n\n\n\n\n\n\n\ndf3.columns = df3.columns.str.upper()\n\n\ndf3\n\n\n\n\n\n\n\n\nX\nY\n\n\n\n\nA\n9\n3\n\n\nB\n1\n2\n\n\nC\n4\n6",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-referencing",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-referencing",
    "title": "Introducting Pandas",
    "section": "Column Referencing",
    "text": "Column Referencing\nPandas supports both bracket notation and dot notation to access column data.\nThis is bracket notation:\n\ndf['y']\n\n0    1\n1    1\n2    0\n3    0\nName: y, dtype: int64\n\n\nAnd this is dot . notation:\n\ndf.y\n\n0    1\n1    1\n2    0\n3    0\nName: y, dtype: int64\n\n\nDot notation is very convenient, since as object attributes they can be tab-completed in various editing environments.\nBut it only works if the column names are not reserved words.\nAnd it can’t be used when creating a new column (see below).\nIt is convenient to names columns with a prefix, e.g. doc_title, doc_year, doc_author, etc. to avoid name collisions.\nColumn attributes and methods work with both:\n\ndf.y.values, df['y'].values\n\n(array([1, 1, 0, 0]), array([1, 1, 0, 0]))\n\n\nHere we get the first element of a column by indexing:\n\ndf.y.values[0]\n\n1",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-selection",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#column-selection",
    "title": "Introducting Pandas",
    "section": "Column Selection",
    "text": "Column Selection\nYou select columns from a dataframe by passing a value or list (or any expression that evaluates to a list).\nCalling a columns with a scalar returns a Series:\n\ndf['x']\n\n0    0\n1    2\n2    1\n3    5\nName: x, dtype: int64\n\n\n\ntype(df['x'])\n\npandas.core.series.Series\n\n\nBut calling a column with a list returns a dataframe:\n\ndf[['x']]\n\n\n\n\n\n\n\n\nx\n\n\n\n\n0\n0\n\n\n1\n2\n\n\n2\n1\n\n\n3\n5\n\n\n\n\n\n\n\n\ntype(df[['x']])\n\npandas.core.frame.DataFrame\n\n\nWe saw this in discussing the difference between vectors (\\(1\\)-D arrays) and \\(2\\)-D arrays with one column or row.\nWe also saw how accessing array data by integer or slice affected the return value.\nIn Pandas, we can use “fancy indexing” with labels:\n\ndf[['y', 'x']]\n\n\n\n\n\n\n\n\ny\nx\n\n\n\n\n0\n1\n0\n\n\n1\n1\n2\n\n\n2\n0\n1\n\n\n3\n0\n5\n\n\n\n\n\n\n\nWe can put in a list comprehension, too:\n\ndf[[col for col in df.columns if col not in ['x','y']]]\n\n\n\n\n\n\n\n\nis_label\n\n\n\n\n0\nTrue\n\n\n1\nFalse\n\n\n2\nFalse\n\n\n3\nFalse",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#adding-new-columns",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#adding-new-columns",
    "title": "Introducting Pandas",
    "section": "Adding New Columns",
    "text": "Adding New Columns\nIt is typical to create a new column from existing columns.\nIn this example, a new column is created by summing x and y:\n\ndf['x_plus_y'] = df.x + df.y\n\n\ndf\n\n\n\n\n\n\n\n\nx\ny\nis_label\nx_plus_y\n\n\n\n\n0\n0\n1\nTrue\n1\n\n\n1\n2\n1\nFalse\n3\n\n\n2\n1\n0\nFalse\n1\n\n\n3\n5\n0\nFalse\n5\n\n\n\n\n\n\n\nNote the use of bracket notation on the left.\nWhen new columns are created, you must use bracket notation.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#removing-columns",
    "href": "notebooks/M06_Pandas/M06-00-IntroducingPandas.html#removing-columns",
    "title": "Introducting Pandas",
    "section": "Removing Columns",
    "text": "Removing Columns\ndel() can be used to delete any object in Python.\ndel does the same thing.\ndel() can drop a DataFrame or single columns from the frame\n\ndf_drop = df.copy()\n\n\ndf_drop.head(2)\n\n\n\n\n\n\n\n\nx\ny\nis_label\nx_plus_y\n\n\n\n\n0\n0\n1\nTrue\n1\n\n\n1\n2\n1\nFalse\n3\n\n\n\n\n\n\n\n\ndel(df_drop['x'])\n\n\ndf_drop\n\n\n\n\n\n\n\n\ny\nis_label\nx_plus_y\n\n\n\n\n0\n1\nTrue\n1\n\n\n1\n1\nFalse\n3\n\n\n2\n0\nFalse\n1\n\n\n3\n0\nFalse\n5\n\n\n\n\n\n\n\n.drop() can drop one or more columns.\nThis takes the axis parameter, where\n\naxis=0 refers to rows\nand axis=1 refers to columns.\n\n\ndf_drop = df_drop.drop(['x_plus_y', 'is_label'], axis=1)\n\n\ndf_drop\n\n\n\n\n\n\n\n\ny\n\n\n\n\n0\n1\n\n\n1\n1\n\n\n2\n0\n\n\n3\n0",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Introducting Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html",
    "title": "Exploring Pandas",
    "section": "",
    "text": "Load Iris Dataset\nWe’ll grab the dataset from the Seaborn visualization package.\nThe function load_dataset() in seaborn loads the built-in dataset.\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\niris = sns.load_dataset('iris')\niris\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n...\n...\n...\n...\n...\n...\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n150 rows × 5 columns\niris.shape\n\n(150, 5)",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#heads-and-tails",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#heads-and-tails",
    "title": "Exploring Pandas",
    "section": "Heads and Tails",
    "text": "Heads and Tails\nWe can quickly inspect the data with .head() and .tail().\nAs we saw with Series, .head() returns the first \\(5\\) rows and .tail() the last.\n\niris.head()\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n\n\n\n\n\n\niris.tail()\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n\n\n\nYou can return fewer or more rows by passing a different positive integer to these methods, e.g. .head(10).\n\niris.head(10)\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n5\n5.4\n3.9\n1.7\n0.4\nsetosa\n\n\n6\n4.6\n3.4\n1.4\n0.3\nsetosa\n\n\n7\n5.0\n3.4\n1.5\n0.2\nsetosa\n\n\n8\n4.4\n2.9\n1.4\n0.2\nsetosa\n\n\n9\n4.9\n3.1\n1.5\n0.1\nsetosa",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#naming-indexes",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#naming-indexes",
    "title": "Exploring Pandas",
    "section": "Naming Indexes",
    "text": "Naming Indexes\nWe can name indexes, which is important to do in many cases.\n\niris.index.name = 'obs_id' # Each observation is a unique plant\n\n\niris\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n...\n...\n...\n...\n...\n...\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n150 rows × 5 columns",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#using-a-multiindex",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#using-a-multiindex",
    "title": "Exploring Pandas",
    "section": "Using a MultiIndex",
    "text": "Using a MultiIndex\nWe can also redefine indexes to reflect the logic of our data.\nIn this data set, the species of the flower is part of its identity, so it can be part of the index.\nThe other features vary by individual.\nNote that species is also a label that can be used for training a model to predict the species of an iris flower. In that use case, the column would be pulled out into a separate vector.\n\niris_w_idx = iris.reset_index().set_index(['species','obs_id'])\n\n\niris_w_idx.sample(10)\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\nsetosa\n39\n5.1\n3.4\n1.5\n0.2\n\n\nversicolor\n82\n5.8\n2.7\n3.9\n1.2\n\n\nvirginica\n124\n6.7\n3.3\n5.7\n2.1\n\n\nsetosa\n10\n5.4\n3.7\n1.5\n0.2\n\n\n41\n4.5\n2.3\n1.3\n0.3\n\n\nvirginica\n117\n7.7\n3.8\n6.7\n2.2\n\n\nversicolor\n89\n5.5\n2.5\n4.0\n1.3\n\n\nvirginica\n123\n6.3\n2.7\n4.9\n1.8\n\n\nsetosa\n4\n5.0\n3.6\n1.4\n0.2\n\n\nversicolor\n65\n6.7\n3.1\n4.4\n1.4",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#row-selection-filtering",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#row-selection-filtering",
    "title": "Exploring Pandas",
    "section": "Row Selection (Filtering)",
    "text": "Row Selection (Filtering)\n\n.iloc[]\nYou can extract rows using indexes with .iloc[].\nThis works by indexing rows by their numeric sequence value.\nThis fetches row 3, and all columns.\n\niris.iloc[2]\n\nsepal_length       4.7\nsepal_width        3.2\npetal_length       1.3\npetal_width        0.2\nspecies         setosa\nName: 2, dtype: object\n\n\nWe can use a slice to fetch rows with indices 1 and 2 (the right endpoint is exclusive), and all columns.\n\niris.iloc[1:3]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#combining-filtering-and-selecting",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#combining-filtering-and-selecting",
    "title": "Exploring Pandas",
    "section": "Combining Filtering and Selecting",
    "text": "Combining Filtering and Selecting\nRecall the comma notation from NumPy — it is used here, too.\nThe first element is a row selector, the second a column selector.\nIn database terminology, row selection is called filtering.\nHere we fetch rows 1 and 2 with and first three columns.\n\niris.iloc[1:3, 0:3]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\n\n\nobs_id\n\n\n\n\n\n\n\n1\n4.9\n3.0\n1.4\n\n\n2\n4.7\n3.2\n1.3\n\n\n\n\n\n\n\n\n.loc[]\nFiltering can also be done with .loc[].\nThis uses the row names and column names.\nHere we ask for rows with labels 1, 2, and 3.\nNote the slice returns the row with obs_id 3.\n.iloc[] would return rows with indices 1, 2.\n\niris.loc[1:3]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n\n\n\n\n\n\niris.loc[1:3, ['sepal_width','sepal_length']]\n\n\n\n\n\n\n\n\nsepal_width\nsepal_length\n\n\nobs_id\n\n\n\n\n\n\n1\n3.0\n4.9\n\n\n2\n3.2\n4.7\n\n\n3\n3.1\n4.6\n\n\n\n\n\n\n\nThe different behavior of the slice with .loc, 1:3 is due to the fact that it is short-hand for [1,2,3], a list of labels, not a range of offsets.\n\niris.loc[[1,2,3]]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n\n\n\n\n\nSo, for example, since there is no label value -1, this won’t work:\n\niris.loc[:-1]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we subset on columns with column names as a list of strings:\n\niris.loc[1:3, ['sepal_length','petal_width']]\n\n\n\n\n\n\n\n\nsepal_length\npetal_width\n\n\nobs_id\n\n\n\n\n\n\n1\n4.9\n0.2\n\n\n2\n4.7\n0.2\n\n\n3\n4.6\n0.2\n\n\n\n\n\n\n\nHere we select all rows, specific columns:\n\niris.loc[:, ['sepal_length','petal_width']]\n\n\n\n\n\n\n\n\nsepal_length\npetal_width\n\n\nobs_id\n\n\n\n\n\n\n0\n5.1\n0.2\n\n\n1\n4.9\n0.2\n\n\n2\n4.7\n0.2\n\n\n3\n4.6\n0.2\n\n\n4\n5.0\n0.2\n\n\n...\n...\n...\n\n\n145\n6.7\n2.3\n\n\n146\n6.3\n1.9\n\n\n147\n6.5\n2.0\n\n\n148\n6.2\n2.3\n\n\n149\n5.9\n1.8\n\n\n\n\n150 rows × 2 columns\n\n\n\nThat is same as this:\n\niris[['sepal_length','petal_width']]\n\n\n\n\n\n\n\n\nsepal_length\npetal_width\n\n\nobs_id\n\n\n\n\n\n\n0\n5.1\n0.2\n\n\n1\n4.9\n0.2\n\n\n2\n4.7\n0.2\n\n\n3\n4.6\n0.2\n\n\n4\n5.0\n0.2\n\n\n...\n...\n...\n\n\n145\n6.7\n2.3\n\n\n146\n6.3\n1.9\n\n\n147\n6.5\n2.0\n\n\n148\n6.2\n2.3\n\n\n149\n5.9\n1.8\n\n\n\n\n150 rows × 2 columns\n\n\n\nWe can use .loc[] with a MultiIndex, too.\nRecall our DataFrame with a two element index:\n\niris_w_idx\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n3\n4.6\n3.1\n1.5\n0.2\n\n\n4\n5.0\n3.6\n1.4\n0.2\n\n\n...\n...\n...\n...\n...\n...\n\n\nvirginica\n145\n6.7\n3.0\n5.2\n2.3\n\n\n146\n6.3\n2.5\n5.0\n1.9\n\n\n147\n6.5\n3.0\n5.2\n2.0\n\n\n148\n6.2\n3.4\n5.4\n2.3\n\n\n149\n5.9\n3.0\n5.1\n1.8\n\n\n\n\n150 rows × 4 columns\n\n\n\nWe can select a single observation by its key, i.e. full label, expressed as a tuple:\n\niris_w_idx.loc[('setosa',0)]\n\nsepal_length    5.1\nsepal_width     3.5\npetal_length    1.4\npetal_width     0.2\nName: (setosa, 0), dtype: float64\n\n\nWe may also select all the setosas by using the first index column:\n\niris_w_idx.loc['setosa'].head()\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nobs_id\n\n\n\n\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n3\n4.6\n3.1\n1.5\n0.2\n\n\n4\n5.0\n3.6\n1.4\n0.2\n\n\n\n\n\n\n\nHere we grab one species and one feature:\n\niris_w_idx.loc['setosa', 'sepal_length'].head()\n\nobs_id\n0    5.1\n1    4.9\n2    4.7\n3    4.6\n4    5.0\nName: sepal_length, dtype: float64\n\n\nNote that this returns a Series.\nIf we want a DataFrame back, we can use .to_frame():\n\niris_w_idx.loc['setosa', 'sepal_length'].to_frame().head()\n\n\n\n\n\n\n\n\nsepal_length\n\n\nobs_id\n\n\n\n\n\n0\n5.1\n\n\n1\n4.9\n\n\n2\n4.7\n\n\n3\n4.6\n\n\n4\n5.0\n\n\n\n\n\n\n\nOr we might pass a list instead of a string for the column selector:\n\niris_w_idx.loc['setosa', ['sepal_length']].head()\n\n\n\n\n\n\n\n\nsepal_length\n\n\nobs_id\n\n\n\n\n\n0\n5.1\n\n\n1\n4.9\n\n\n2\n4.7\n\n\n3\n4.6\n\n\n4\n5.0\n\n\n\n\n\n\n\nWe use a tuple to index multiple index levels.\n\niris_w_idx.loc[('setosa', 5)]\n\nsepal_length    5.4\nsepal_width     3.9\npetal_length    1.7\npetal_width     0.4\nName: (setosa, 5), dtype: float64\n\n\nOr a list to get multiple rows, a la fancy indexing.\n\niris_w_idx.loc[['setosa','virginica']]\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n3\n4.6\n3.1\n1.5\n0.2\n\n\n4\n5.0\n3.6\n1.4\n0.2\n\n\n...\n...\n...\n...\n...\n...\n\n\nvirginica\n145\n6.7\n3.0\n5.2\n2.3\n\n\n146\n6.3\n2.5\n5.0\n1.9\n\n\n147\n6.5\n3.0\n5.2\n2.0\n\n\n148\n6.2\n3.4\n5.4\n2.3\n\n\n149\n5.9\n3.0\n5.1\n1.8\n\n\n\n\n100 rows × 4 columns",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#boolean-indexing",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#boolean-indexing",
    "title": "Exploring Pandas",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nIt’s very common to subset a DataFrame based on some condition on the data.\nNote that even though we are filtering rows, we are not using .loc[] or .iloc[] here.\nPandas knows what to do if you pass a boolean structure.\nHere is a boolean Series.\n\niris.sepal_length &gt;= 7.5\n\nobs_id\n0      False\n1      False\n2      False\n3      False\n4      False\n       ...  \n145    False\n146    False\n147    False\n148    False\n149    False\nName: sepal_length, Length: 150, dtype: bool\n\n\nWe can pass it to the DataFrame to select the True rows:\n\niris[iris.sepal_length &gt;= 7.5]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n105\n7.6\n3.0\n6.6\n2.1\nvirginica\n\n\n117\n7.7\n3.8\n6.7\n2.2\nvirginica\n\n\n118\n7.7\n2.6\n6.9\n2.3\nvirginica\n\n\n122\n7.7\n2.8\n6.7\n2.0\nvirginica\n\n\n131\n7.9\n3.8\n6.4\n2.0\nvirginica\n\n\n135\n7.7\n3.0\n6.1\n2.3\nvirginica\n\n\n\n\n\n\n\nAnd we may combine boolean expressions, too, making sure we group things with parentheses.\n\niris[(iris.sepal_length &gt;= 4.5) & (iris.sepal_length &lt;= 4.7)]\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n6\n4.6\n3.4\n1.4\n0.3\nsetosa\n\n\n22\n4.6\n3.6\n1.0\n0.2\nsetosa\n\n\n29\n4.7\n3.2\n1.6\n0.2\nsetosa\n\n\n41\n4.5\n2.3\n1.3\n0.3\nsetosa\n\n\n47\n4.6\n3.2\n1.4\n0.2\nsetosa\n\n\n\n\n\n\n\nAnd here we add a column selection.\n\niris.loc[(iris.sepal_length &gt;= 4.5) & (iris.sepal_length &lt;= 4.7), ['sepal_length']]\n\n\n\n\n\n\n\n\nsepal_length\n\n\nobs_id\n\n\n\n\n\n2\n4.7\n\n\n3\n4.6\n\n\n6\n4.6\n\n\n22\n4.6\n\n\n29\n4.7\n\n\n41\n4.5\n\n\n47\n4.6",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#working-with-missing-data",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#working-with-missing-data",
    "title": "Exploring Pandas",
    "section": "Working with Missing Data",
    "text": "Working with Missing Data\nPandas primarily uses the data type np.nan from NumPy to represent missing data.\n\ndf_miss = pd.DataFrame({\n    'x': [2, np.nan, 1], \n    'y': [np.nan, np.nan, 6]}\n)\n\nThese values appear as NaNs:\n\ndf_miss\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n2.0\nNaN\n\n\n1\nNaN\nNaN\n\n\n2\n1.0\n6.0\n\n\n\n\n\n\n\n\n.dropna()\nWe can drop all rows with missing data in any column using dropna().\n\ndf_drop_all = df_miss.dropna()\ndf_drop_all\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n2\n1.0\n6.0\n\n\n\n\n\n\n\nThe subset parameter takes a list of column names to specify which columns should have missing values.\n\ndf_drop_x = df_miss.dropna(subset=['x'])\ndf_drop_x\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n2.0\nNaN\n\n\n2\n1.0\n6.0\n\n\n\n\n\n\n\n\n\n.fillna()\nThis will replace missing values with whatever you set it to, e.g. \\(0\\)s.\nWe can pass the results of an operation — for example to peform simple imputation, we can replace missing values in each column with the median value of the respective column:\n\ndf_filled = df_miss.fillna(df_miss.median())\n\n\ndf_filled\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n2.0\n6.0\n\n\n1\n1.5\n6.0\n\n\n2\n1.0\n6.0",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#sorting",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#sorting",
    "title": "Exploring Pandas",
    "section": "Sorting",
    "text": "Sorting\n\n.sort_values()\nWe use .sort_values() to sort the data in a DataFrame.\nThe by parameter takes string or list of strings, defining the columns and order to sort on.\nThe ascending parameter takes True or False. This may be a list if you want diffferent sort order for different columns.\nAnd the inplace paramter takes True or False.\n\niris.sort_values(by=['sepal_length','petal_width'], ascending=False).head(10)\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n131\n7.9\n3.8\n6.4\n2.0\nvirginica\n\n\n118\n7.7\n2.6\n6.9\n2.3\nvirginica\n\n\n135\n7.7\n3.0\n6.1\n2.3\nvirginica\n\n\n117\n7.7\n3.8\n6.7\n2.2\nvirginica\n\n\n122\n7.7\n2.8\n6.7\n2.0\nvirginica\n\n\n105\n7.6\n3.0\n6.6\n2.1\nvirginica\n\n\n130\n7.4\n2.8\n6.1\n1.9\nvirginica\n\n\n107\n7.3\n2.9\n6.3\n1.8\nvirginica\n\n\n109\n7.2\n3.6\n6.1\n2.5\nvirginica\n\n\n125\n7.2\n3.2\n6.0\n1.8\nvirginica\n\n\n\n\n\n\n\n\n\n.sort_index()\nRecall that indexes and data are accessed differently in Pandas.\nTo sort the index of a DataFrame, use this method.\n\niris.sort_index(axis=0, ascending=False)\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n...\n...\n...\n...\n...\n...\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n\n\n150 rows × 5 columns",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#statistics",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#statistics",
    "title": "Exploring Pandas",
    "section": "Statistics",
    "text": "Statistics\nPandas has a number of statistic operations built into it.\n\n.describe()\nAs we saw above, this method computes some basic statistics from the DataTable if applicable.\n\niris.describe()\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\n\n\ncount\n150.000000\n150.000000\n150.000000\n150.000000\n\n\nmean\n5.843333\n3.057333\n3.758000\n1.199333\n\n\nstd\n0.828066\n0.435866\n1.765298\n0.762238\n\n\nmin\n4.300000\n2.000000\n1.000000\n0.100000\n\n\n25%\n5.100000\n2.800000\n1.600000\n0.300000\n\n\n50%\n5.800000\n3.000000\n4.350000\n1.300000\n\n\n75%\n6.400000\n3.300000\n5.100000\n1.800000\n\n\nmax\n7.900000\n4.400000\n6.900000\n2.500000\n\n\n\n\n\n\n\nWe can transpose this for easier reading:\n\niris.describe().T\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\nsepal_length\n150.0\n5.843333\n0.828066\n4.3\n5.1\n5.80\n6.4\n7.9\n\n\nsepal_width\n150.0\n3.057333\n0.435866\n2.0\n2.8\n3.00\n3.3\n4.4\n\n\npetal_length\n150.0\n3.758000\n1.765298\n1.0\n1.6\n4.35\n5.1\n6.9\n\n\npetal_width\n150.0\n1.199333\n0.762238\n0.1\n0.3\n1.30\n1.8\n2.5\n\n\n\n\n\n\n\nWe can also call it on a single feature, i.e. a Series.\nNotice the difference between a column of strings and one of numbers.\n\niris.species.describe()\n\ncount        150\nunique         3\ntop       setosa\nfreq          50\nName: species, dtype: object\n\n\n\niris.sepal_length.describe()\n\ncount    150.000000\nmean       5.843333\nstd        0.828066\nmin        4.300000\n25%        5.100000\n50%        5.800000\n75%        6.400000\nmax        7.900000\nName: sepal_length, dtype: float64\n\n\n\n\n.value_counts()\nThis is a highly useful function for showing the frequency for each distinct value in a column.\n\niris.species.value_counts()\n\nspecies\nsetosa        50\nversicolor    50\nvirginica     50\nName: count, dtype: int64\n\n\nWe can also extract a new table for the distinct values of a column.\n\nSPECIES = iris.species.value_counts().to_frame('n')\nSPECIES\n\n\n\n\n\n\n\n\nn\n\n\nspecies\n\n\n\n\n\nsetosa\n50\n\n\nversicolor\n50\n\n\nvirginica\n50\n\n\n\n\n\n\n\nWe can show relative frequency instead of counts:\n\niris.species.value_counts(normalize=True)\n\nspecies\nsetosa        0.333333\nversicolor    0.333333\nvirginica     0.333333\nName: proportion, dtype: float64\n\n\nThe method returns a Series that can be converted into a DataFrame.\n\nSEPAL_LENGTH = iris.sepal_length.value_counts().to_frame('n')\n\n\nSEPAL_LENGTH.head()\n\n\n\n\n\n\n\n\nn\n\n\nsepal_length\n\n\n\n\n\n5.0\n10\n\n\n5.1\n9\n\n\n6.3\n9\n\n\n5.7\n8\n\n\n6.7\n8\n\n\n\n\n\n\n\nYou can run .value_counts() on a column to get a kind of histogram:\n\nSEPAL_LENGTH.sort_index().plot.bar(figsize=(8,4), rot=45);\n\n\n\n\n\n\n\n\nYou can see that this method produces similar results to a histogram:\n\niris.sepal_length.hist(bins=20);\n\n\n\n\n\n\n\n\n\n\n.mean()\nStatistical properties are easily computed.\nOperations like this generally exclude missing data.\nSo, it is import to convert missing data to values if they need to be considered in the denominator.\n\niris.sepal_length.mean()\n\n5.843333333333334\n\n\n\n\n.max()\n\niris.sepal_length.max()\n\n7.9\n\n\n\n\n.std()\nThis standard deviation.\n\niris.sepal_length.std()\n\n0.828066127977863\n\n\n\n\n.corr()\nWe may get the correlations among features with .corr():\n\n# iris.corr() # Won't work because of string column\n\n\niris.corr(numeric_only=True, method='pearson') \n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\n\n\nsepal_length\n1.000000\n-0.117570\n0.871754\n0.817941\n\n\nsepal_width\n-0.117570\n1.000000\n-0.428440\n-0.366126\n\n\npetal_length\n0.871754\n-0.428440\n1.000000\n0.962865\n\n\npetal_width\n0.817941\n-0.366126\n0.962865\n1.000000\n\n\n\n\n\n\n\n\niris_w_idx.corr() # This works because we moved the string into the index\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\n\n\nsepal_length\n1.000000\n-0.117570\n0.871754\n0.817941\n\n\nsepal_width\n-0.117570\n1.000000\n-0.428440\n-0.366126\n\n\npetal_length\n0.871754\n-0.428440\n1.000000\n0.962865\n\n\npetal_width\n0.817941\n-0.366126\n0.962865\n1.000000\n\n\n\n\n\n\n\nNote that the method parameter defaults to pearson.\nYou may also use spearman, kendall, or a custom function.\nCorrelation can be computed on two columns, or features, by subsetting on them:\n\niris[['sepal_length','petal_length']].corr()\n\n\n\n\n\n\n\n\nsepal_length\npetal_length\n\n\n\n\nsepal_length\n1.000000\n0.871754\n\n\npetal_length\n0.871754\n1.000000\n\n\n\n\n\n\n\nHere we correlate three features:\n\niris[['sepal_length','petal_length','sepal_width']].corr()\n\n\n\n\n\n\n\n\nsepal_length\npetal_length\nsepal_width\n\n\n\n\nsepal_length\n1.000000\n0.871754\n-0.11757\n\n\npetal_length\n0.871754\n1.000000\n-0.42844\n\n\nsepal_width\n-0.117570\n-0.428440\n1.00000",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#styling",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#styling",
    "title": "Exploring Pandas",
    "section": "Styling",
    "text": "Styling\nPandas provides methods for styling DataFrames as quick way to visualize data.\n\niris.corr(numeric_only=True).style.background_gradient(cmap=\"Blues\", axis=None)\n\n\n\n\n\n\n \nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\n\n\nsepal_length\n1.000000\n-0.117570\n0.871754\n0.817941\n\n\nsepal_width\n-0.117570\n1.000000\n-0.428440\n-0.366126\n\n\npetal_length\n0.871754\n-0.428440\n1.000000\n0.962865\n\n\npetal_width\n0.817941\n-0.366126\n0.962865\n1.000000",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#visualization-with-.plot",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#visualization-with-.plot",
    "title": "Exploring Pandas",
    "section": "Visualization with .plot()",
    "text": "Visualization with .plot()\nThe .plot() method allows for quick visualizations such as scatterplots, bar charts, and histograms.\nWe will cover visualization separately in more detail.\n\nmy_features = ['sepal_length', 'petal_length']\nmy_title = f\"r={round(iris[features].corr().iloc[0,1], 2)}\" \niris.plot.scatter(*my_features, title=my_title);\n\n\n\n\n\n\n\n\nHere we plot all the data as points.\nNote how .plot() color codes the features for us.\n\niris.sort_values(list(iris.columns)).plot(style='o', figsize=(10,10));\n\n\n\n\n\n\n\n\nHere we use Seaborn’s scatter matrix function.\n\nfrom pandas.plotting import scatter_matrix\n\n\nscatter_matrix(iris, figsize=(10,10));",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#saving-to-a-csv-file",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#saving-to-a-csv-file",
    "title": "Exploring Pandas",
    "section": "Saving to a CSV File",
    "text": "Saving to a CSV File\nIt is common practice to save a DataFrame to a CSV file.\nUse .to_csv() for this.\n\niris_w_idx.to_csv('./iris_data.csv', index=True)\n\nThere are also options to save to a database, other file formats, even the clipboard.\nA file path is required; it will create the file if it does not exist, or overwrite it if it does.\nYou may also append by passing a to the mode parameter.\nOther optional parameters include:\nsep: to set the delimiter to something other than a comma, e.g. a pipe | or tab \\t.\nindex: to save the index column(s) or not.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#reading-from-a-csv-file",
    "href": "notebooks/M06_Pandas/M06-01-ExploringPandas.html#reading-from-a-csv-file",
    "title": "Exploring Pandas",
    "section": "Reading from a CSV File",
    "text": "Reading from a CSV File\n.read_csv() reads from CSV into DataFrame\n\niris_loaded = pd.read_csv('./iris_data.csv').set_index('obs_id')\n\n\niris_loaded.head()\n\n\n\n\n\n\n\n\nspecies\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nobs_id\n\n\n\n\n\n\n\n\n\n0\nsetosa\n5.1\n3.5\n1.4\n0.2\n\n\n1\nsetosa\n4.9\n3.0\n1.4\n0.2\n\n\n2\nsetosa\n4.7\n3.2\n1.3\n0.2\n\n\n3\nsetosa\n4.6\n3.1\n1.5\n0.2\n\n\n4\nsetosa\n5.0\n3.6\n1.4\n0.2\n\n\n\n\n\n\n\nNote we apply the .set_index() method immediately.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exploring Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html",
    "title": "Deeper Into Pandas",
    "section": "",
    "text": "Setting Up\nLet’s work with the Iris dataset again.\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\niris = sns.load_dataset('iris')\niris.head()\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\nLet’s configure the index once we load the dataset.\niris.index.name = 'obs_id'\niris = iris.reset_index().set_index(['species', 'obs_id'])\niris.head(5)\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n4.7\n3.2\n1.3\n0.2\n\n\n3\n4.6\n3.1\n1.5\n0.2\n\n\n4\n5.0\n3.6\n1.4\n0.2\nYou may wonder why we used .reset_index() in the previous line of code.\nThis method pops the index columns into the data column space, leaving the default sequence of offsets as the index.\niris.reset_index().head()\n\n\n\n\n\n\n\n\nspecies\nobs_id\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\n\n\n0\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\nsetosa\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\nsetosa\n2\n4.7\n3.2\n1.3\n0.2\n\n\n3\nsetosa\n3\n4.6\n3.1\n1.5\n0.2\n\n\n4\nsetosa\n4\n5.0\n3.6\n1.4\n0.2\nWe do this so that we can use .set_index() which converts data columns into index columns.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#getting-statitistics-by-axis",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#getting-statitistics-by-axis",
    "title": "Deeper Into Pandas",
    "section": "Getting Statitistics by Axis",
    "text": "Getting Statitistics by Axis\nWe saw that we can apply statistical methods, such as .mean(), to Series data.\nWe can also apply them to whole DataFrames. But we need to tell Pandas just how to apply the method.\nIf we use a statistical method on a DataFrame, Pandas defaults to performing the operation over rows for each column Series:\n\niris.mean()\n\nsepal_length    5.843333\nsepal_width     3.057333\npetal_length    3.758000\npetal_width     1.199333\ndtype: float64\n\n\nWe can specify this explicitly with the axis parameter:\n\niris.mean(axis=0)\n\nsepal_length    5.843333\nsepal_width     3.057333\npetal_length    3.758000\npetal_width     1.199333\ndtype: float64\n\n\nIf we wanted the applied method to get the mean over columns for each row, we’d set axis to \\(1\\).\n\niris.mean(axis=1)\n\nspecies    obs_id\nsetosa     0         2.550\n           1         2.375\n           2         2.350\n           3         2.350\n           4         2.550\n                     ...  \nvirginica  145       4.300\n           146       3.925\n           147       4.175\n           148       4.325\n           149       3.950\nLength: 150, dtype: float64\n\n\nIf we want the statistic over all the data, irrespective of row or column position, we set axis to None.\nIn effect, we are reshaping the \\(2\\)-D DataFrame into a \\(1\\)-D Series and getting the mean.\n\niris.mean(axis=None)\n\n3.4644999999999997",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#applying-custom-functions-with-.apply",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#applying-custom-functions-with-.apply",
    "title": "Deeper Into Pandas",
    "section": "Applying Custom Functions with .apply()",
    "text": "Applying Custom Functions with .apply()\nBeyond the vectorized functions provided by Pandas, such as .mean(), we can apply custom functions to our DataFrame.\nYou can use regular functions here, but lambda functions are particularly appropriate.\nThe apply() method should be used after you have established that you can’t use an existing vectorized function.\nHere we create a new feature of the square of the sepal length.\n\niris['sepal_len_sq'] = iris.sepal_length.apply(lambda x: x**2)\niris.head(5)\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nsepal_len_sq\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\n\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n26.01\n\n\n1\n4.9\n3.0\n1.4\n0.2\n24.01\n\n\n2\n4.7\n3.2\n1.3\n0.2\n22.09\n\n\n3\n4.6\n3.1\n1.5\n0.2\n21.16\n\n\n4\n5.0\n3.6\n1.4\n0.2\n25.00\n\n\n\n\n\n\n\nTo apply a function using multiple columns for each row operation, set axis=1.\nHere, we compute the average of sepal_length, sepal_width:\n\niris['sepal_len_wid_avg'] = iris[['sepal_length','sepal_width']]\\\n    .apply(lambda x: (x.sepal_length + x.sepal_width) / 2, axis=1)\niris.head()\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nsepal_len_sq\nsepal_len_wid_avg\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\n\n\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n26.01\n4.30\n\n\n1\n4.9\n3.0\n1.4\n0.2\n24.01\n3.95\n\n\n2\n4.7\n3.2\n1.3\n0.2\n22.09\n3.95\n\n\n3\n4.6\n3.1\n1.5\n0.2\n21.16\n3.85\n\n\n4\n5.0\n3.6\n1.4\n0.2\n25.00\n4.30\n\n\n\n\n\n\n\nNote the use of the continuation operator \\ so we can write out code over multiple lines.\nNote also that the argument x to the lambda function stands for the given row to which it is being applied.\nlambda x: (x.sepal_length + x.sepal_width) / 2, axis=1\nIt’s as if we are iterating through the DataFrame rows and using the function in the body of the loop.\nIn fact, Pandas lets you do this with such methods as .iterrows() and .itertuples(), like so:\n\n[(x.sepal_length + x.sepal_width) / 2 for x in iris.itertuples()][:5]\n\n[4.3, 3.95, 3.95, 3.8499999999999996, 4.3]\n\n\nAnd, in this case, it’s faster.\n\n%timeit [(x.sepal_length + x.sepal_width) / 2 for x in iris.itertuples()]\n%timeit iris.apply(lambda x: (x.sepal_length + x.sepal_width) / 2, axis=1)\n\n367 µs ± 1.76 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n1.53 ms ± 1.86 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#using-vectorized-operations",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#using-vectorized-operations",
    "title": "Deeper Into Pandas",
    "section": "Using Vectorized Operations",
    "text": "Using Vectorized Operations\nWhenever possible, you should see if your .apply() method call can be replaced by a simple operation.\nThese are typically much faster.\nFor example, we could achieve the same results as the above use of .apply() to square a feature.\nHere are two ways to do this, along with the apply method for comparison:\n\n%timeit iris['sepal_len_sq_2'] = iris.sepal_length**2\n%timeit iris['sepal_len_sq_3'] = np.square(iris.sepal_length)\n\n106 µs ± 617 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n104 µs ± 538 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n\n\n\niris\n\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nsepal_len_sq\nsepal_len_wid_avg\nsepal_len_sq_2\nsepal_len_sq_3\n\n\nspecies\nobs_id\n\n\n\n\n\n\n\n\n\n\n\n\nsetosa\n0\n5.1\n3.5\n1.4\n0.2\n26.01\n4.30\n26.01\n26.01\n\n\n1\n4.9\n3.0\n1.4\n0.2\n24.01\n3.95\n24.01\n24.01\n\n\n2\n4.7\n3.2\n1.3\n0.2\n22.09\n3.95\n22.09\n22.09\n\n\n3\n4.6\n3.1\n1.5\n0.2\n21.16\n3.85\n21.16\n21.16\n\n\n4\n5.0\n3.6\n1.4\n0.2\n25.00\n4.30\n25.00\n25.00\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nvirginica\n145\n6.7\n3.0\n5.2\n2.3\n44.89\n4.85\n44.89\n44.89\n\n\n146\n6.3\n2.5\n5.0\n1.9\n39.69\n4.40\n39.69\n39.69\n\n\n147\n6.5\n3.0\n5.2\n2.0\n42.25\n4.75\n42.25\n42.25\n\n\n148\n6.2\n3.4\n5.4\n2.3\n38.44\n4.80\n38.44\n38.44\n\n\n149\n5.9\n3.0\n5.1\n1.8\n34.81\n4.45\n34.81\n34.81\n\n\n\n\n150 rows × 8 columns\n\n\n\nWe can see that both versions are faster than using .apply().\n\n%timeit iris['sepal_len_sq'] = iris.sepal_length.apply(lambda x: x**2)\n\n189 µs ± 252 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#aggregation-by-groups",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#aggregation-by-groups",
    "title": "Deeper Into Pandas",
    "section": "Aggregation by Groups",
    "text": "Aggregation by Groups\nPandas offers a powerful set of tools to apply aggregate statistical functions to subsets of data.\nThe pattern is as follows:\n\nGroup, or “split,” the data by the distinctive values in a column or set of columns.\nApply a statstic to each group.\nCombine the results in a table where each row stands for one of those unique values and the feature is the aggregate statistic.\n\nThis pattern is called split-apply-combine, which we will discuss more when we get to R.\n\n.groupby()\nThe DataFrame method we use for this pattern is .groupby().\nThis method takes one or more column names, including index columns, and divides the table into separate groups based the unique combinations of the values in these columns.\nThen a statistical method, such as .mean(), is called.\nHere we compute the mean of each feature grouped by species:\n\niris.groupby(\"species\").mean()\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nsepal_len_sq\nsepal_len_wid_avg\nsepal_len_sq_2\nsepal_len_sq_3\n\n\nspecies\n\n\n\n\n\n\n\n\n\n\n\n\nsetosa\n5.006\n3.428\n1.462\n0.246\n25.1818\n4.217\n25.1818\n25.1818\n\n\nversicolor\n5.936\n2.770\n4.260\n1.326\n35.4972\n4.353\n35.4972\n35.4972\n\n\nvirginica\n6.588\n2.974\n5.552\n2.026\n43.7980\n4.781\n43.7980\n43.7980\n\n\n\n\n\n\n\nWe can also pass function names to the .agg() method:\n\niris.groupby(\"species\").agg(['mean', 'median', 'sum', 'max', 'min']).T.head(10)\n\n\n\n\n\n\n\n\nspecies\nsetosa\nversicolor\nvirginica\n\n\n\n\nsepal_length\nmean\n5.006\n5.936\n6.588\n\n\nmedian\n5.000\n5.900\n6.500\n\n\nsum\n250.300\n296.800\n329.400\n\n\nmax\n5.800\n7.000\n7.900\n\n\nmin\n4.300\n4.900\n4.900\n\n\nsepal_width\nmean\n3.428\n2.770\n2.974\n\n\nmedian\n3.400\n2.800\n3.000\n\n\nsum\n171.400\n138.500\n148.700\n\n\nmax\n4.400\n3.400\n3.800\n\n\nmin\n2.300\n2.000\n2.200\n\n\n\n\n\n\n\n\n\npd.pivot_table()\nWe can also use the pivot table method and apply a function aggfunc to selected value, grouped by columns.\nHere we compute mean sepal length for each species:\n\npd.pivot_table(iris, values=\"sepal_length\", columns=[\"species\"], aggfunc = np.mean)\n\n\n\n\n\n\n\nspecies\nsetosa\nversicolor\nvirginica\n\n\n\n\nsepal_length\n5.006\n5.936\n6.588\n\n\n\n\n\n\n\nThat produces the same result as this:\n\niris[['sepal_length']].groupby(\"species\").mean().T\n\n\n\n\n\n\n\nspecies\nsetosa\nversicolor\nvirginica\n\n\n\n\nsepal_length\n5.006\n5.936\n6.588",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#stacking-and-unstacking",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#stacking-and-unstacking",
    "title": "Deeper Into Pandas",
    "section": "Stacking and Unstacking",
    "text": "Stacking and Unstacking\n\n.unstack()\nAnother way to achieve these results, but by taking advance of indexes, is unstacking.\nLet’s look at what unstack() does with another dataset from Seaborn’s collection.\n\nattention = sns.load_dataset('attention')\n\n\nattention.sample(10)\n\n\n\n\n\n\n\n\nUnnamed: 0\nsubject\nattention\nsolutions\nscore\n\n\n\n\n55\n55\n16\nfocused\n3\n7.0\n\n\n39\n39\n20\nfocused\n2\n6.0\n\n\n26\n26\n7\ndivided\n2\n4.5\n\n\n46\n46\n7\ndivided\n3\n6.0\n\n\n18\n18\n19\nfocused\n1\n5.0\n\n\n25\n25\n6\ndivided\n2\n5.0\n\n\n21\n21\n2\ndivided\n2\n4.0\n\n\n33\n33\n14\nfocused\n2\n8.0\n\n\n22\n22\n3\ndivided\n2\n5.0\n\n\n31\n31\n12\nfocused\n2\n9.0\n\n\n\n\n\n\n\nThis dataframe appears to record the results of an experiment on human attention.\nEach row is a trial or observation in that experiment.\nAn analysis of the columns in this dataframe show that\n\nscore is a measured outcome,\nsubjects are probably individuals in a comparative study where two groups,\nthose with attention divided and those with attention focused,\nare subject to three different solutions applied to the performance of some task.\nUnnamed: 0 is just the row number as index.\n\nThe purpose of the test performed in each trial seems to be see which solutions are best at overcoming divied attention in the performance of those tasks.\nLet’s restructure our data to reflect these assumptions.\n\nattention1 = attention.set_index(['attention','solutions','subject']).sort_index().drop('Unnamed: 0', axis=1)\nattention1.sample(10)\n\n\n\n\n\n\n\n\n\n\nscore\n\n\nattention\nsolutions\nsubject\n\n\n\n\n\nfocused\n1\n15\n8.0\n\n\n2\n11\n5.0\n\n\n16\n8.0\n\n\ndivided\n3\n3\n6.0\n\n\nfocused\n3\n17\n6.0\n\n\n12\n8.0\n\n\n16\n7.0\n\n\ndivided\n3\n4\n5.0\n\n\n1\n2\n3.0\n\n\nfocused\n2\n18\n8.0\n\n\n\n\n\n\n\nWe can use .unstack() to provide a nice, synoptic view of these data.\nThe operation takes the right-most index column and projects onto the column-axis.\nNote that it requires a MultiIndex of at least two index columns.\n\nattention2 = attention1.unstack()\nattention2.fillna('-')\n\n\n\n\n\n\n\n\n\nscore\n\n\n\nsubject\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nattention\nsolutions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndivided\n1\n2.0\n3.0\n3.0\n5.0\n4.0\n5.0\n5.0\n5.0\n2.0\n6.0\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\n2\n4.0\n4.0\n5.0\n7.0\n5.0\n5.0\n4.5\n7.0\n3.0\n5.0\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\n3\n7.0\n5.0\n6.0\n5.0\n8.0\n6.0\n6.0\n8.0\n7.0\n6.0\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\nfocused\n1\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n6.0\n8.0\n6.0\n8.0\n8.0\n6.0\n7.0\n7.0\n5.0\n6.0\n\n\n2\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n5.0\n9.0\n5.0\n8.0\n8.0\n8.0\n7.0\n8.0\n6.0\n6.0\n\n\n3\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n6.0\n8.0\n9.0\n7.0\n7.0\n7.0\n6.0\n6.0\n6.0\n5.0\n\n\n\n\n\n\n\nRight away we can see that participants were matched to attention mode.\nTo complete the pattern, we can apply .mean() to the unstacked DataFrame.\n\nATTENTION = attention2.mean(axis=1).to_frame('score')\nATTENTION\n\n\n\n\n\n\n\n\n\nscore\n\n\nattention\nsolutions\n\n\n\n\n\ndivided\n1\n4.00\n\n\n2\n4.95\n\n\n3\n6.40\n\n\nfocused\n1\n6.70\n\n\n2\n7.00\n\n\n3\n6.70\n\n\n\n\n\n\n\nWe can apply .unstack() again to show the results more compactly:\n\nATTENTION.unstack()\n\n\n\n\n\n\n\n\nscore\n\n\nsolutions\n1\n2\n3\n\n\nattention\n\n\n\n\n\n\n\ndivided\n4.0\n4.95\n6.4\n\n\nfocused\n6.7\n7.00\n6.7\n\n\n\n\n\n\n\nIt appears that solution 3 performed well in overcoming divided attention.\n\n\n.stack()\nStack is the opposite of .unstack(), of course.\nIt will project column labels onto the values of a single column.\nLet’s look at this with the taxis database.\n\ntaxis = sns.load_dataset('taxis')\ntaxis.head()\n\n\n\n\n\n\n\n\npickup\ndropoff\npassengers\ndistance\nfare\ntip\ntolls\ntotal\ncolor\npayment\npickup_zone\ndropoff_zone\npickup_borough\ndropoff_borough\n\n\n\n\n0\n2019-03-23 20:21:09\n2019-03-23 20:27:24\n1\n1.60\n7.0\n2.15\n0.0\n12.95\nyellow\ncredit card\nLenox Hill West\nUN/Turtle Bay South\nManhattan\nManhattan\n\n\n1\n2019-03-04 16:11:55\n2019-03-04 16:19:00\n1\n0.79\n5.0\n0.00\n0.0\n9.30\nyellow\ncash\nUpper West Side South\nUpper West Side South\nManhattan\nManhattan\n\n\n2\n2019-03-27 17:53:01\n2019-03-27 18:00:25\n1\n1.37\n7.5\n2.36\n0.0\n14.16\nyellow\ncredit card\nAlphabet City\nWest Village\nManhattan\nManhattan\n\n\n3\n2019-03-10 01:23:59\n2019-03-10 01:49:51\n1\n7.70\n27.0\n6.15\n0.0\n36.95\nyellow\ncredit card\nHudson Sq\nYorkville West\nManhattan\nManhattan\n\n\n4\n2019-03-30 13:27:42\n2019-03-30 13:37:14\n3\n2.16\n9.0\n1.10\n0.0\n13.40\nyellow\ncredit card\nMidtown East\nYorkville West\nManhattan\nManhattan\n\n\n\n\n\n\n\nLet’s define our indexes to reflect the structure of the data.\nWe define the index, sort it, and then use it to perform a stacking operation.\n\ntaxis1 = taxis.set_index(['pickup','dropoff']).sort_index().stack().to_frame('val')\ntaxis1.index.names = ['pickup','dropoff','field']\ntaxis1.sample(10)\n\n\n\n\n\n\n\n\n\n\nval\n\n\npickup\ndropoff\nfield\n\n\n\n\n\n2019-03-09 19:47:10\n2019-03-09 20:09:17\ndropoff_borough\nManhattan\n\n\n2019-03-20 23:19:55\n2019-03-20 23:46:00\ndistance\n4.82\n\n\n2019-03-03 07:48:48\n2019-03-03 07:53:53\ndistance\n1.57\n\n\n2019-03-04 08:30:51\n2019-03-04 08:40:54\npickup_zone\nUpper East Side South\n\n\n2019-03-16 11:39:52\n2019-03-16 11:50:36\ndistance\n1.8\n\n\n2019-03-03 04:11:09\n2019-03-03 04:17:14\ndistance\n0.8\n\n\n2019-03-18 16:03:14\n2019-03-18 16:10:36\npickup_borough\nManhattan\n\n\n2019-03-31 12:03:39\n2019-03-31 12:12:51\npickup_zone\nChinatown\n\n\n2019-03-12 16:00:34\n2019-03-12 16:06:28\npassengers\n1\n\n\n2019-03-05 21:39:03\n2019-03-05 21:49:12\npickup_zone\nClinton East\n\n\n\n\n\n\n\nHere is the data for one observation:\n\ntaxis1.loc['2019-02-28 23:29:03']\n\n\n\n\n\n\n\n\n\nval\n\n\ndropoff\nfield\n\n\n\n\n\n2019-02-28 23:32:35\npassengers\n1\n\n\ndistance\n0.9\n\n\nfare\n5.0\n\n\ntip\n0.0\n\n\ntolls\n0.0\n\n\ntotal\n6.3\n\n\ncolor\ngreen\n\n\npayment\ncash\n\n\npickup_zone\nOld Astoria\n\n\ndropoff_zone\nLong Island City/Queens Plaza\n\n\npickup_borough\nQueens\n\n\ndropoff_borough\nQueens",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#combining-dataframes",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#combining-dataframes",
    "title": "Deeper Into Pandas",
    "section": "Combining DataFrames",
    "text": "Combining DataFrames\nThere are at least \\(3\\) ways to combine DataFrame in Pandas: by concatening, merging, or joining.\n\npd.concat()\nTo concatenate to DataFrames, we use pd.concat().\nHere’s an example.\n\ndf1 = pd.DataFrame(np.random.randn(3, 4))\ndf2 = pd.DataFrame(np.random.randn(3, 4))\n\n\ndf1\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n0.361659\n0.802342\n-0.986953\n0.350928\n\n\n1\n0.258543\n-0.106647\n1.467904\n1.238903\n\n\n2\n2.896572\n0.739011\n0.705529\n-0.397988\n\n\n\n\n\n\n\n\ndf2\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n0.023824\n1.013029\n0.200236\n0.274996\n\n\n1\n2.256482\n0.982360\n0.933824\n0.774376\n\n\n2\n-0.203034\n1.013550\n-0.812464\n-2.777192\n\n\n\n\n\n\n\nThe Pandas function takes a list of DataFrames to combine, an optional keys argument to create a MultiIndex, and an axis parameter to choose between combining by rows or columns.\nTo combine by rows, set axis to \\(0\\).\n\ndf3 = pd.concat([df1, df2], keys=['a','b'], axis=0)\n\n\ndf3\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\na\n0\n0.361659\n0.802342\n-0.986953\n0.350928\n\n\n1\n0.258543\n-0.106647\n1.467904\n1.238903\n\n\n2\n2.896572\n0.739011\n0.705529\n-0.397988\n\n\nb\n0\n0.023824\n1.013029\n0.200236\n0.274996\n\n\n1\n2.256482\n0.982360\n0.933824\n0.774376\n\n\n2\n-0.203034\n1.013550\n-0.812464\n-2.777192\n\n\n\n\n\n\n\nWe set keys because indexes of the two source DataFrames are not unique.\nHere we use the key to get back the second DataFrame.\n\ndf3.loc['b']\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n0.023824\n1.013029\n0.200236\n0.274996\n\n\n1\n2.256482\n0.982360\n0.933824\n0.774376\n\n\n2\n-0.203034\n1.013550\n-0.812464\n-2.777192\n\n\n\n\n\n\n\nTo combine by columns, we set the axis to \\(1\\).\nThis assumes that the two DataFrames share an index, i.e. that the indexes represent the same events.\n\ndf4 = pd.concat([df1, df2], axis=1, keys=['a', 'b'])\n\n\ndf4\n\n\n\n\n\n\n\n\na\nb\n\n\n\n0\n1\n2\n3\n0\n1\n2\n3\n\n\n\n\n0\n0.361659\n0.802342\n-0.986953\n0.350928\n0.023824\n1.013029\n0.200236\n0.274996\n\n\n1\n0.258543\n-0.106647\n1.467904\n1.238903\n2.256482\n0.982360\n0.933824\n0.774376\n\n\n2\n2.896572\n0.739011\n0.705529\n-0.397988\n-0.203034\n1.013550\n-0.812464\n-2.777192\n\n\n\n\n\n\n\n\ndf4.b\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n0.023824\n1.013029\n0.200236\n0.274996\n\n\n1\n2.256482\n0.982360\n0.933824\n0.774376\n\n\n2\n-0.203034\n1.013550\n-0.812464\n-2.777192\n\n\n\n\n\n\n\n\n\n.merge()\nAnother way to combine DataFrames is with the Pandas function pd.marge().\nIt works similar to a SQL join.\nThis function takes two DataFrames as its first and second argument.\nThe on parameter specifies the columns on which to join.\nThe how parameter specifies the type of merge, i.e. left, right, outer, inner, or cross.\nHere we create two tables, left and right.\nWe then right join them on key.\nRight join means include all records from table on right.\nThe key is used for matching up the records.\n\nleft = pd.DataFrame({\"key\": [\"jamie\", \"bill\"], \"lval\": [15, 22]})\nright = pd.DataFrame({\"key\": [\"jamie\", \"bill\", \"asher\"], \"rval\": [4, 5, 8]})\n\n\nleft\n\n\n\n\n\n\n\n\nkey\nlval\n\n\n\n\n0\njamie\n15\n\n\n1\nbill\n22\n\n\n\n\n\n\n\n\nright\n\n\n\n\n\n\n\n\nkey\nrval\n\n\n\n\n0\njamie\n4\n\n\n1\nbill\n5\n\n\n2\nasher\n8\n\n\n\n\n\n\n\n\nmerged = pd.merge(left, right, on=\"key\", how=\"right\")\nmerged\n\n\n\n\n\n\n\n\nkey\nlval\nrval\n\n\n\n\n0\njamie\n15.0\n4\n\n\n1\nbill\n22.0\n5\n\n\n2\nasher\nNaN\n8\n\n\n\n\n\n\n\nNotice the NaN inserted into the record with key='asher', since the left table didn’t contain the key.\nIn this next example, the value columns have the same name: val. Notice what happens to the column names.\n\nleft = pd.DataFrame({\"key\": [\"jamie\", \"bill\"], \"val\": [15, 22]})\nright = pd.DataFrame({\"key\": [\"jamie\", \"bill\", \"asher\"], \"val\": [4, 5, 8]})\nmerged = pd.merge(left, right, on=\"key\", how=\"right\")\n\n\nleft\n\n\n\n\n\n\n\n\nkey\nval\n\n\n\n\n0\njamie\n15\n\n\n1\nbill\n22\n\n\n\n\n\n\n\n\nright\n\n\n\n\n\n\n\n\nkey\nval\n\n\n\n\n0\njamie\n4\n\n\n1\nbill\n5\n\n\n2\nasher\n8\n\n\n\n\n\n\n\n\nmerged\n\n\n\n\n\n\n\n\nkey\nval_x\nval_y\n\n\n\n\n0\njamie\n15.0\n4\n\n\n1\nbill\n22.0\n5\n\n\n2\nasher\nNaN\n8\n\n\n\n\n\n\n\n\n\n.join()\nAs the name implies, .join() is also SQL-like joiner, but it takes advantage of indexes.\nIt assumes the DataFrames to be joined share index values.\nHere we redefine our DataFrames with indexes.\n\nleft2 = left.set_index('key').copy()\nright2 = right.set_index('key').copy()\n\n\nleft2\n\n\n\n\n\n\n\n\nval\n\n\nkey\n\n\n\n\n\njamie\n15\n\n\nbill\n22\n\n\n\n\n\n\n\n\nright2\n\n\n\n\n\n\n\n\nval\n\n\nkey\n\n\n\n\n\njamie\n4\n\n\nbill\n5\n\n\nasher\n8\n\n\n\n\n\n\n\nNow we just use the method and Pandas assumes the indexes are shared.\nWe define a right suffix rsuffix to ensure the column names are unique.\n\nright2.join(left2, rsuffix='_r') \n\n\n\n\n\n\n\n\nval\nval_r\n\n\nkey\n\n\n\n\n\n\njamie\n4\n15.0\n\n\nbill\n5\n22.0\n\n\nasher\n8\nNaN\n\n\n\n\n\n\n\nThis is an inner join:\n\nright2.join(left2, how='inner', rsuffix='_r')\n\n\n\n\n\n\n\n\nval\nval_r\n\n\nkey\n\n\n\n\n\n\njamie\n4\n15\n\n\nbill\n5\n22",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#things-to-pay-attention-to",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#things-to-pay-attention-to",
    "title": "Deeper Into Pandas",
    "section": "Things to Pay Attention To",
    "text": "Things to Pay Attention To\nUse join if you have shared indexes.\nUse merge if you do not have shared indexes.\nUse concat to combine based on shared indexes or columns\nPay attention to resulting dataframe indexes and column names.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#categoricals",
    "href": "notebooks/M06_Pandas/M06-02-DeeperIntoPandas.html#categoricals",
    "title": "Deeper Into Pandas",
    "section": "Categoricals",
    "text": "Categoricals\nIt is often necessary to convert categorical data into numeric form.\nCategorical data are data in which the values are members of a set, such as the species names in the Iris data set.\nIn machine learning, we often want to project these onto the column axis where each row can only contain one True value.\n\npd.get_dummies()\nThis method will project a list of values in a column onto the column axis, using distinct values as the column names.\nThis is similar to .unstack(), except that the values for each of the new columns is boolean.\nThis is also called “one-hot encoding,” because only one feature can be “hot,” i.e. True, for each row.\nHere a some important parameters for the function:\n\nprefix : append prefix to column names (a good idea for later use)\ndrop_first: remove first level, as only k-1 variables needed to represent k levels\n\nLet’s look at example.\nHere we define a little DataFrame of cats, with a feature for breed.\n\ncats = pd.DataFrame({'breed':['persian', 'persian', 'siamese', 'himalayan', 'burmese']})\n\n\ncats\n\n\n\n\n\n\n\n\nbreed\n\n\n\n\n0\npersian\n\n\n1\npersian\n\n\n2\nsiamese\n\n\n3\nhimalayan\n\n\n4\nburmese\n\n\n\n\n\n\n\nTo convert to one-hot encoded form, we can do the following:\n\ndummy_cats = pd.get_dummies(cats.breed, prefix='breed')\ndummy_cats\n\n\n\n\n\n\n\n\nbreed_burmese\nbreed_himalayan\nbreed_persian\nbreed_siamese\n\n\n\n\n0\nFalse\nFalse\nTrue\nFalse\n\n\n1\nFalse\nFalse\nTrue\nFalse\n\n\n2\nFalse\nFalse\nFalse\nTrue\n\n\n3\nFalse\nTrue\nFalse\nFalse\n\n\n4\nTrue\nFalse\nFalse\nFalse\n\n\n\n\n\n\n\nWe can drop the first column, since it can be inferred.\nThis is done improve the efficiency of training a model.\n\npd.get_dummies(cats.breed, drop_first=True, prefix='breed')\n\n\n\n\n\n\n\n\nbreed_himalayan\nbreed_persian\nbreed_siamese\n\n\n\n\n0\nFalse\nTrue\nFalse\n\n\n1\nFalse\nTrue\nFalse\n\n\n2\nFalse\nFalse\nTrue\n\n\n3\nTrue\nFalse\nFalse\n\n\n4\nFalse\nFalse\nFalse\n\n\n\n\n\n\n\nNotice burmese was dropped (first level by alphabet) since it can be inferred.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Deeper Into Pandas</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-03-NarrowWide.html",
    "href": "notebooks/M06_Pandas/M06-03-NarrowWide.html",
    "title": "Narrow vs Wide Tables",
    "section": "",
    "text": "1 Hot Encoding\nProject values onto the column axis.\n# pd.get_dummies?\npd.get_dummies(WIDE.cat)\n\n\n\n\n\n\n\n\n19\n21\n23\n25\n28\n29\n\n\nowner\n\n\n\n\n\n\n\n\n\n\nA\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\n\n\nB\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\nC\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nD\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\n\n\nE\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nF\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nG\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\npd.get_dummies(NARROW.n)\n\n\n\n\n\n\n\n\n\n15\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n33\n\n\nowner\npet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA\ncat\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\ndog\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\n\n\nferret\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nB\ncat\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\ndog\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nferret\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nC\ncat\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\ndog\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nferret\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nD\ncat\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\ndog\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nferret\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nE\ncat\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\ndog\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nferret\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nF\ncat\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\ndog\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nferret\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nG\ncat\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\n\n\ndog\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nferret\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nparraot\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nsnake\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nturtle\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\npd.get_dummies(NARROW.n).sum().plot.bar();",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Narrow vs Wide Tables</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-04-MethodChaining.html",
    "href": "notebooks/M06_Pandas/M06-04-MethodChaining.html",
    "title": "Method Chaining",
    "section": "",
    "text": "Method chaining is supported by many objects in Python.\nThis allows you to “chain” a series of methods without having to defined temporary variables.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n\niris = sns.load_dataset('iris')\n\n\niris\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n...\n...\n...\n...\n...\n...\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n150 rows × 5 columns\n\n\n\n\niris.index.name = 'iris_id'\n\n\niris\n\n\n\n\n\n\n\n\nsepal_length\nsepal_width\npetal_length\npetal_width\nspecies\n\n\niris_id\n\n\n\n\n\n\n\n\n\n0\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n1\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n2\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n3\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n4\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n...\n...\n...\n...\n...\n...\n\n\n145\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n146\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n147\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n148\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n149\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n150 rows × 5 columns\n\n\n\n\niris = iris.reset_index()\\\n    .set_index(['species', 'iris_id'])\n\n\niris\n\n\n\n\n\n\n\n\n\nlevel_0\nindex\nsepal_length\nsepal_width\npetal_length\npetal_width\n\n\nspecies\niris_id\n\n\n\n\n\n\n\n\n\n\nsetosa\n0\n0\n0\n5.1\n3.5\n1.4\n0.2\n\n\n1\n1\n1\n4.9\n3.0\n1.4\n0.2\n\n\n2\n2\n2\n4.7\n3.2\n1.3\n0.2\n\n\n3\n3\n3\n4.6\n3.1\n1.5\n0.2\n\n\n4\n4\n4\n5.0\n3.6\n1.4\n0.2\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nvirginica\n145\n145\n145\n6.7\n3.0\n5.2\n2.3\n\n\n146\n146\n146\n6.3\n2.5\n5.0\n1.9\n\n\n147\n147\n147\n6.5\n3.0\n5.2\n2.0\n\n\n148\n148\n148\n6.2\n3.4\n5.4\n2.3\n\n\n149\n149\n149\n5.9\n3.0\n5.1\n1.8\n\n\n\n\n150 rows × 6 columns\n\n\n\n\niris.groupby('species').mean('mean').plot.barh();\n\n\n\n\n\n\n\n\n\niris.groupby('species').agg('mean').T.setosa.plot.barh();\n\n\n\n\n\n\n\n\n\niris.groupby(['sepal_length','sepal_width']).petal_length\\\n    .mean()\\\n    .to_frame('mean petal_length')\\\n    .plot(style='.', rot=45);",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Method Chaining</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html",
    "href": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html",
    "title": "Pandas and SQL",
    "section": "",
    "text": "Overview\nIn this exercise, we split the raw table into tables corresponding the implied subjects we discovered.\nThen we use joins to reassemble the data.\nWe will assumed that the implied subjects are ARTIST, GENRE, ALBUM, and REVIEW.\nTo do this, we use Pandas to store the initial table as a dataframe, and then we create variations of that dataframe and save those to the database as new tables.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pandas and SQL</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-artist-table",
    "href": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-artist-table",
    "title": "Pandas and SQL",
    "section": "The artist table",
    "text": "The artist table\nWe get the unique artist names and save them to a new dataframe, and change the column name and the index name in the process so that we have well-named columns in our table.\n\nartists = raw.artist.value_counts().to_frame('n_reviews')\nartists.index.name = 'artist_id'\nartists.to_sql('artist', db, index=True, if_exists='replace', index_label='artist_id')\n\n9249\n\n\n\nartists.sample(10)\n\n\n\n\n\n\n\n\nn_reviews\n\n\nartist_id\n\n\n\n\n\nFlying Canyon\n1\n\n\nFlorence and the Machine\n4\n\n\nLarkin Grimm\n3\n\n\nDylan LeBlanc\n2\n\n\nDevo\n2\n\n\nTory Lanez\n3\n\n\nSacred Paws\n1\n\n\nLittle Wings\n4\n\n\nBoris / Ian Astbury\n1\n\n\nThe Sight Below\n2\n\n\n\n\n\n\n\nHow many albums does Wilco have?\n\nartists.loc['Wilco'].n_reviews\n\n14\n\n\n\nPattern\n\nImport the columns that you want from raw table into a new dataframe. value_counts() is your friend.\nRename columns and index as desired.\nPut the new dataframe into the database as a new table. No need to define the schema!",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pandas and SQL</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-genre-table",
    "href": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-genre-table",
    "title": "Pandas and SQL",
    "section": "The genre table",
    "text": "The genre table\n\ngenres = raw.genre.value_counts().to_frame('n_reviews')\ngenres.index.name = 'genre_id'\ngenres.to_sql('genre', db, index=True, if_exists='replace', index_label='genre_id')\n\n10\n\n\n\ngenres\n\n\n\n\n\n\n\n\nn_reviews\n\n\ngenre_id\n\n\n\n\n\nRock\n6954\n\n\nElectronic\n4020\n\n\nNone\n2320\n\n\nExperimental\n1696\n\n\nRap\n1481\n\n\nPop/R&B\n1157\n\n\nMetal\n781\n\n\nFolk/Country\n700\n\n\nJazz\n257\n\n\nGlobal\n178\n\n\n\n\n\n\n\n\ngenres.plot.barh();",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pandas and SQL</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-album-table",
    "href": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-album-table",
    "title": "Pandas and SQL",
    "section": "The album table",
    "text": "The album table\n\nalbums = raw[['album','artist','genre']].value_counts().to_frame('n_reviews').reset_index().set_index(['artist','album'])\nalbums.index.names = ['artist_id','album_id']\nalbums = albums.rename(columns={'genre':'genre_id'})\nalbums.to_sql('album', db, index=True, if_exists='replace', index_label=albums.index.names)\n\n19506\n\n\n\nalbums\n\n\n\n\n\n\n\n\n\ngenre_id\nn_reviews\n\n\nartist_id\nalbum_id\n\n\n\n\n\n\nNÙze\nSongs on the Rocks\nNone\n2\n\n\nThe Postal Service\nGive Up\nElectronic\n2\n\n\nEnon\nBelievo!\nRock\n2\n\n\nTim Hecker\nRadio Amor\nExperimental\n2\n\n\nOf Montreal\nIf He Is Protecting Our Nation, Then Who Will Protect Big Oil, Our Children?\nRock\n2\n\n\n...\n...\n...\n...\n\n\nRussian Circles\nGuidance\nMetal\n1\n\n\nVarious Artists\nGuess Who This Is: A Tribute to Dom Leone\nNone\n1\n\n\nBeck\nGuerolito\nRock\n1\n\n\nGuero\nRock\n1\n\n\nPretty Girls Make Graves\n…lan Vital\nNone\n1\n\n\n\n\n19506 rows × 2 columns",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pandas and SQL</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-review-table",
    "href": "notebooks/M06_Pandas/M06-05-Pandas-and-SQL.html#the-review-table",
    "title": "Pandas and SQL",
    "section": "The review table",
    "text": "The review table\n\nreviews = raw[['album', 'artist', 'best', 'date', 'review', 'score']].copy()\nreviews.columns = ['album_id', 'artist_id', 'is_best', 'review_date', 'review_content', 'album_score']\nreviews = reviews.set_index(['artist_id','album_id','review_date'])\nreviews.to_sql('review', db, index=True, if_exists='replace', index_label=reviews.index.names)\n\n19544\n\n\n\nreviews.head()\n\n\n\n\n\n\n\n\n\n\nis_best\nreview_content\nalbum_score\n\n\nartist_id\nalbum_id\nreview_date\n\n\n\n\n\n\n\nWilco\nA.M./Being There\nDecember 6 2017\n1\nBest new reissue 1 / 2 Albums Newly reissued a...\n7.0\n\n\nHopsin\nNo Shame\nDecember 6 2017\n0\nOn his corrosive fifth album, the rapper takes...\n3.5\n\n\nGlassjaw\nMaterial Control\nDecember 6 2017\n0\nOn their first album in 15 years, the Long Isl...\n6.6\n\n\nNabihah Iqbal\nWeighing of the Heart\nDecember 6 2017\n0\nOn her debut LP, British producer Nabihah Iqba...\n7.7\n\n\nNeil Young / Promise of the Real\nThe Visitor\nDecember 5 2017\n0\nWhile still pointedly political, Neil Youngís ...\n6.7\n\n\n\n\n\n\n\n\nreviews.loc['Wilco'].sort_index()\n\n\n\n\n\n\n\n\n\nis_best\nreview_content\nalbum_score\n\n\nalbum_id\nreview_date\n\n\n\n\n\n\n\nA Ghost Is Born\nJune 21 2004\n0\nAt the time of Yankee Hotel Foxtrot's non-trad...\n6.6\n\n\nA.M./Being There\nDecember 6 2017\n1\nBest new reissue 1 / 2 Albums Newly reissued a...\n7.0\n\n\nAlpha Mike Foxtrot: Rare Tracks 1994ñ2014/What's Your 20? Essential Tracks 1994ñ2014\nNovember 19 2014\n0\n1 / 2 Albums Both the†Alpha Mike Foxtrot†rarit...\n7.0\n\n\nKicking Television: Live in Chicago\nNovember 13 2005\n0\nThis 2xCD live album finds the now six-piece b...\n8.3\n\n\nMore Like the Moon EP\nApril 27 2003\n0\nOkay, show of hands: how many of you people ha...\n7.0\n\n\nSchmilco\nSeptember 9 2016\n0\nWilco's 10th album is a largely acoustic affai...\n7.0\n\n\nSky Blue Sky\nMay 14 2007\n0\nDespite the experimental pedigree of their new...\n5.2\n\n\nStar Wars\nJuly 23 2015\n0\nWith its $0 asking price, lawsuit-baiting titl...\n7.7\n\n\nSummerteeth\nFebruary 28 1999\n0\nAfter parting ways with Uncle Tupelo partner J...\n9.4\n\n\nThe Whole Love\nSeptember 26 2011\n0\nWilco's adventurous, self-produced eighth LP f...\n6.9\n\n\nThe Wilco Book\nOctober 31 2004\n0\nWe don't usually review books, but seeing that...\n7.5\n\n\nWilco (The Album)\nJune 29 2009\n0\nJeff Tweedy and co.'s latest does what its tit...\n7.3\n\n\nYankee Hotel Foxtrot\nApril 21 2002\n0\nMyth, it has been said, is the buried part of ...\n10.0\n\n\niTunes Session\nFebruary 2 2012\n0\nThis eight-song EP, comprised primarily of tra...\n6.7\n\n\n\n\n\n\n\n\nreviews.loc['Wilco'].album_score.mean().round(2)\n\n7.4\n\n\nNote how the new review table has fewer columns – e.g. we no longer have genre.",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Pandas and SQL</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html",
    "title": "Introducing R",
    "section": "",
    "text": "What is R?\nR is an open source programming language developed in the 1990s by and for statisticians.\nIt was based on the earlier langauge S, first developed at Bell Labs in the mid-1970s, also by and for statisticians.\nIt is a purpose-built language designed to provide a relatively low-code scripting language to explore, visualize, and model data.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#why-study-r",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#why-study-r",
    "title": "Introducing R",
    "section": "Why Study R?",
    "text": "Why Study R?\nR is in many ways the original data science programming language.\nPython borrows many concepts from R, including the data frame.\nThe R community provides insights into data processing through excellent documentation and well-designed code.\nAlthough not as popular as it once was, it is still widely used — you may find yourself on a team that prefers it.\nMany courses in the UVA SDS programs use R.\nIt’s not that hard, especially once you know basic programming concepts.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#rs-design",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#rs-design",
    "title": "Introducing R",
    "section": "R’s Design",
    "text": "R’s Design\nR was designed to support statistical computing above all.\nIn constrast to Python, it is not a general purpose language, although it may be used for many things.\nIt has a very strong academic community which is reflected in its high quality documentation, the variety of its scientific libraries, and in its well-organized resources.\nIt has many statistical functions built into it, i.e. to get started with statistical computing you don’t need to import anything.\nIt is based on what we might call vector-first thinking.\nAs with Python, everything is an object.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#r-syntax",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#r-syntax",
    "title": "Introducing R",
    "section": "R Syntax",
    "text": "R Syntax\nSyntax loosely follows traditional C-style syntax.\nIt uses braces { and } to form code blocks.\nIt uses semi-colons to end statements (optionally) or separate them if on same line.\nNotably, assignments are made with &lt;- or -&gt; operators.\nDots . have no special meaning — they are not operators.\nIn effect, they are used like underscores _ in Python.\nSingle and double quotes have the same meaning, but double quotes tend to be preferred.\nUse single quotes if you expect your string to contain double quotes.\nBackslash escape applies to R strings, although since there are no raw strings — Python’s r\" \" — we often have to supply double backslashes in regular expressions.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#using-r",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#using-r",
    "title": "Introducing R",
    "section": "Using R",
    "text": "Using R\nAlthough there are many ways to run R programs, by far the most common is to use R Studio.\nR Studio provides a fully-functional programming environment that includes an editor, a command-line, access to the file system, a help system, an installation system, etc.\nYou may use other programs run R too, though, such as VSCode and Jupyter.\nIn practice, however, RStudio is almost universally used.\nR programs can be plain text files with an .r suffix, R Markdown files (.Rmd), or many other kinds of file.\nWe will discuss these in a later module.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#command-line-r",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#command-line-r",
    "title": "Introducing R",
    "section": "Command Line R",
    "text": "Command Line R\nR can also be run from the command line.\nR is invoked by calling R:\n&gt; R\nIf properly installed, that should produce a message like this:\nR version 4.3.1 (2023-06-16) – “Beagle Scouts” Copyright (C) 2023 The R Foundation for Statistical Computing Platform: x86_64-conda-linux-gnu (64-bit)\nR is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type ‘license()’ or ‘licence()’ for distribution details.\nNatural language support but running in an English locale\nR is a collaborative project with many contributors. Type ‘contributors()’ for more information and ‘citation()’ on how to cite R or R packages in publications.\nType ‘demo()’ for some demos, ‘help()’ for on-line help, or ‘help.start()’ for an HTML browser interface to help. Type ‘q()’ to quit R.\n[Previously saved workspace restored]",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#installing-and-loading-packages",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#installing-and-loading-packages",
    "title": "Introducing R",
    "section": "Installing and Loading Packages",
    "text": "Installing and Loading Packages\nAs with Python, R allows you to install and import packages to extend the program’s capabilities.\nPackages can be installed from within a program as follows:\n\n# install.packages(\"tm\")\n\nHere installed the Text Mining tm package.\nYou only have to install a package once.\nYou can also install packages using R Studio’s Package window or from the command line.\nOnce they are installed, you import them with the library() function:\n\nlibrary(tm)\n\nNote that the library name is quoted in when installing, but not when using library.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-01-Intro.html#using-r-in-jupyter",
    "href": "notebooks/M10_RBasics/M10-01-Intro.html#using-r-in-jupyter",
    "title": "Introducing R",
    "section": "Using R in Jupyter",
    "text": "Using R in Jupyter\nIf you want to use R within a Jupyter notebook file, you can create and load an R kernel using Anaconda’s package manager conda. In brief, here’s what you do.\nFirst, at the command line:\nconda create -n r_env r-essentials r-base\nconda activate r_env\nR # This opens the R shell\nThen, in the R shell:\nIRkernel::installspec(name = 'r_env', displayname = 'R Environment')\nquit()\nNow, fire up a Jupyter Lab or Jupyter Notebook instance from the OpenOnDemand page and select the kernel when you create a new notebook.\nNote that the name r_env can be replaced by whatever you want.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Introducing R</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html",
    "title": "R Data Types and Operators",
    "section": "",
    "text": "Numeric\nFloating point numbers are called “numerics” in R.\nIt is the default data type.\nIf we assign a decimal value to a variable x, x will be of numeric type:\nx &lt;- 10.5      \nx              \n\n10.5\nWe can learn the type of data stored by a variable with the class() function.\nclass(x)      \n\n'numeric'\nEven if we assign an integer to a variable k, it is will still be saved as a numeric value.\nk &lt;- 1\nk              \n\n1\nclass(k)       \n\n'numeric'\nThat k is not an integer can be confirmed with is.integer():\nis.integer(k)  \n\nFALSE",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#integers",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#integers",
    "title": "R Data Types and Operators",
    "section": "Integers",
    "text": "Integers\nTo create an integer variable in R, we use as.integer().\n\ny &lt;- as.integer(3) \ny              \n\n3\n\n\n\nclass(y)       \nis.integer(y)  \n\n'integer'\n\n\nTRUE\n\n\nWe can also declare an integer by appending an L suffix.\n\ny &lt;- 3L \n\nTo see if a variable is an integer, you can use is.integer():\n\nis.integer(y) \n\nTRUE\n\n\nWe can also coerce, or cast, a numeric value into an integer with as.integer().\n\nas.integer(3.14)    \n\n3\n\n\nAnd we can parse a string for decimal values in much the same way.\n\nas.integer(\"5.27\")  \n\n5\n\n\nOn the other hand, you can’t parse a non-decimal string.\n\nas.integer(\"Joe\")   \n\nWarning message in eval(expr, envir, enclos):\n“NAs introduced by coercion”\n\n\n&lt;NA&gt;\n\n\nWe can convert booleans to numbers this way, too.\n\nas.integer(TRUE)    \nas.integer(FALSE)   \n\n1\n\n\n0",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#math-operators",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#math-operators",
    "title": "R Data Types and Operators",
    "section": "Math Operators",
    "text": "Math Operators\nNumerics and integers are subject to the standard array of arithmetic operations.\n\n\n\nOperator\nDescription\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^ or **\nexponentiation\n\n\nx %% y\nmodulus (x mod y) 5%%2 is 1\n\n\nx %/% y\ninteger division 5%/%2 is 2",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#logical-boolean",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#logical-boolean",
    "title": "R Data Types and Operators",
    "section": "Logical (Boolean)",
    "text": "Logical (Boolean)\nBoolean data are called “logical” in R.\nThey take the values TRUE and FALSE, or T and F for short.\nA logical value is often produced from the comparison between values.\n\nx &lt;- 1\ny &lt;- 2      \nz &lt;- x &gt; y  \nz           \n\nFALSE\n\n\n\nclass(z) \n\n'logical'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#logical-operators",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#logical-operators",
    "title": "R Data Types and Operators",
    "section": "Logical Operators",
    "text": "Logical Operators\nR supports the standard logical operations: & stands for “and”, | for stands for “or”, and ! stands for negation.\n\nu &lt;- TRUE\nv &lt;- FALSE\nu & v\n\nFALSE\n\n\n\nu | v\n\nTRUE\n\n\n\n!u\n\nFALSE\n\n\nAgain, you may use T and F instead of TRUE and FALSE.\n\na &lt;- T\nb &lt;- F\na & b\n\nFALSE",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#characters",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#characters",
    "title": "R Data Types and Operators",
    "section": "Characters",
    "text": "Characters\nStrings are called “character” objects in R.\nThis may be confusing if you are coming from a language, such as Java, where “character” means an individual character, such as A.\nWe may convert non-character objects into characters with the as.character() function:\n\nx &lt;- as.character(3.14) \nx\n\n'3.14'\n\n\n\nclass(x)       # print the class name of x \n\n'character'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#paste",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#paste",
    "title": "R Data Types and Operators",
    "section": "paste()",
    "text": "paste()\nTwo character values can be concatenated with the paste() function.\n\nfname &lt;- \"Joe\"\nlname &lt;- \"Smith\" \npaste(fname, lname) \n\n'Joe Smith'\n\n\npaste() takes a sep argument:\n\npaste(\"A\", \"B\", \"C\", sep=\"--\")\n\n'A--B--C'\n\n\nNote that R does not overload the + operator.\n\nfname + lname\n\nERROR: Error in fname + lname: non-numeric argument to binary operator\n\nError in fname + lname: non-numeric argument to binary operator\nTraceback:",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#sprintf",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#sprintf",
    "title": "R Data Types and Operators",
    "section": "sprintf()",
    "text": "sprintf()\nIt is often convenient to create a readable string with the sprintf() function, which has a C language syntax.\n\nsprintf(\"%s has %d dollars\", \"Sam\", 100) \n\n'Sam has 100 dollars'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#substr",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#substr",
    "title": "R Data Types and Operators",
    "section": "substr()",
    "text": "substr()\nTo extract a substring, we apply the substr() function.\nHere is an example showing how to extract the substring between the third and twelfth positions in a string.\n\nsubstr(\"Mary has a little lamb.\", start=3, stop=12) \n\n'ry has a l'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-02-DataTypes.html#sub",
    "href": "notebooks/M10_RBasics/M10-02-DataTypes.html#sub",
    "title": "R Data Types and Operators",
    "section": "sub()",
    "text": "sub()\nAnd to replace the first occurrence of the word “little” by another word “big” in the string, we apply the sub() function.\nThis function can use regular expressions.\n\nsub(\"little\", \"big\", \"Mary has a little lamb.\") \n\n'Mary has a big lamb.'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>R Data Types and Operators</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html",
    "title": "R Data Structures",
    "section": "",
    "text": "Vector\nA vector is an ordered collection of elements where each elements contains the same data type (integers or characters or reals or whatever).\nVectors are immutable.\nVectors are indexed beginning with the number \\(1\\).\n\\(1\\)-based indexing is used throughout R.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#matrix",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#matrix",
    "title": "R Data Structures",
    "section": "Matrix",
    "text": "Matrix\nA matrix is just a two-dimensional vector.\nIt too has one data type and is immutable.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#array",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#array",
    "title": "R Data Structures",
    "section": "Array",
    "text": "Array\nAn array in R is a generalization of the vector and matrix. It may have one or more dimensions.\nSo, an array with one dimension is almost the same as a vector.\nAn array with two dimensions is almost the same as a matrix.\nAn array with three or more dimensions is an n-dimensional array.\nThey are like NumPy arrays in Python.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#list",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#list",
    "title": "R Data Structures",
    "section": "List",
    "text": "List\nA list can hold items of different types and the list size can be increased on the fly.\nList contents can be accessed either by index (like mylist[[1]]) or by name (like mylist$age).\nLists are like lists in Python.\nA data frame is called a table in many languages.\nThis is the workhorse of R.\nEach column holds the same type, and the columns can have header names.\nA data frame is essential a kind of a list — a list of vectors each with the same length, but of varying data types.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#summary",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#summary",
    "title": "R Data Structures",
    "section": "Summary",
    "text": "Summary\n\n\n\nStructure\nDim\nData Type\nShape\nPython\n\n\n\n\nVector\n\\(1\\)\nsingle\n—\n—\n\n\nMatrix\n\\(2\\)\nsingle\nuniform\n—\n\n\nArray\n\\(N\\)\nsingle\nuniform\nNumPy array\n\n\nList\n\\(1\\)\nmultiple\nragged\nList, Dict\n\n\nData Frame\n\\(2\\)\nmultiple\nuniform\nPandas Data Frame\n\n\n\nThese reflect the evolution of R.\nWe mainly use Vectors and Data Frames.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#sequences",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#sequences",
    "title": "R Data Structures",
    "section": "Sequences",
    "text": "Sequences\nVectors may be created from sequences using :, seq(), and rep()\nVectors can be made out of sequences which may be generated in a few ways.\n\ns1 &lt;- 2:5\ns1\n\n\n2345\n\n\nThe seq() function is like Python’s range().\n\ns2 &lt;- seq(from=1, to=5, by=2)\ns2\n\n\n135\n\n\nYou can drop the argument names and write seq(1,5,2).\nThe rep() function will create a series of repeated values:\n\ns3 &lt;- rep(1, 5)\ns3\n\n\n11111",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#length",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#length",
    "title": "R Data Structures",
    "section": "length()",
    "text": "length()\nThe number of members in a vector is given by the length() function.\n\nlength(c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\")) \n\n5",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#combining-vectors",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#combining-vectors",
    "title": "R Data Structures",
    "section": "Combining Vectors",
    "text": "Combining Vectors\nVectors can be combined via the function c().\n\nn &lt;- c(2, 3, 5) \ns &lt;- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \n c(n, s) \n\n\n'2''3''5''aa''bb''cc''dd''ee'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#value-coercion",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#value-coercion",
    "title": "R Data Structures",
    "section": "Value Coercion",
    "text": "Value Coercion\nNotice how the numeric values are being coerced into character strings when the two vectors are combined.\nThis is necessary so as to maintain the same primitive data type for members in the same vector.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#vector-math",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#vector-math",
    "title": "R Data Structures",
    "section": "Vector Math",
    "text": "Vector Math\nArithmetic operations of vectors are performed member-by-member, i.e., member-wise.\nWe called this ‘element-wise’ in the context of NumPy.\nFor example, suppose we have two vectors a and b.\n\na &lt;- c(1, 3, 5, 7) \nb &lt;- c(1, 2, 4, 8)\n\nIf we multiply a by 5, we would get a vector with each of its members multiplied by 5.\n\n5 * a \n\n\n5152535\n\n\nAnd if we add a and b together, the sum would be a vector whose members are the sum of the corresponding members from a and b.\n\na + b\n\n\n25915\n\n\nSimilarly for subtraction, multiplication and division, we get new vectors via member-wise operations.\n\na - b \n\n\n011-1\n\n\n\na * b \n\n\n162056\n\n\n\na / b \n\n\n11.51.250.875",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#the-recycling-rule",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#the-recycling-rule",
    "title": "R Data Structures",
    "section": "The Recycling Rule",
    "text": "The Recycling Rule\nIf two vectors in an operation are of unequal length, the shorter one will be recycled in order to match the longer vector.\nThis is similar to broadcasting in NumPy and Pandas.\nFor example, the following vectors u and v have different lengths, and their sum is computed by recycling values of the shorter vector u.\n\nu &lt;- c(10, 20, 30) \nv &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) \nu + v \n\n\n112233142536172839",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#vector-indexes",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#vector-indexes",
    "title": "R Data Structures",
    "section": "Vector Indexes",
    "text": "Vector Indexes\nWe retrieve values in a vector by declaring an index inside a single square bracket index [] operator.\nVector indexes are \\(1\\)-based.\n\ns &lt;- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \ns[3] \n\n'cc'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#negative-indexing",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#negative-indexing",
    "title": "R Data Structures",
    "section": "Negative Indexing",
    "text": "Negative Indexing\nUnlike Python, if the index is negative, it will remove the member whose position has the same absolute value as the negative index.\nIt really does mean subtraction!\nFor example, the following creates a vector slice with the third member removed.\n\ns[-3] \n\n\n'aa''bb''dd''ee'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#out-of-range-indexes",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#out-of-range-indexes",
    "title": "R Data Structures",
    "section": "Out-of-Range Indexes",
    "text": "Out-of-Range Indexes\nValues for out-of-range indexes are reported as NA.\n\ns[10] \n\nNA",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#numeric-index-vectors",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#numeric-index-vectors",
    "title": "R Data Structures",
    "section": "Numeric Index Vectors",
    "text": "Numeric Index Vectors\nA new vector can be sliced from a given vector with a numeric vector passed to the indexing operator.\nIndex vectors consist of member positions of the original vector to be retrieved.\nHere we see how to retrieve a vector slice containing the second and third members of a given vector s.\n\ns &lt;- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\") \ns[c(2, 3)] \n\n\n'bb''cc'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#duplicate-indexes",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#duplicate-indexes",
    "title": "R Data Structures",
    "section": "Duplicate Indexes",
    "text": "Duplicate Indexes\nThe index vector allows duplicate values. Hence the following retrieves a member twice in one operation.\n\ns[c(2, 3, 3)] \n\n\n'bb''cc''cc'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#out-of-order-indexes",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#out-of-order-indexes",
    "title": "R Data Structures",
    "section": "Out-of-Order Indexes",
    "text": "Out-of-Order Indexes\nThe index vector can even be out-of-order. Here is a vector slice with the order of first and second members reversed.\n\ns[c(2, 1, 3)] \n\n\n'bb''aa''cc'\n\n\nIn Python, we called this “fancy indexing.”",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#range-index",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#range-index",
    "title": "R Data Structures",
    "section": "Range Index",
    "text": "Range Index\nTo produce a vector slice between two indexes, we can use the colon sequence operator :.\nThis can be convenient for situations involving large vectors.\n\ns[2:4] \n\n\n'bb''cc''dd'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#logical-index-vectors",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#logical-index-vectors",
    "title": "R Data Structures",
    "section": "Logical Index Vectors",
    "text": "Logical Index Vectors\nA new vector can be sliced from a given vector with a logical index vector.\nThe logical vector must the same length as the original vector.\nIts members are TRUE if the corresponding members in the original vector are to be included in the slice, and FALSE if otherwise.\nThis is what we called boolean indexing and masking in Python.\nFor example, consider the following vector s of length \\(5\\).\n\ns &lt;- c(\"aa\", \"bb\", \"cc\", \"dd\", \"ee\")\n\nTo retrieve the the second and fourth members of s, we define a logical vector L of the same length, and have its second and fourth members set as TRUE.\n\nL = c(FALSE, TRUE, FALSE, TRUE, FALSE)\ns[L] \n\n\n'bb''dd'\n\n\nThe code can be abbreviated into a single line.\n\ns[c(FALSE, TRUE, FALSE, TRUE, FALSE)]\n\n\n'bb''dd'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#naming-vector-members-with-names",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#naming-vector-members-with-names",
    "title": "R Data Structures",
    "section": "Naming Vector Members with names()",
    "text": "Naming Vector Members with names()\nWe can assign names to vector members, too.\n\nv &lt;- c(\"Mary\", \"Sue\") \nnames(v) &lt;- c(\"First\", \"Last\") \nv\n\nFirst'Mary'Last'Sue'\n\n\nNow we can retrieve the first member by name, much like a Python dictionary.\n\nv[\"First\"]\n\nFirst: 'Mary'\n\n\nWe can also reverse the order with a character string index vector.\n\nv[c(\"Last\", \"First\")]\n\nLast'Sue'First'Mary'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#list-slicing",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#list-slicing",
    "title": "R Data Structures",
    "section": "List Slicing",
    "text": "List Slicing\nWe retrieve a list slice with the single square bracket [] operator.\nThe following is a slice containing the second member of x, which is a copy of s.\n\nx[2]\n\n\n    \n'aa''bb''cc''dd''ee'\n\n\n\n\nWith a vector, we can retrieve a slice with multiple members.\nHere a slice containing the second and fourth members of x.\n\nx[c(2, 4)]\n\n\n    \n'aa''bb''cc''dd''ee'\n\n    3",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-03-DataStructures.html#member-reference-with",
    "href": "notebooks/M10_RBasics/M10-03-DataStructures.html#member-reference-with",
    "title": "R Data Structures",
    "section": "Member Reference with [[]]",
    "text": "Member Reference with [[]]\nTo reference a list member directly, we use the double square bracket [[]] operator.\nThe following object x[[2]] is the second member of x.\nIn other words, *x[[2]] is a true copy of s, not a slice containing s or its copy.\n\nprint(x[2])\n\n[[1]]\n[1] \"aa\" \"bb\" \"cc\" \"dd\" \"ee\"\n\n\n\n\nprint(x[[2]])\n\n[1] \"aa\" \"bb\" \"cc\" \"dd\" \"ee\"\n\n\nWe can modify its content directly.\n\nx[[2]][1] &lt;- \"ta\" \n\n\nprint(x[2])\n\n[[1]]\n[1] \"ta\" \"bb\" \"cc\" \"dd\" \"ee\"\n\n\n\nAnd s is unaffected.\n\nprint(s)\n\n[1] \"aa\" \"bb\" \"cc\" \"dd\" \"ee\"\n\n\nNote that this notation is opposite to Python’s syntax in NumPy and Pandas.\nIn Python, a double bracket containing a single value passed to a DataFrame would return a DataFrame, whereas a single bracket would return a Series.\nThis is because the double bracket means a list is being used to select data, whereas a single bracket means a scalar is being used.\ndf[[x]] # Returns a one column DataFrame\ndf[x]   # Returns a Series",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Data Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html",
    "title": "R Data Frames",
    "section": "",
    "text": "Data Frames\nA data frame is used for storing data tables.\nIt is essentially a list of vectors of equal length.\nFor example, the following variable df is a data frame containing three vectors n, s, b.\nn &lt;- c(2, 3, 5) \ns &lt;- c(\"aa\", \"bb\", \"cc\") \nb &lt;- c(TRUE, FALSE, TRUE) \ndf &lt;- data.frame(n, s, b)\ndf\n\n\nA data.frame: 3 × 3\n\n\nn\ns\nb\n\n\n&lt;dbl&gt;\n&lt;chr&gt;\n&lt;lgl&gt;\n\n\n\n\n2\naa\nTRUE\n\n\n3\nbb\nFALSE\n\n\n5\ncc\nTRUE\nNotice that data frames are built column-wise.\nWhen displayed in certain environemnts, the top line of the data frame is the header and it contains the column names.\nThe data type is listed below the column name.\nEach horizontal line afterward denotes a data row, which may begin with the name of the row, and then followed by the actual data.\nEach data member of a row is called a cell.\nNote that on Jupyter, if we print a data frame, we get this:\nprint(df)\n\n  n  s     b\n1 2 aa  TRUE\n2 3 bb FALSE\n3 5 cc  TRUE",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#built-in-data-frames",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#built-in-data-frames",
    "title": "R Data Frames",
    "section": "Built-in Data Frames",
    "text": "Built-in Data Frames\nTo learn more about data frames in R, let’s look at some built in data.\nR comes with many built-in data sets to get you started.\nThese do not need to be imported.\nHere is the mtcars data frame.\n\nmtcars\n\n\nA data.frame: 32 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\nDuster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n\n\nMerc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\nMerc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n\n\nMerc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n\n\nMerc 280C\n17.8\n6\n167.6\n123\n3.92\n3.440\n18.90\n1\n0\n4\n4\n\n\nMerc 450SE\n16.4\n8\n275.8\n180\n3.07\n4.070\n17.40\n0\n0\n3\n3\n\n\nMerc 450SL\n17.3\n8\n275.8\n180\n3.07\n3.730\n17.60\n0\n0\n3\n3\n\n\nMerc 450SLC\n15.2\n8\n275.8\n180\n3.07\n3.780\n18.00\n0\n0\n3\n3\n\n\nCadillac Fleetwood\n10.4\n8\n472.0\n205\n2.93\n5.250\n17.98\n0\n0\n3\n4\n\n\nLincoln Continental\n10.4\n8\n460.0\n215\n3.00\n5.424\n17.82\n0\n0\n3\n4\n\n\nChrysler Imperial\n14.7\n8\n440.0\n230\n3.23\n5.345\n17.42\n0\n0\n3\n4\n\n\nFiat 128\n32.4\n4\n78.7\n66\n4.08\n2.200\n19.47\n1\n1\n4\n1\n\n\nHonda Civic\n30.4\n4\n75.7\n52\n4.93\n1.615\n18.52\n1\n1\n4\n2\n\n\nToyota Corolla\n33.9\n4\n71.1\n65\n4.22\n1.835\n19.90\n1\n1\n4\n1\n\n\nToyota Corona\n21.5\n4\n120.1\n97\n3.70\n2.465\n20.01\n1\n0\n3\n1\n\n\nDodge Challenger\n15.5\n8\n318.0\n150\n2.76\n3.520\n16.87\n0\n0\n3\n2\n\n\nAMC Javelin\n15.2\n8\n304.0\n150\n3.15\n3.435\n17.30\n0\n0\n3\n2\n\n\nCamaro Z28\n13.3\n8\n350.0\n245\n3.73\n3.840\n15.41\n0\n0\n3\n4\n\n\nPontiac Firebird\n19.2\n8\n400.0\n175\n3.08\n3.845\n17.05\n0\n0\n3\n2\n\n\nFiat X1-9\n27.3\n4\n79.0\n66\n4.08\n1.935\n18.90\n1\n1\n4\n1\n\n\nPorsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.70\n0\n1\n5\n2\n\n\nLotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n\n\nFord Pantera L\n15.8\n8\n351.0\n264\n4.22\n3.170\n14.50\n0\n1\n5\n4\n\n\nFerrari Dino\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n\n\nMaserati Bora\n15.0\n8\n301.0\n335\n3.54\n3.570\n14.60\n0\n1\n5\n8\n\n\nVolvo 142E\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2\n\n\n\n\n\nTo retrieve data in a cell, we enter its row and column coordinates in the single square bracket [ ] operator.\nThe two coordinates are separated by a comma, e.g. [row, col].\nHere is the cell value from the first row, second column of mtcars.\n\nmtcars[1, 2]\n\n6\n\n\nWe can use names instead of the numeric coordinates.\n\nmtcars[\"Mazda RX4\", \"cyl\"]\n\n6\n\n\nThe number of data rows in the data frame is given by the nrow() function.\n\nnrow(mtcars)\n\n32\n\n\nAnd the number of columns of a data frame is given by the ncol() function.\n\nncol(mtcars)\n\n11\n\n\nWe get the shape of the data frame withdim(), which stands for “dimension.”\n\ndim(mtcars)\n\n\n3211",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#preview-with-head",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#preview-with-head",
    "title": "R Data Frames",
    "section": "Preview with head()",
    "text": "Preview with head()\nInstead of printing out the entire data frame, it is often desirable to preview it with the head function first.\n\nhead(mtcars)\n\n\nA data.frame: 6 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#data-frame-column-vectors",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#data-frame-column-vectors",
    "title": "R Data Frames",
    "section": "Data Frame Column Vectors",
    "text": "Data Frame Column Vectors\nWe reference a the data inside a column with the double square bracket [[]] operator, just as we do for lists.\nFor example, to retrieve the ninth column vector from mtcars, we write:\n\nmtcars[[9]]\n\n\n11100000000000000111000001111111\n\n\nWe can retrieve the same column vector by its name\n\nmtcars[[\"am\"]]\n\n\n11100000000000000111000001111111\n\n\nWe can also retrieve with the $ operator in lieu of the double square bracket operator.\nThis is like using a dot in Pandas.\n\nmtcars$am\n\n\n11100000000000000111000001111111\n\n\nYet another way to retrieve the same column vector is to use the single square bracket [] operator.\nWe prepend the column name with a comma character, which signals a wildcard match for the row position\n\nmtcars[, \"am\"]\n\n\n11100000000000000111000001111111",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#data-frame-column-slice",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#data-frame-column-slice",
    "title": "R Data Frames",
    "section": "Data Frame Column Slice",
    "text": "Data Frame Column Slice\nIn contrast to retrieving vectors from within a data frame, we retrieve a slice of a data frame with the single square bracket [ ] operator.\nA slice of a data frame is just a smaller data frame.\nIt is not a lower-dimensional data strucure, i.e. a vector.\nWe saw this with lists earlier.\nThis is like a one-column dataframe in Pandas, as opposed to a Series.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#numeric-indexing",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#numeric-indexing",
    "title": "R Data Frames",
    "section": "Numeric Indexing",
    "text": "Numeric Indexing\nThe following is a slice containing the first column of mtcars:\n\nhead(mtcars[1])\n\n\nA data.frame: 6 × 1\n\n\n\nmpg\n\n\n\n&lt;dbl&gt;\n\n\n\n\nMazda RX4\n21.0\n\n\nMazda RX4 Wag\n21.0\n\n\nDatsun 710\n22.8\n\n\nHornet 4 Drive\n21.4\n\n\nHornet Sportabout\n18.7\n\n\nValiant\n18.1\n\n\n\n\n\nTo reinforce this difference between getting a slice of a data frame and getting the data it contains, compare the classes of the results in each case.\n\nclass(mtcars[1]); class(mtcars[[1]])\n\n'data.frame'\n\n\n'numeric'",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#name-indexing",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#name-indexing",
    "title": "R Data Frames",
    "section": "Name Indexing",
    "text": "Name Indexing\nWe can also retrieve a column slice by its name.\n\nhead(mtcars[\"mpg\"])\n\n\nA data.frame: 6 × 1\n\n\n\nmpg\n\n\n\n&lt;dbl&gt;\n\n\n\n\nMazda RX4\n21.0\n\n\nMazda RX4 Wag\n21.0\n\n\nDatsun 710\n22.8\n\n\nHornet 4 Drive\n21.4\n\n\nHornet Sportabout\n18.7\n\n\nValiant\n18.1\n\n\n\n\n\nTo retrieve a data frame slice with the two columns mpg and hp, we put the column names into a vector inside the single square bracket operator:\n\nhead(mtcars[c(\"mpg\", \"hp\")])\n\n\nA data.frame: 6 × 2\n\n\n\nmpg\nhp\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nMazda RX4\n21.0\n110\n\n\nMazda RX4 Wag\n21.0\n110\n\n\nDatsun 710\n22.8\n93\n\n\nHornet 4 Drive\n21.4\n110\n\n\nHornet Sportabout\n18.7\n175\n\n\nValiant\n18.1\n105",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#data-frame-row-slices",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#data-frame-row-slices",
    "title": "R Data Frames",
    "section": "Data Frame Row Slices",
    "text": "Data Frame Row Slices\nWe also retrieve rows from a data frame with the single square bracket operator.\nBut, we need append an extra comma character, which implies getting all columns.\nmtcar[&lt;row&gt;,]\nWhere &lt;row&gt; is a row index number or a name.\nIn Python, we would have done this:\ndf[&lt;row&gt;, :]",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#numeric-indexing-1",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#numeric-indexing-1",
    "title": "R Data Frames",
    "section": "Numeric Indexing",
    "text": "Numeric Indexing\nWe can access a row of data by its index number.\nFor example, the following retrieves the 24th row record.\n\nmtcars[24,]\n\n\nA data.frame: 1 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nCamaro Z28\n13.3\n8\n350\n245\n3.73\n3.84\n15.41\n0\n0\n3\n4\n\n\n\n\n\nTo retrieve more than one row, we use a numeric index vector:\n\nmtcars[c(3, 24),]\n\n\nA data.frame: 2 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.32\n18.61\n1\n1\n4\n1\n\n\nCamaro Z28\n13.3\n8\n350\n245\n3.73\n3.84\n15.41\n0\n0\n3\n4",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#name-indexing-1",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#name-indexing-1",
    "title": "R Data Frames",
    "section": "Name Indexing",
    "text": "Name Indexing\nWe can retrieve a row by its index name.\n\nmtcars[\"Camaro Z28\",]\n\n\nA data.frame: 1 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nCamaro Z28\n13.3\n8\n350\n245\n3.73\n3.84\n15.41\n0\n0\n3\n4\n\n\n\n\n\nAnd we can pack the row names in an index vector in order to retrieve multiple rows.\n\nmtcars[c(\"Datsun 710\", \"Camaro Z28\"),]\n\n\nA data.frame: 2 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.32\n18.61\n1\n1\n4\n1\n\n\nCamaro Z28\n13.3\n8\n350\n245\n3.73\n3.84\n15.41\n0\n0\n3\n4",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#logical-indexing",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#logical-indexing",
    "title": "R Data Frames",
    "section": "Logical Indexing",
    "text": "Logical Indexing\nWe can also retrieve rows with a logical index vector.\nIn the following logical (boolean) vector expression, the member value is TRUE if the car has automatic transmission, and FALSE if otherwise.\n\nmtcars$am == 1 \n\n\nTRUETRUETRUEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSEFALSETRUETRUETRUEFALSEFALSEFALSEFALSEFALSETRUETRUETRUETRUETRUETRUETRUE\n\n\nPassing this vector expression as a row selector, we get the subset of rows with vehicles that have automatic transmission:\n\nmtcars[mtcars$am == 1,]\n\n\nA data.frame: 13 × 11\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nFiat 128\n32.4\n4\n78.7\n66\n4.08\n2.200\n19.47\n1\n1\n4\n1\n\n\nHonda Civic\n30.4\n4\n75.7\n52\n4.93\n1.615\n18.52\n1\n1\n4\n2\n\n\nToyota Corolla\n33.9\n4\n71.1\n65\n4.22\n1.835\n19.90\n1\n1\n4\n1\n\n\nFiat X1-9\n27.3\n4\n79.0\n66\n4.08\n1.935\n18.90\n1\n1\n4\n1\n\n\nPorsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.70\n0\n1\n5\n2\n\n\nLotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n\n\nFord Pantera L\n15.8\n8\n351.0\n264\n4.22\n3.170\n14.50\n0\n1\n5\n4\n\n\nFerrari Dino\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n\n\nMaserati Bora\n15.0\n8\n301.0\n335\n3.54\n3.570\n14.60\n0\n1\n5\n8\n\n\nVolvo 142E\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2\n\n\n\n\n\nAnd here is the gas mileage data for automatic transmission\n\nmtcars[mtcars$am == 1,]$mpg\n\n\n212122.832.430.433.927.32630.415.819.71521.4",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#importing-data",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#importing-data",
    "title": "R Data Frames",
    "section": "Importing Data",
    "text": "Importing Data\nTo retrieve data from external files and convert them in to data frames, R offers a number of import functions.\nTo read CSV files, you can use the built-in function read.csv().\nHere’s a quick example.\n\ndf_from_csv &lt;- read.csv(\"mydata.csv\")\n\n\ndf_from_csv\n\n\nA data.frame: 3 × 3\n\n\nCol1\nCol2\nCol3\n\n\n&lt;int&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\n100\na1\nb1\n\n\n200\na2\nb2\n\n\n300\na3\nb3\n\n\n\n\n\nR has a special function for reading in table data where cell data are separated by spaces.\nIn this example, mydata.txt contains this:\n100 a1 b1 \n200 a2 b2 \n300 a3 b3 \n400 a4 b4\n\ndf_from_table &lt;- read.table(\"mydata.txt\")\ndf_from_table\n\n\nA data.frame: 4 × 3\n\n\nV1\nV2\nV3\n\n\n&lt;int&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\n100\na1\nb1\n\n\n200\na2\nb2\n\n\n300\na3\nb3\n\n\n400\na4\nb4",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#plotting-data-with-plot",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#plotting-data-with-plot",
    "title": "R Data Frames",
    "section": "Plotting Data with plot()",
    "text": "Plotting Data with plot()\nR is know for its high-quality visualizations, and we’ll explore at these in more detail when we look at GGPlot.\nFor now, consider the plot() function.\nOne of the nice features of plot() is that it produced plots based on the shape and type of data you give it.\nTo see this, let’s plot the data from the built in data frame airquality.\n\nhead(airquality)\n\n\nA data.frame: 6 × 6\n\n\n\nOzone\nSolar.R\nWind\nTemp\nMonth\nDay\n\n\n\n&lt;int&gt;\n&lt;int&gt;\n&lt;dbl&gt;\n&lt;int&gt;\n&lt;int&gt;\n&lt;int&gt;\n\n\n\n\n1\n41\n190\n7.4\n67\n5\n1\n\n\n2\n36\n118\n8.0\n72\n5\n2\n\n\n3\n12\n149\n12.6\n74\n5\n3\n\n\n4\n18\n313\n11.5\n62\n5\n4\n\n\n5\nNA\nNA\n14.3\n56\n5\n5\n\n\n6\n28\nNA\n14.9\n66\n5\n6\n\n\n\n\n\nIf we pass it the whole data frame, it produces a scatter plot lattice:\n\nplot(airquality)\n\n\n\n\n\n\n\n\nIf we pass it just two columns, it produces a scatter plot:\n\nplot(airquality[, c(\"Temp\", \"Wind\")])\n\n\n\n\n\n\n\n\nAnd if pass it one, it produces a line graph:\n\nplot(airquality$Temp, type='l')\n\n\n\n\n\n\n\n\nThe hist() function will create a histogram:\n\nhist(airquality$Temp)",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-04-DataFrames.html#value-counts-with-table",
    "href": "notebooks/M10_RBasics/M10-04-DataFrames.html#value-counts-with-table",
    "title": "R Data Frames",
    "section": "Value Counts with table()",
    "text": "Value Counts with table()\nThis function is like .value_counts() in Pandas.\nIt does a quick count of all the value types of a feature or combination of them.\nHere we get a table of values and their counts for airquality$Month.\n\nmonths &lt;- table(airquality$Month)\nmonths.df &lt;- data.frame(months)\nnames(months.df) &lt;- c(\"Month\", \"Freq\")\nt(months.df)\n\n\nA matrix: 2 × 5 of type chr\n\n\nMonth\n5\n6\n7\n8\n9\n\n\nFreq\n31\n30\n31\n31\n30\n\n\n\n\n\nNote we used t() to transpose the data frame.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>R Data Frames</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html",
    "title": "R Control Structures",
    "section": "",
    "text": "Conditional Statements\nR supports conditional statements in the standard way.\nIt provides the following statements:\nif, else if, and else.\nHere’s a skeletal control structure in R:\nHere is a more compact way of writing it:\nLet’s look at some examples.\nHere, we generate a uniform random number, using the function runif().\nThe first argument determines the number of results, and the second two define the upper and lower bound.\nx &lt;- runif(1, 0, 10)\nx\n\n6.29529620986432\nif (x &gt; 3) {\n    y &lt;- 10\n} else {\n    y &lt;- 0\n}\ny\n\n10\nYou can assign an if statement to a variable.\nz &lt;- if (x &gt; 3) {10} else {0}\nz\n\n10\nNote you can drop the braces when doing a one-liner.\nz &lt;- if (x &gt; 3) 10 else 0\nz\n\n10\nYou do need to keep the parentheses around the comparison expression, though.\nOf course, you can stack if blocks, too.",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#conditional-statements",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#conditional-statements",
    "title": "R Control Structures",
    "section": "",
    "text": "if (&lt;condition&gt;) {\n        ## do something\n} \n\nif (&lt;condition&gt;) {\n        ## do something\n} \nelse {\n        ## do something else\n}\n\nif (&lt;condition1&gt;) {\n        ## do something\n} else if (&lt;condition2&gt;)  {\n        ## do something different\n} else {\n        ## do something different\n}\n\n\n\n\n\n\n\n\n\n\n\nif (&lt;condition1&gt;) {\n    \n}\n\nif (&lt;condition2&gt;) {\n\n}",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#for-loops",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#for-loops",
    "title": "R Control Structures",
    "section": "for Loops",
    "text": "for Loops\nFor loops are straight-forward in R.\nThey take an iterator variable, e.g. i, and assign it successive values from a sequence or vector.\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#seq_along",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#seq_along",
    "title": "R Control Structures",
    "section": "seq_along()",
    "text": "seq_along()\nThe seq_along() function is commonly used in conjunction with for loops.\nIt generates an integer sequence based on the length of an object.\n\nx &lt;- c(\"a\", \"b\", \"c\", \"d\")\nfor (i in seq_along(x)) {\n  print(x[i])  \n}\n\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n\n\nNote that it is not necessary to use an index-type variable to iterate through an iterable object.\n\nfor (letter in x) {\n  print(letter)\n}\n\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n\n\nFor one line loops, the curly braces are not strictly necessary.\n\nfor (i in 1:4) print(x[i])\n\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#seq_len",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#seq_len",
    "title": "R Control Structures",
    "section": "seq_len()",
    "text": "seq_len()\nThe seq_len() function is also used in conjunction with for loops.\nIt generates an integer sequence based a number.\n\nfor (i in seq_len(length(x))) {\n  print(x[i])  \n}\n\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n\n\nseq_len() is like seq(), but it doesn’t have the flexibility of the latter.\nIt handles the common case of beginning at \\(1\\) and stepping by \\(1\\).\n\nseq(length(x))\nseq_len(length(x))\n\n\n123456\n\n\n\n123456",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#nested-for-loops",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#nested-for-loops",
    "title": "R Control Structures",
    "section": "Nested for loops",
    "text": "Nested for loops\nFor loops can be nested inside of each other.\nThe number of levels you nest is often a function of the number of dimensions in your iterable.\nHere we iterate through a \\(2\\)-D data structure.\n\nx &lt;- matrix(1:6, 2, 3)\nfor (i in seq_len(nrow(x))) {\n  for (j in seq_len(ncol(x))) {\n    print(x[i, j])\n  }   \n}\n\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#while-loops",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#while-loops",
    "title": "R Control Structures",
    "section": "while Loops",
    "text": "while Loops\nAs with Python, while loops start with a condition.\nIt iterates while the condition is TRUE and stops when it is FALSE.\nRemember, while loops can go on forever is the truth condition is never met!\n\ncount &lt;- 0\nwhile (count &lt; 10) {\n  print(count)\n  count &lt;- count + 1\n}\n\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#next-and-break",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#next-and-break",
    "title": "R Control Structures",
    "section": "next and break",
    "text": "next and break\nnext is used to skip an iteration of a loop.\nThis is the same as continue in Python.\n\nfor (i in 1:100) {\n  if (i &lt;= 20) {\n    # Skip the first 20 iterations\n    next                \n  }     \n  # Do something here\n}\n\nbreak is used to exit a loop immediately.\n\nfor (i in 1:100) {\n  print(i)\n  if (i &gt; 20) {\n    # Stop loop after 20 iterations\n    break  \n  }     \n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-05-ControlStructures.html#repeat-loops",
    "href": "notebooks/M10_RBasics/M10-05-ControlStructures.html#repeat-loops",
    "title": "R Control Structures",
    "section": "repeat Loops",
    "text": "repeat Loops\nrepeat loops are used by R.\nThey initiate an infinite loop right from the start.\nThe only way to exit a repeat loop is to call break on an internal condition.\nHere’s an example of what one might look like:\nx0 &lt;- 1\ntol &lt;- 1e-8\n\nrepeat {\n  x1 &lt;- computeEstimate()\n  if (abs(x1 - x0) &lt; tol) {  ## Close enough?\n    break\n  } else {\n    x0 &lt;- x1\n  } \n}",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Control Structures</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-06-Functions.html",
    "href": "notebooks/M10_RBasics/M10-06-Functions.html",
    "title": "R Functions",
    "section": "",
    "text": "Default Argument Values\nFunction arguments can use default values:\nthreshold_vals &lt;- function(p, thresh = 0.5) {\n  p &gt; thresh\n}\nHere we use the default thresh.\nthreshold_vals(c(0.6, 0.4, 0.1, 1))\n\n\nTRUEFALSEFALSETRUE\nNow, pass a different threshold:\nthreshold_vals(c(0.6, 0.4, 0.1, 1), 0.7)\n\n\nFALSEFALSEFALSETRUE",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>R Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-06-Functions.html#error-trapping",
    "href": "notebooks/M10_RBasics/M10-06-Functions.html#error-trapping",
    "title": "R Functions",
    "section": "Error Trapping",
    "text": "Error Trapping\nYou can assert important preconditions with stop().\nHere, we assert that the lengths of vectors x and y match.\nIf they don’t. we throw an error with stop().\n\nadd_vectors &lt;- function(x, y) {\n  if (length(x) != length(y)) {\n    stop(\"x and y must be the same length\", call. = FALSE)\n  }\n  x + y\n}\n\n\nadd_vectors(c(1, 2, 3), c(3, 3, 3))\n\n\n456\n\n\nLet’s see if it traps this error:\n\nadd_vectors(c(1, 2, 3), c(3, 3, 3, 3))\n\nERROR: Error: x and y must be the same length\n\nError: x and y must be the same length\nTraceback:\n\n1. add_vectors(c(1, 2, 3), c(3, 3, 3, 3))\n2. stop(\"x and y must be the same length\", call. = FALSE)   # at line 3 of file &lt;text&gt;",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>R Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-06-Functions.html#scoping-rules",
    "href": "notebooks/M10_RBasics/M10-06-Functions.html#scoping-rules",
    "title": "R Functions",
    "section": "Scoping Rules",
    "text": "Scoping Rules\nScoping rules for functions are similar to those in Python.\nR uses the tinted glass model discussed earlier.\n\nz &lt;- 4\ntest_fcn &lt;- function(x) {\n  x^z\n}\n\n\ntest_fcn(2)\n\n16\n\n\nSince z isn’t in the function, R looks in the function’s environment for it.\nNote that R handles potential scope conflicts differently to Python.\nRecall that Python would not have allowed the following to run, since the function treats m as both global and local.\n\nm &lt;- 5\ntest_2 &lt;- function(x) {\n    print(m)\n    m &lt;- x**2\n    print(m)\n}\n\n\ntest_2(10)\n\n[1] 5\n[1] 100",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>R Functions</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html",
    "title": "The Tidyverse and Tibbles",
    "section": "",
    "text": "The Tidyverse\nTidyverse is a collection of essential R packages for data science.\nThe packages included in the Tidyverse are designed to support the pipeline of activities associated with data science, such as filtering, transforming, visualizing, etc.\nTidyverse was created by Hadley Wickham and his team with the aim of providing all these utilities to clean and work with data.\nHere’s a graphic of the packages associated with the Tidyverse:",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#tidy-data",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#tidy-data",
    "title": "The Tidyverse and Tibbles",
    "section": "Tidy Data",
    "text": "Tidy Data\nNote that the word “tidy” in Tidyverse stands for a specific way to structure data in data frames.\nTidy data frames have the following qualities:\nEach variable forms a column.\nEach observation forms a row.\nEach type of observational unit forms a table.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#using-the-tidyverse",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#using-the-tidyverse",
    "title": "The Tidyverse and Tibbles",
    "section": "Using the Tidyverse",
    "text": "Using the Tidyverse\nTo use the Tidyverse, we often import everything:\n\ninstall.packages(\"tidyverse\")\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#piping-with",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#piping-with",
    "title": "The Tidyverse and Tibbles",
    "section": "Piping with %>%",
    "text": "Piping with %&gt;%\nJust a quick note about this odd looking operator that you will start to see.\nOne of the key elements of the Tidyverse is the use of piping.\nPiping is the ability of to pass the return values of one function to another, without having to nest functions.\nFor example, instead of something like this:\n\na &lt;- \"Hello\"\nb &lt;- \"World\"\n\nvar1 &lt;- c(a, b)\nvar2 &lt;- paste(var1)\nprint(var2)\n\n[1] \"Hello\" \"World\"\n\n\nOr this:\n\nprint(paste(c(a,b)))\n\n[1] \"Hello\" \"World\"\n\n\nWe can do:\n\nc(a, b) %&gt;%\n  paste() %&gt;%\n  print()\n\n[1] \"Hello\" \"World\"\n\n\nYou can see that although this pattern is longer than the preceding, it is easier to read and write.\nThe pipe operator %&gt;% is similar to the pipe operator | in Unix shells.\nmore foo.txt | grep bar\nPiping is also similar to method chaining in Python, but is more pervasive.\nIn Python you can chain individual objects that return themselves (as it were).\nFor example, we chain four operations below:\ndf.value_counts('foo').to_frame('n').fillna(0).T\nIn the Tidyverse, you pipe together any two functions so long as it makes sense that the output of one function is the input of another.\nBy default, the output of one function becomes the first argument of the function following the %&gt;%.\nIf not use the . placeholder variable to tell pipe operator where to put the data.\nFor example, here we want the data frame to be the second argument of the lm() function:\nmy_data_frame %&gt;%\nlm(y ~ x, .)\nBy the way, the operator comes with the magrittr package, which is a central part of the Tidyverse. It is so central, in fact, that packages in the tidyverse load %&gt;% automatically.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#creating-tibbles",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#creating-tibbles",
    "title": "The Tidyverse and Tibbles",
    "section": "Creating tibbles",
    "text": "Creating tibbles\nIf you need to make a tibble “by hand”, you can use tibble() or tribble().\ntibble() works by assembling individual vectors, a column-wise operation:\n\nx &lt;- c(1, 2, 5)\ny &lt;- c(\"a\", \"b\", \"h\")\ntibble(x, y)\n\n\nA tibble: 3 × 2\n\n\nx\ny\n\n\n&lt;dbl&gt;\n&lt;chr&gt;\n\n\n\n\n1\na\n\n\n2\nb\n\n\n5\nh\n\n\n\n\n\nYou can also name the inputs, provide data inline with c(), and perform computation:\n\ntibble(\n  x1 = x,\n  x2 = c(10, 15, 25),\n  y = sqrt(x1^2 + x2^2)\n)\n\n\nA tibble: 3 × 3\n\n\nx1\nx2\ny\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n1\n10\n10.04988\n\n\n2\n15\n15.13275\n\n\n5\n25\n25.49510\n\n\n\n\n\nEvery column in a data frame or tibble must be the same length. If they are not, you will get an error:\n\ntibble(  \n    x = c(1, 5),   \n    y = c(\"a\", \"b\", \"c\") \n)\n\n\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n• Size 2: Existing data.\n• Size 3: Column `y`.\nℹ Only values of size one are recycled.\nTraceback:\n\n1. tibble(x = c(1, 5), y = c(\"a\", \"b\", \"c\"))\n2. tibble_quos(xs, .rows, .name_repair)\n3. vectbl_recycle_rows(res, first_size, j, given_col_names[[j]], \n .     call)\n4. abort_incompatible_size(n, name, size, \"Existing data\", call)\n5. tibble_abort(call = call, bullets(\"Tibble columns must have compatible sizes:\", \n .     if (!is.null(.rows)) paste0(\"Size \", .rows, \": \", rows_source), \n .     problems, info = \"Only values of size one are recycled.\"))\n6. abort(x, class, ..., call = call, parent = parent, use_cli_format = TRUE)\n7. signal_abort(cnd, .file)\n\n\n\nAs the error message says, “Only values of size one are recycled.”\nSo this will work:\n\ntibble(\n  x = 1:5,\n  y = \"a\",\n  z = TRUE\n)\n\n\nA tibble: 5 × 3\n\n\nx\ny\nz\n\n\n&lt;int&gt;\n&lt;chr&gt;\n&lt;lgl&gt;\n\n\n\n\n1\na\nTRUE\n\n\n2\na\nTRUE\n\n\n3\na\nTRUE\n\n\n4\na\nTRUE\n\n\n5\na\nTRUE",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#tribbles",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#tribbles",
    "title": "The Tidyverse and Tibbles",
    "section": "Tribbles",
    "text": "Tribbles\nAnother way to create a tibble is with tribble(), which short for transposed tibble.\ntribble() is customized for entering data directly in code, where row-wise entries are more natural.\nColumn headings start with ~.\nEntries are separated by commas.\nThis makes it possible to lay out small amounts of data in an easy to read form:\n\ntribble(\n  ~x, ~y, ~z,\n  \"a\", 2, 3.6,\n  \"b\", 1, 8.5\n)\n\n\nA tibble: 2 × 3\n\n\nx\ny\nz\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\na\n2\n3.6\n\n\nb\n1\n8.5\n\n\n\n\n\nFinally, if you have a regular data frame you can turn it into to a tibble with as_tibble():\n\nas_tibble(mtcars) %&gt;% head()\n\n\nA tibble: 6 × 11\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n\n\n\nThe inverse of as_tibble() is as.data.frame().\nIt converts a tibble back into a regular data.frame.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#non-syntactic-names",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#non-syntactic-names",
    "title": "The Tidyverse and Tibbles",
    "section": "Non-syntactic names",
    "text": "Non-syntactic names\nIt’s possible for a tibble to have column names that are not valid R variable names, names that are non-syntactic.\nFor example, the variables might not start with a letter or they might contain unusual characters like a space.\n\ntb &lt;- tibble(\n  `:)` = \"smile\", \n  ` ` = \"space\",\n  `2000` = \"number\"\n)\n\n\ntb\n\n\nA tibble: 1 × 3\n\n\n:)\n\n2000\n\n\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n\n\n\n\nsmile\nspace\nnumber\n\n\n\n\n\nNote that to refer to these variables, you need to surround them with backticks, `:\nYou’ll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#printing",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#printing",
    "title": "The Tidyverse and Tibbles",
    "section": "Printing",
    "text": "Printing\nThe print method will print only the first 10 rows and the columns that fit on screen.\nThis makes it much easier to work with large data.\n\nmy_trib &lt;- tibble(\n  a = lubridate::now() + runif(1e3) * 86400,\n  b = lubridate::today() + runif(1e3) * 30,\n  c = 1:1e3,\n  d = runif(1e3),\n  e = sample(letters, 1e3, replace = TRUE)\n)\n\n\nprint(my_trib)\n\n# A tibble: 1,000 × 5\n   a                   b              c      d e    \n   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1 2024-09-27 11:55:17 2024-10-01     1 0.299  k    \n 2 2024-09-28 09:32:40 2024-10-06     2 0.247  k    \n 3 2024-09-27 13:15:14 2024-10-08     3 0.456  b    \n 4 2024-09-28 04:51:21 2024-10-21     4 0.357  e    \n 5 2024-09-28 10:08:21 2024-10-13     5 0.150  q    \n 6 2024-09-28 01:33:43 2024-09-29     6 0.565  r    \n 7 2024-09-27 21:58:04 2024-10-19     7 0.0905 y    \n 8 2024-09-28 05:03:11 2024-10-02     8 0.912  f    \n 9 2024-09-28 10:27:03 2024-10-13     9 0.169  z    \n10 2024-09-28 03:24:24 2024-09-30    10 0.338  u    \n# ℹ 990 more rows\n\n\nWhere possible, tibbles also use color to draw your eye to important differences.\nOne of the most important distinctions is between the string \"NA\" and the missing value, NA:\n\nprint(tibble(x = c(\"NA\", NA)))\n\n# A tibble: 2 × 1\n  x    \n  &lt;chr&gt;\n1 NA   \n2 NA   \n\n\nTibbles are designed to avoid overwhelming your console when you print large data frames.\nBut sometimes you need more output than the default display.\nThere are a few options that can help.\nFirst, you can explicitly print() the data frame and control the number of rows (n) and the width of the display. width = Inf will display all columns:\n\n# install.packages(\"nycflights13\")\n\n\nlibrary(nycflights13)\n\n\nflights %&gt;% print(n = 10, width = Inf)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n   arr_delay carrier flight tailnum origin dest  air_time distance  hour minute\n       &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1        11 UA        1545 N14228  EWR    IAH        227     1400     5     15\n 2        20 UA        1714 N24211  LGA    IAH        227     1416     5     29\n 3        33 AA        1141 N619AA  JFK    MIA        160     1089     5     40\n 4       -18 B6         725 N804JB  JFK    BQN        183     1576     5     45\n 5       -25 DL         461 N668DN  LGA    ATL        116      762     6      0\n 6        12 UA        1696 N39463  EWR    ORD        150      719     5     58\n 7        19 B6         507 N516JB  EWR    FLL        158     1065     6      0\n 8       -14 EV        5708 N829AS  LGA    IAD         53      229     6      0\n 9        -8 B6          79 N593JB  JFK    MCO        140      944     6      0\n10         8 AA         301 N3ALAA  LGA    ORD        138      733     6      0\n   time_hour          \n   &lt;dttm&gt;             \n 1 2013-01-01 05:00:00\n 2 2013-01-01 05:00:00\n 3 2013-01-01 05:00:00\n 4 2013-01-01 05:00:00\n 5 2013-01-01 06:00:00\n 6 2013-01-01 05:00:00\n 7 2013-01-01 06:00:00\n 8 2013-01-01 06:00:00\n 9 2013-01-01 06:00:00\n10 2013-01-01 06:00:00\n# ℹ 336,766 more rows\n\n\nYou can also control the default print behavior by setting options:\n\noptions(tibble.print_max = n, tibble.print_min = m): if more than n rows, print only m rows.\nUse options(tibble.print_min = Inf) to always show all rows.\nUse options(tibble.width = Inf) to always print all columns, regardless of the width of the screen.\n\nYou can see a complete list of options by looking at the package help with package?tibble.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#using-rstudio-view",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#using-rstudio-view",
    "title": "The Tidyverse and Tibbles",
    "section": "Using RStudio View()",
    "text": "Using RStudio View()\nA final option is to use RStudio’s built-in data viewer to get a scrollable view of the complete dataset. This is also often useful at the end of a long chain of manipulations.\nYou can open a window with a view to your data by calling View(), like so:\nflights %&gt;% View()\nHere’s what the opened window would looks like:",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#extracting-variables",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#extracting-variables",
    "title": "The Tidyverse and Tibbles",
    "section": "Extracting variables",
    "text": "Extracting variables\nSo far all the tools you’ve learned have worked with complete data frames.\nIf you want to pull out a single variable, you can use dplyr::pull():\n\ntb &lt;- tibble(\n  id = LETTERS[1:5],\n  x1  = 1:5,\n  y1  = 6:10\n)\n\n\ntb %&gt;% pull(x1) # by name\n\n\n12345\n\n\n\ntb %&gt;% pull(1)  # by position\n\n\n'A''B''C''D''E'\n\n\npull() also takes an optional name argument that specifies the column to be used as names for a named vector.\n\ntb %&gt;% pull(x1, name = id) %&gt;% print()\n\nA B C D E \n1 2 3 4 5 \n\n\nYou can also use the base R tools $ and [[.\n[[ can extract by name or position.\n$ only extracts by name but is a little less typing.\nHere we extract by name:\n\ntb$x1\n\n\n12345\n\n\n\ntb[[\"x1\"]]\n\n\n12345\n\n\nHere we extract by position:\n\ntb[[1]]\n\n\n'A''B''C''D''E'\n\n\nCompared to a data frame, tibbles are more strict.\nThey never do partial matching.\nPartial matching is when you specify a part of a column name in a selection operation and R returns the column that matches the substring if there is one.\nFor example, if you have a data frame df with a column called x1 and you do this — df$x — R will return that column, assuming there are no other columns that begin with x.\n\ndf &lt;- as.data.frame(tb)\n\n\ndf$x\n\n\n12345\n\n\nNor will data frames generate a warning if the column you are trying to access does not exist.\n\ndf$z\n\nNULL\n\n\nTibbles don’t do these things.\nInstead, they treat both cases as unknown columns and warn the user.\n\ntb$x\n\nWarning message:\n“Unknown or uninitialised column: `x`.”\n\n\nNULL\n\n\n\ntb$z\n\nWarning message:\n“Unknown or uninitialised column: `z`.”\n\n\nNULL\n\n\nFor this reason we sometimes joke that tibbles are lazy and surly.\nThey do less and complain more :-)",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-01-Tibbles.html#subsetting",
    "href": "notebooks/M11_RDplyr/M11-01-Tibbles.html#subsetting",
    "title": "The Tidyverse and Tibbles",
    "section": "Subsetting",
    "text": "Subsetting\nLastly, there are some important differences when using [.\nWith traditional data frames, [ sometimes returns a data.frame, and sometimes returns a vector.\nThis is a common source of bugs.\nWith tibbles, [ always returns another tibble.\nThis can sometimes cause problems when working with older code.\nIf you hit one of those functions, just use as.data.frame() to turn your tibble back to a data.frame.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>The Tidyverse and Tibbles</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html",
    "title": "Dplyr",
    "section": "",
    "text": "What is Dplyr?\nThe Dplyr package is a cetnral component of the Tidyverse.\nTechnically, Dplyr is an optimized and distilled version of the previous Plyr package.\nPlyr organizes much of the functionality of the family of apply functions in base R — functions like apply(), lapply(), sapply(), and tapply().\nThese functions perform the same action on multiple chunks of data in a repetitive way.\nFor example, apply() applies a function to every element of a row or column in a dataset.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#why-dplyr",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#why-dplyr",
    "title": "Dplyr",
    "section": "Why Dplyr?",
    "text": "Why Dplyr?\nDplyr was developed to provide a clean and intelligble way to process data tables.\nIt does this by providing a simple grammar for data manipulation and for operating on data frames.\nWith this grammar, you can clearly express and communicate what it is that you are doing to a data frame that other people can understand.\nThis is useful because it provides an abstraction for data manipulation that previously did not exist within R and other programming languages.\nAnother useful contribution is that the Dplyr functions are very fast, as many key operations are coded in C++.\nNote that Dplyr does not provide any new functionality to R per se.\nEverything Dplyr does may already be done with base R.\nBut it greatly simplifies existing functionality in R.\nIn the table below, you can see that that Dplyr provides a consistent way of phrasing the someone chaotic idioms of base R.\n\n\n\ndplyr\nbase R\n\n\n\n\narrange(df, x)\ndf[order(x), , drop = FALSE]\n\n\ndistinct(df, x)\ndf[!duplicated(x), , drop = FALSE], unique()\n\n\nfilter(df, x)\ndf[which(x), , drop = FALSE], subset()\n\n\nmutate(df, z = x + y)\ndf$z &lt;- df$x + df$y, transform()\n\n\npull(df, 1)\ndf[[1]]\n\n\npull(df, x)\ndf$x\n\n\nrename(df, y = x)\nnames(df)[names(df) == \"x\"] &lt;- \"y\"\n\n\nrelocate(df, y)\ndf[union(\"y\", names(df))]\n\n\nselect(df, x, y)\ndf[c(\"x\", \"y\")], subset()\n\n\nselect(df, starts_with(\"x\"))\ndf[grepl(\"\n\n\nsummarise(df, mean(x))\nmean(df$x), tapply(), aggregate(), by()\n\n\nslice(df, c(1, 2, 5))\ndf[c(1, 2, 5), , drop = FALSE]",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#a-grammar-of-data",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#a-grammar-of-data",
    "title": "Dplyr",
    "section": "A Grammar of Data",
    "text": "A Grammar of Data\nSome of the key “verbs” provided by the Dplyr package are:\n\nselect: return a subset of the columns of a data frame, using a flexible notation.\nfilter: extract a subset of rows from a data frame based on logical conditions.\narrange: reorder rows of a. data frame.\nrename: rename variables in a data frame.\nmutate: add new variables/columns or transform existing variables.\nsummarise / summarize: generate summary statistics of different variables in the data frame, possibly within strata.\n\n%&gt;%: the pipe operator is used to connect multiple verb actions together into a pipeline.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#common-function-properties",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#common-function-properties",
    "title": "Dplyr",
    "section": "Common Function Properties",
    "text": "Common Function Properties\nAll Dplyr functions have some common characteristics:\n\nThe first argument is a data frame (or tibble).\nThe succeeding arguments describe what to do with the data frame specified in the first argument.\nThe return result of a function is a new data frame.\n\nIn addition, Dplyr expects data frames to be be properly structured as tidy data.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#installing-dplyr",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#installing-dplyr",
    "title": "Dplyr",
    "section": "Installing Dplyr",
    "text": "Installing Dplyr\nYou can install Dplyr directly or as part of Tidyverse, which we installed in the previous notebook.\n\n# install.packages(\"dplyr\")\n\nOnce the package is installed, you may load it into your R session by calling the library() function.\n\n# library(dplyr)\n\nOf course, you can also just install tidyverse if you plan to visualize your results.\nSince we did this in our previous notebook, we can import it now.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nYou may get some warnings when the package is loaded because there are functions in the dplyr package that have the same name as functions in other packages. For now you can ignore the warnings.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#getting-a-dataset",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#getting-a-dataset",
    "title": "Dplyr",
    "section": "Getting a dataset",
    "text": "Getting a dataset\nLet’s use a dataset containing air pollution and temperature data for the city of Chicago in the U.S.\nYou will find the data in the directory for this module.\nWe load the data into R using the readRDS() function and then convert it to a tibble.\n\nchicago &lt;- readRDS(\"chicago.rds\") %&gt;% as_tibble()\n\nWe can see some basic characteristics of the dataset with the print() function.\n\nprint(chicago)\n\n# A tibble: 6,940 × 8\n   city   tmpd  dptp date       pm25tmean2 pm10tmean2 o3tmean2 no2tmean2\n   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;          &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 chic   31.5  31.5 1987-01-01         NA       34       4.25      20.0\n 2 chic   33    29.9 1987-01-02         NA       NA       3.30      23.2\n 3 chic   33    27.4 1987-01-03         NA       34.2     3.33      23.8\n 4 chic   29    28.6 1987-01-04         NA       47       4.38      30.4\n 5 chic   32    28.9 1987-01-05         NA       NA       4.75      30.3\n 6 chic   40    35.1 1987-01-06         NA       48       5.83      25.8\n 7 chic   34.5  26.8 1987-01-07         NA       41       9.29      20.6\n 8 chic   29    22   1987-01-08         NA       36      11.3       17.0\n 9 chic   26.5  29   1987-01-09         NA       33.3     4.5       23.4\n10 chic   32.5  27.8 1987-01-10         NA       NA       4.96      19.5\n# ℹ 6,930 more rows",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#select",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#select",
    "title": "Dplyr",
    "section": "select()",
    "text": "select()\nWe use the select() function to select columns you want to focus on.\nFor example, we can inspect the tmpd column like so:\n\nchicago %&gt;% select(tmpd) %&gt;% head()\n\n\nA tibble: 6 × 1\n\n\ntmpd\n\n\n&lt;dbl&gt;\n\n\n\n\n31.5\n\n\n33.0\n\n\n33.0\n\n\n29.0\n\n\n32.0\n\n\n40.0\n\n\n\n\n\nIn base R, we would do this:\n\nhead(chicago[\"tmpd\"])\n\n\nA tibble: 6 × 1\n\n\ntmpd\n\n\n&lt;dbl&gt;\n\n\n\n\n31.5\n\n\n33.0\n\n\n33.0\n\n\n29.0\n\n\n32.0\n\n\n40.0\n\n\n\n\n\nNow suppose we wanted to take the first \\(3\\) columns only.\nWe could use numerical indices in base R.\n\nhead(chicago[1:3])\n\n\nA tibble: 6 × 3\n\n\ncity\ntmpd\ndewpoint\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n31.5\n31.500\n\n\nchic\n33.0\n29.875\n\n\nchic\n33.0\n27.375\n\n\nchic\n29.0\n28.625\n\n\nchic\n32.0\n28.875\n\n\nchic\n40.0\n35.125\n\n\n\n\n\nIn Dplr, we can use the names directly to create a column range slice:\n\nchicago %&gt;%\n  select(city:dptp) %&gt;%\n  head()\n\n\nA tibble: 6 × 3\n\n\ncity\ntmpd\ndptp\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n31.5\n31.500\n\n\nchic\n33.0\n29.875\n\n\nchic\n33.0\n27.375\n\n\nchic\n29.0\n28.625\n\n\nchic\n32.0\n28.875\n\n\nchic\n40.0\n35.125\n\n\n\n\n\nNote the use of : inside the select() — you can use it to specify a range of variable names.\nYou can also omit variables using the select() function by using the negative sign.\nWith select() you can do:\n\nchicago %&gt;%\n    select(-(city:dptp)) %&gt;% \n    head()\n\n\nA tibble: 6 × 5\n\n\ndate\npm25tmean2\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n1987-01-01\nNA\n34.00000\n4.250000\n19.98810\n\n\n1987-01-02\nNA\nNA\n3.304348\n23.19099\n\n\n1987-01-03\nNA\n34.16667\n3.333333\n23.81548\n\n\n1987-01-04\nNA\n47.00000\n4.375000\n30.43452\n\n\n1987-01-05\nNA\nNA\n4.750000\n30.33333\n\n\n1987-01-06\nNA\n48.00000\n5.833333\n25.77233\n\n\n\n\n\nThis indicates that we should include every variable except the variables city through dptp.\nThe select() function also allows a special syntax that allows you to specify variable names based on patterns.\nIf you wanted to keep every variable that ends with a “2”, we could do this:\n\nchicago %&gt;%\n  select(ends_with(\"2\")) %&gt;%\n  head()\n\n\nA tibble: 6 × 4\n\n\npm25tmean2\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nNA\n34.00000\n4.250000\n19.98810\n\n\nNA\nNA\n3.304348\n23.19099\n\n\nNA\n34.16667\n3.333333\n23.81548\n\n\nNA\n47.00000\n4.375000\n30.43452\n\n\nNA\nNA\n4.750000\n30.33333\n\n\nNA\n48.00000\n5.833333\n25.77233\n\n\n\n\n\nOr if we wanted to keep every variable that starts with a “d”, we could do this:\n\nchicago %&gt;%\n  select(starts_with(\"d\")) %&gt;%\n  head()\n\n\nA tibble: 6 × 2\n\n\ndptp\ndate\n\n\n&lt;dbl&gt;\n&lt;date&gt;\n\n\n\n\n31.500\n1987-01-01\n\n\n29.875\n1987-01-02\n\n\n27.375\n1987-01-03\n\n\n28.625\n1987-01-04\n\n\n28.875\n1987-01-05\n\n\n35.125\n1987-01-06\n\n\n\n\n\nThis is super useful if you have a table with prefixes, such as doc_.\nYou can also use more general regular expressions if necessary.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#aside-helper-functions",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#aside-helper-functions",
    "title": "Dplyr",
    "section": "Aside: Helper Functions",
    "text": "Aside: Helper Functions\nNote the use of the function ends_with() inside of the argument space for the function select() above.\nends_with() is an example of a “helper function” — a function that helps make Dplyr functions more effective.\nThere are many of these introduced by Dplyr.\nHere is a set of helper functions that can be especially useful with select():\n\n\n\n\n\n\n\n\nHelper Function\nDescription\nExample\n\n\n\n\nstarts_with()\nMatches variable names that start with a given prefix\nselect(data, starts_with(\"X\"))\n\n\nends_with()\nMatches variable names that end with a given suffix\nselect(data, ends_with(\"_2019\"))\n\n\ncontains()\nMatches variable names that contain a given string\nselect(data, contains(\"income\"))\n\n\nmatches()\nMatches variable names that match a given regular expression\nselect(data, matches(\"^X[1-3]$\"))\n\n\nnum_range()\nMatches variable names that match a pattern of prefix + number\nselect(data, num_range(\"X\", 1:3))\n\n\none_of()\nMatches variable names that are in a given set of names\nselect(data, one_of(c(\"var1\", \"var2\")))\n\n\neverything()\nMatches all variable names (used to reorder variables)\nselect(data, starts_with(\"X\"), everything())",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#filter",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#filter",
    "title": "Dplyr",
    "section": "filter()",
    "text": "filter()\nThe filter() function extracts subsets of rows from a data frame.\nWhereas select() is a column-wise operation, filter() is row-wise.\nThis function is similar to the existing subset() function in R but is quite a bit faster.\nSuppose we wanted to extract the rows of the chicago data frame where the levels of PM2.5 are greater than 30 (which is a reasonably high level), we could do this:\n\nchicago %&gt;%\n  filter(pm25tmean2 &gt; 30) %&gt;%\n  head()\n\n\nA tibble: 6 × 8\n\n\ncity\ntmpd\ndptp\ndate\npm25tmean2\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n23\n21.9\n1998-01-17\n38.10\n32.46154\n3.180556\n25.30000\n\n\nchic\n28\n25.8\n1998-01-23\n33.95\n38.69231\n1.750000\n29.37630\n\n\nchic\n55\n51.3\n1998-04-30\n39.40\n34.00000\n10.786232\n25.31310\n\n\nchic\n59\n53.7\n1998-05-01\n35.40\n28.50000\n14.295125\n31.42905\n\n\nchic\n57\n52.0\n1998-05-02\n33.30\n35.00000\n20.662879\n26.79861\n\n\nchic\n57\n56.0\n1998-05-07\n32.10\n34.50000\n24.270422\n33.99167\n\n\n\n\n\nCompare this to base R:\n\nhead(na.omit(chicago[(chicago$pm25tmean2 &gt; 30),]))\n\n\nA tibble: 6 × 8\n\n\ncity\ntmpd\ndptp\ndate\npm25tmean2\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n23\n21.9\n1998-01-17\n38.10\n32.46154\n3.180556\n25.30000\n\n\nchic\n28\n25.8\n1998-01-23\n33.95\n38.69231\n1.750000\n29.37630\n\n\nchic\n55\n51.3\n1998-04-30\n39.40\n34.00000\n10.786232\n25.31310\n\n\nchic\n59\n53.7\n1998-05-01\n35.40\n28.50000\n14.295125\n31.42905\n\n\nchic\n57\n52.0\n1998-05-02\n33.30\n35.00000\n20.662879\n26.79861\n\n\nchic\n57\n56.0\n1998-05-07\n32.10\n34.50000\n24.270422\n33.99167\n\n\n\n\n\nNote that we have to filter out the NA values, which Dplyr does for you.\nNote also that column names in Dply do not need to be prefixed by the data frame name; they are called directly.\nFor example, compare how the column pm25tmean2 is accessed below:\nchicago %&gt;% filter(pm25tmean2 &gt; 30)\nvs\nchicago[(chicago$pm25tmean2 &gt; 30),]\nWe can place an arbitrarily complex logical sequence inside of filter().\nFor example, we may extract the rows where PM2.5 is greater than \\(30\\) and temperature is greater than \\(80\\) degrees Fahrenheit.\n\nchicago %&gt;%\n    filter(pm25tmean2 &gt; 30 & tmpd &gt; 80) %&gt;%\n    select(date, tmpd, pm25tmean2) %&gt;%\n    head()\n\n\nA tibble: 6 × 3\n\n\ndate\ntmpd\npm25tmean2\n\n\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n1998-08-23\n81\n39.6000\n\n\n1998-09-06\n81\n31.5000\n\n\n2001-07-20\n82\n32.3000\n\n\n2001-08-01\n84\n43.7000\n\n\n2001-08-08\n85\n38.8375\n\n\n2001-08-09\n84\n38.2000\n\n\n\n\n\nHere’s a table of helper functions specifically associated with filter():\n\n\n\n\n\n\n\n\nHelper Function\nDescription\nExample\n\n\n\n\nbetween()\nCheck if a value lies between two other values.\nfilter(data, between(age, 18, 30))\n\n\nnear()\nCheck for near equality (useful for floating-point numbers).\nfilter(data, near(price, 19.99, tolerance = 0.01))\n\n\nisin() (or %in%)\nCheck if a value is in a set of values.\nfilter(data, region %in% c(\"East\", \"West\"))\n\n\nall_of()\nCheck for all of the variables, even if some don’t exist. Useful with character vectors.\nfilter(data, all_of(variables))\n\n\nany_of()\nCheck for any of the variables. Useful with character vectors.\nfilter(data, any_of(variables))\n\n\ncur_group_id()\nIdentify the current group inside group_by(). Useful for more complex filtering with groups.\nfilter(data, cur_group_id() == 1)",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#arrange",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#arrange",
    "title": "Dplyr",
    "section": "arrange()",
    "text": "arrange()\nWe use arrange() to reorder rows of a data frame according to one or more of the columns.\nThis normally called sorting.\nReordering rows of a data frame (while preserving corresponding order of other columns) is normally a pain to do in R.\nThe arrange() function simplifies the process quite a bit.\nHere we order the rows of the data frame by date in ascending order:\n\nchicago_by_date &lt;- chicago %&gt;%\n    arrange(date)\n\nchicago_by_date %&gt;% head()\n\n\nA tibble: 6 × 8\n\n\ncity\ntmpd\ndptp\ndate\npm25tmean2\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n31.5\n31.500\n1987-01-01\nNA\n34.00000\n4.250000\n19.98810\n\n\nchic\n33.0\n29.875\n1987-01-02\nNA\nNA\n3.304348\n23.19099\n\n\nchic\n33.0\n27.375\n1987-01-03\nNA\n34.16667\n3.333333\n23.81548\n\n\nchic\n29.0\n28.625\n1987-01-04\nNA\n47.00000\n4.375000\n30.43452\n\n\nchic\n32.0\n28.875\n1987-01-05\nNA\nNA\n4.750000\n30.33333\n\n\nchic\n40.0\n35.125\n1987-01-06\nNA\n48.00000\n5.833333\n25.77233\n\n\n\n\n\nWe can now check the first few rows\n\nchicago_by_date %&gt;%\n  select(date, pm25tmean2) %&gt;%\n  head(3)\n\n\nA tibble: 3 × 2\n\n\ndate\npm25tmean2\n\n\n&lt;date&gt;\n&lt;dbl&gt;\n\n\n\n\n1987-01-01\nNA\n\n\n1987-01-02\nNA\n\n\n1987-01-03\nNA\n\n\n\n\n\nand the last few rows.\n\nchicago_by_date %&gt;%\n  select(date, pm25tmean2) %&gt;%\n  tail(3)\n\n\nA tibble: 3 × 2\n\n\ndate\npm25tmean2\n\n\n&lt;date&gt;\n&lt;dbl&gt;\n\n\n\n\n2005-12-29\n7.45000\n\n\n2005-12-30\n15.05714\n\n\n2005-12-31\n15.00000\n\n\n\n\n\nColumns can be arranged in descending order too by using the desc() helper function.\n\nchicago %&gt;%\n  arrange(desc(date)) %&gt;%\n  head()\n\n\nA tibble: 6 × 8\n\n\ncity\ntmpd\ndptp\ndate\npm25tmean2\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n35\n30.1\n2005-12-31\n15.00000\n23.5\n2.531250\n13.25000\n\n\nchic\n36\n31.0\n2005-12-30\n15.05714\n19.2\n3.034420\n22.80556\n\n\nchic\n35\n29.4\n2005-12-29\n7.45000\n23.5\n6.794837\n19.97222\n\n\nchic\n37\n34.5\n2005-12-28\n17.75000\n27.5\n3.260417\n19.28563\n\n\nchic\n40\n33.6\n2005-12-27\n23.56000\n27.0\n4.468750\n23.50000\n\n\nchic\n35\n29.6\n2005-12-26\n8.40000\n8.5\n14.041667\n16.81944\n\n\n\n\n\nHere’s a table of helper functions specifically associated with arrange():\n\n\n\n\n\n\n\n\nHelper Function\nDescription\nExample\n\n\n\n\ndesc()\nOrder by descending instead of default ascending.\narrange(data, desc(salary))\n\n\nacross()\nApply to multiple columns, especially with c_across() in dplyr 1.0.0 and later.\narrange(data, across(starts_with(\"X\")))\n\n\nrow_number()\nCreate an index based on the order of rows.\nmutate(data, idx = row_number())\n\n\n\nNote that row_number() is often seen in mutate() for creating an index column based on ordering.\nThe across() function provides a more concise syntax for working with multiple columns.\nIt is useful in arrange() when you’re trying to order rows based on a selection of columns that match a certain criterion.\nMost of the magic with arrange() happens through the way you structure its arguments and not necessarily through a large set of helper functions.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#rename",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#rename",
    "title": "Dplyr",
    "section": "rename()",
    "text": "rename()\nRenaming a variable in a data frame in R is surprisingly hard to do!\nThe rename() function is designed to make this process easier.\nHere we select the names of the first five variables in the chicago data frame.\n\nchicago %&gt;% select(1:5) %&gt;% head(3)\n\n\nA tibble: 3 × 5\n\n\ncity\ntmpd\ndptp\ndate\npm25tmean2\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n31.5\n31.500\n1987-01-01\nNA\n\n\nchic\n33.0\n29.875\n1987-01-02\nNA\n\n\nchic\n33.0\n27.375\n1987-01-03\nNA\n\n\n\n\n\nThe dptp column represents the dew point temperature and the pm25tmean2 column the PM2.5 data.\nThese names are cryptic, so let’s rename them.\n\nchicago &lt;- chicago %&gt;%\n  rename(dewpoint = dptp, pm25 = pm25tmean2) \n\nchicago %&gt;%  \n  head(3)\n\n\nA tibble: 3 × 8\n\n\ncity\ntmpd\ndewpoint\ndate\npm25\npm10tmean2\no3tmean2\nno2tmean2\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n31.5\n31.500\n1987-01-01\nNA\n34.00000\n4.250000\n19.98810\n\n\nchic\n33.0\n29.875\n1987-01-02\nNA\nNA\n3.304348\n23.19099\n\n\nchic\n33.0\n27.375\n1987-01-03\nNA\n34.16667\n3.333333\n23.81548\n\n\n\n\n\nThe syntax inside the rename() function is to have the new name on the left-hand side of the = sign and the old name on the right-hand side.\nHere’s a table of helper functions that can be used with rename():\n\n\n\n\n\n\n\n\nHelper Function\nDescription\nExample\n\n\n\n\nstarts_with()\nMatch columns that start with a given prefix.\nrename(data, start_X = starts_with(\"X\")) (Note: This example would rename the first column that starts with “X” to “start_X”)\n\n\nends_with()\nMatch columns that end with a given suffix.\nrename(data, end_year = ends_with(\"_2021\"))\n\n\ncontains()\nMatch columns that contain a given string.\nrename(data, has_rate = contains(\"rate\"))\n\n\nmatches()\nMatch columns that match a given regular expression.\nrename(data, match_num = matches(\"^X[1-3]$\"))\n\n\neverything()\nMatch all columns.\nRarely used with rename(), but possible.\n\n\n\nIt’s worth noting that these helper functions will typically target the first column that meets the specified criterion.\nIf there are multiple columns that match the criterion (e.g., multiple columns that start with “X”), you’ll need to use these helpers with more precision or utilize other techniques.\nAlso, remember to always refer to the official Dplyr documentation as the package continues to evolve and new functionalities might be added over time.",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#mutate",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#mutate",
    "title": "Dplyr",
    "section": "mutate()",
    "text": "mutate()\nThe mutate() function creates new columns based on computations usually involving the other columns.\nFor example, with air pollution data, we often want to de-trend the data by subtracting the mean from the data.\nThis allows us to see whether a given day’s air pollution level is higher than or less than average.\nHere we create a pm25detrend variable that subtracts the mean from the pm25 variable.\nWe also compute the Z-score.\n\nchicago &lt;- chicago %&gt;%\n    mutate(pm25detrend = pm25 - mean(pm25, na.rm = TRUE),\n       pm25z = pm25detrend / sd(pm25, na.rm = TRUE))\n\nchicago %&gt;% tail()\n\n\nA tibble: 6 × 10\n\n\ncity\ntmpd\ndewpoint\ndate\npm25\npm10tmean2\no3tmean2\nno2tmean2\npm25detrend\npm25z\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;date&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\nchic\n35\n29.6\n2005-12-26\n8.40000\n8.5\n14.041667\n16.81944\n-7.830958\n-0.9003429\n\n\nchic\n40\n33.6\n2005-12-27\n23.56000\n27.0\n4.468750\n23.50000\n7.329042\n0.8426366\n\n\nchic\n37\n34.5\n2005-12-28\n17.75000\n27.5\n3.260417\n19.28563\n1.519042\n0.1746477\n\n\nchic\n35\n29.4\n2005-12-29\n7.45000\n23.5\n6.794837\n19.97222\n-8.780958\n-1.0095666\n\n\nchic\n36\n31.0\n2005-12-30\n15.05714\n19.2\n3.034420\n22.80556\n-1.173815\n-0.1349561\n\n\nchic\n35\n30.1\n2005-12-31\n15.00000\n23.5\n2.531250\n13.25000\n-1.230958\n-0.1415260\n\n\n\n\n\nNote how the new column name pm25detrend can be used immediately within the argument space of mutate().\nDplyr also has a related transmute() function.\nIt does the same thing as mutate() but then drops all non-transformed variables.\nHere we de-trend the PM10 and ozone (O3) variables.\n\nchicago_detrended &lt;- chicago %&gt;%\n  transmute(pm10detrend = pm10tmean2 - mean(pm10tmean2, na.rm = TRUE), \n            o3detrend = o3tmean2 - mean(o3tmean2, na.rm = TRUE),\n            o3z = o3detrend / sd(o3tmean2, na.rm = TRUE))\n\nchicago_detrended %&gt;% head()\n\n\nA tibble: 6 × 3\n\n\npm10detrend\no3detrend\no3z\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n0.1047939\n-15.18551\n-1.333702\n\n\nNA\n-16.13117\n-1.416756\n\n\n0.2714605\n-16.10218\n-1.414211\n\n\n13.1047939\n-15.06051\n-1.322724\n\n\nNA\n-14.68551\n-1.289789\n\n\n14.1047939\n-13.60218\n-1.194642\n\n\n\n\n\nNote that there are only three columns in the transmuted data frame.\nHere’s a table of helper functions specifically associated with mutate():\n\n\n\n\n\n\n\n\nHelper Function\nDescription\nExample\n\n\n\n\nif_else()\nA vectorized conditional operation (if-else).\nmutate(data, status = if_else(age &lt; 18, \"minor\", \"adult\"))\n\n\ncase_when()\nGeneralized multiple conditions for transformations.\nmutate(data, category = case_when(score &gt; 90 ~ \"A\", score &gt; 80 ~ \"B\", TRUE ~ \"C\"))\n\n\nlead()\nAccess the subsequent value in the column.\nmutate(data, next_value = lead(column_name))\n\n\nlag()\nAccess the preceding value in the column.\nmutate(data, previous_value = lag(column_name))\n\n\nrow_number()\nGenerate row numbers, often used with arrange().\nmutate(data, rank = row_number())\n\n\nrank(), min_rank(), dense_rank()\nDifferent types of ranking functions.\nmutate(data, rank = rank(score))\n\n\ncumsum(), cumprod(), cummin(), cummax()\nCumulative functions.\nmutate(data, cumulative_total = cumsum(total))\n\n\ncoalesce()\nReturn the first non-missing value among its arguments.\nmutate(data, combined = coalesce(col1, col2))\n\n\nna_if()\nReplace a specified value with NA.\nmutate(data, updated_col = na_if(column_name, \"replace_me\"))\n\n\nreplace_na()\nReplace NA values with a specified value.\nmutate(data, updated_col = replace_na(column_name, \"new_value\"))\n\n\nrecode()\nRecode or replace values in a column.\nmutate(data, recoded_col = recode(column_name, old=\"new\", ...))\n\n\nacross()\nApply a function across multiple columns (from dplyr 1.0.0).\nmutate(data, across(c(col1, col2), function_name))",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-02-Dplyr.html#group_by",
    "href": "notebooks/M11_RDplyr/M11-02-Dplyr.html#group_by",
    "title": "Dplyr",
    "section": "group_by()",
    "text": "group_by()\nThe group_by() function is used to generate summary or aggregate statistics from a data frame.\nIn conjunction with the group_by() function we often use the summarize() function.\nThe general operation here is a combination of:\n\nsplitting a table into separate pieces defined by a variable or group of variables (group_by()),\nthen applying a summary function across those subsets (summarize()),\nthen combining back into another table.\n\nThis pattern is called split, apply, and combine.\nIt is a fundamental pattern in data processing.\nFor example, in this air pollution dataset, you might want to know the average annual level of PM2.5.\nThe stratum is the year, which we can derive from the date variable.\nFirst, we can create a year variable using as.POSIXlt().\nThen we group on our new column and compute summary statistics for each year with the summarize() function.\n\nyears &lt;- chicago %&gt;%\n  mutate(year = as.POSIXlt(date)$year + 1900) %&gt;%\n  group_by(year) %&gt;%\n  summarize(pm25 = mean(pm25, na.rm = TRUE), \n          o3 = max(o3tmean2, na.rm = TRUE), \n          no2 = median(no2tmean2, na.rm = TRUE), .groups = \"drop\")\n\nyears %&gt;% head()\n\n\nA tibble: 6 × 4\n\n\nyear\npm25\no3\nno2\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n1987\nNaN\n62.96966\n23.49369\n\n\n1988\nNaN\n61.67708\n24.52296\n\n\n1989\nNaN\n59.72727\n26.14062\n\n\n1990\nNaN\n52.22917\n22.59583\n\n\n1991\nNaN\n63.10417\n21.38194\n\n\n1992\nNaN\n50.82870\n24.78921\n\n\n\n\n\nTo see why we add \\(1900\\) in the preceding mutation, note that the date function returns just the last two digits of the year.\n\nas.POSIXlt(chicago$date)$year %&gt;% head()\n\n\n878787878787\n\n\nNote in the process, we implicitly created a separate data frame that splits the original data frame by year, which is then passed to summarize().\nsummarize() then returns a data frame with columns for year and the annual averages of pm25, o3, and no2.\nIn a slightly more complicated example, we might want to know what are the average levels of ozone o3 and nitrogen dioxide no2 within quantiles of pm25.\nWe could do this with a regression model, but we can also do this quickly with group_by() and summarize().\nFirst, we can create a categorical variable of pm25 divided into quantiles.\n\nqq &lt;- quantile(chicago$pm25, seq(0, 1, 0.2), na.rm = TRUE)\nprint(qq)\n\n    0%    20%    40%    60%    80%   100% \n 1.700  8.700 12.375 16.700 22.610 61.500 \n\n\nThen we group the data frame by the pm25.quint variable and compute the mean of o3 and no2 within quantiles of pm25.\n\nchicago %&gt;%\n  mutate(pm25.quint = cut(pm25, qq)) %&gt;%\n  group_by(pm25.quint) %&gt;%\n  summarize(o3 = mean(o3tmean2, na.rm = TRUE), \n          no2 = mean(no2tmean2, na.rm = TRUE),\n          .groups = \"drop\")\n\n\nA tibble: 6 × 3\n\n\npm25.quint\no3\nno2\n\n\n&lt;fct&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n(1.7,8.7]\n21.66401\n17.99129\n\n\n(8.7,12.4]\n20.38248\n22.13004\n\n\n(12.4,16.7]\n20.66160\n24.35708\n\n\n(16.7,22.6]\n19.88122\n27.27132\n\n\n(22.6,61.5]\n20.31775\n29.64427\n\n\nNA\n18.79044\n25.77585\n\n\n\n\n\nFrom the table, it seems there isn’t a strong relationship between pm25 and o3, but there appears to be a positive correlation between pm25 and no2.\nMore sophisticated statistical modeling can help to provide precise answers to these questions, but a simple application of Dplyr functions can often get you most of the way there.\nHere is another example:\n\nchicago %&gt;%  \n  mutate(month = as.POSIXlt(date)$mon + 1) %&gt;% \n  group_by(month) %&gt;%                              # SPLIT\n  summarize(pm25 = mean(pm25, na.rm = TRUE),       # APPLY \n    o3 = max(o3tmean2, na.rm = TRUE), \n    no2 = median(no2tmean2, na.rm = TRUE),\n    .groups = \"drop\") \n                                                    # COMBINE (in the result)\n\n\nA tibble: 12 × 4\n\n\nmonth\npm25\no3\nno2\n\n\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n\n\n\n\n1\n17.76996\n28.22222\n25.35417\n\n\n2\n20.37513\n37.37500\n26.78034\n\n\n3\n17.40818\n39.05000\n26.76984\n\n\n4\n13.85879\n47.94907\n25.03125\n\n\n5\n14.07420\n52.75000\n24.22222\n\n\n6\n15.86461\n66.58750\n25.01140\n\n\n7\n16.57087\n59.54167\n22.38442\n\n\n8\n16.93380\n53.96701\n22.98333\n\n\n9\n15.91279\n57.48864\n24.47917\n\n\n10\n14.23557\n47.09275\n24.15217\n\n\n11\n15.15794\n29.45833\n23.56537\n\n\n12\n17.52221\n27.70833\n24.45773\n\n\n\n\n\nHere’s a table of helper functions specifically associated with group_by():\n\n\n\n\n\n\n\n\nHelper Function\nDescription\nExample\n\n\n\n\nadd_tally()\nAdds a column with the count of each group (equivalent to adding a count with mutate() after a group_by()).\ngroup_by(data, group_var) %&gt;% add_tally()\n\n\ngroup_size()\nReturns the size of each group.\ngroup_by(data, group_var) %&gt;% summarise(size = group_size())\n\n\nntile()\nCreates rank percentiles within groups.\ngroup_by(data, group_var) %&gt;% mutate(perc = ntile(score, 4))\n\n\ncur_group_id()\nGives an integer identifier for the current group.\ngroup_by(data, group_var) %&gt;% filter(cur_group_id() == 1)\n\n\ncur_group_rows()\nProvides row indices for the current group.\nUsed internally, but can be useful for advanced operations.\n\n\ngroup_map(), group_modify(), group_walk()\nFunctions to iterate over groups, modify them or walk them with side effects.\ngroup_map(data, ~ head(.x, 2)) shows the first two rows of each group.\n\n\n\nIt’s worth noting that group_by() often works in tandem with other verbs, so the real power comes from the combined operations.\nFor example, after grouping data, one often uses summarise() to calculate summary statistics for each group.\nThe combination of these functions and their associated helpers allow for a wide range of group-wise data manipulation tasks.\nBased on Peng 2022",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Dplyr</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-00-AGrammarOfGraphics.html",
    "href": "notebooks/M12_RViz/M12-00-AGrammarOfGraphics.html",
    "title": "GGPlot and the Grammar of Graphics",
    "section": "",
    "text": "Programming for Data Science\nGGPlot is the graphics package associated with the Tidyverse.\nIn this notebook, we will present a quick overview of the design principles behind the package.\nAs with Dplyr, GGPlot2 is a an entirely new system that supplants the older graph functions that are built into R.\nIt is founded on a principled analysis of its domain and from this develops a basic grammar which can then be expressed in R.\nJust as Dplyr is built on a grammar of data consisting of pipable verbs that correspond to the logic data transformation, GGPlot2 is built on a grammar of graphics consisting of nouns that correspond to the architecture of a graphic (aka plot).\nThe phrase “grammar of graphics” actually comes from the book by that name written by statistician and computer scientist Leland Wilkinson in 1999 and later revised:\n\nIt is worth reading if you want to get a solid grounding in visualization, which belongs to the design area of data science.\nThe Grammar of Graphics takes an object-oriented approach to visualization and formalizes two main principles:\n\nGraphics are built out of distinct layers.\nIn each layer, meaningful plots are constructed through mappings of data onto aesthetics.\n\nThe primary layers are these:\n\nAccording to Wickham, who adopted these principles and applied them to R,\n\nA grammar of graphics is a tool that enables us to concisely describe the components of a graphic. Such a grammar allows us to move beyond named graphics (e.g., the “scatterplot”) and gain insight into the deep structure that underlies statistical graphics (Wickham 2012).\n\nWickham takes this idea and develops it into this:\n\nSource (see also ScienceCraft).\nIn this model, everything starts with data.\nThen data are mapped on aesthetics within geometries.\n\nGeometries are geometric things like points, lines, and bars.\nAesthetics are visual things like position, size, color and shape.\n\nAlso note that aesthetics make use of visual channels to signify features and their properties.\n\nSize can mean greater than, which is good for numeric scale but not categories\nColor can signify things like value, e.g. via red : dangerous : : green : safe.\n\nThese compose the primary layers.\nThe other layers apply downstream modifications that add more information and style to the graph.",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>GGPlot and the Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-01-GettingStartedWithGGPlot.html",
    "href": "notebooks/M12_RViz/M12-01-GettingStartedWithGGPlot.html",
    "title": "Getting Started with GGPlot2",
    "section": "",
    "text": "Programming for Data Science\nIn this notebook, we look at GGPlot2, the specific graphics package associated with the Tidyverse.\nIt implements the logic of the grammar of graphics model described in the previous notebook.\n\nA First Plot\nEverything starts with getting ggplot(), which is imported when you import tidyverse.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nGGPlot gives lots of warning messages.\nFor sake of clarity, we are going to turn these off for now.\nWe’re also going to the set the default size of our plots so they display better.\nWe do this with the options() function we saw earlier.\n\noptions(warn=-1)\noptions(repr.plot.width = 16, repr.plot.height = 10)\n\nHere is a basic graph — a scatterplot comparing two features in the iris dataset.\nThe functions and arguments are broken out so you can see how the grammar is implemented:\n\niris %&gt;%\n    ggplot(\n        mapping = aes(x = Sepal.Length, y = Sepal.Width)\n    ) + \n    geom_point(\n        size = 5, \n        aes(color = Species)\n    )\n\n\n\n\n\n\n\n\nHere is an alternate way to build the graph:\n\niris %&gt;%\n    ggplot() +\n    aes(x = Sepal.Length, y = Sepal.Width) + \n    geom_point(size = 5) +\n    aes(color = Species)\n\n\n\n\n\n\n\n\nNote how we can pull the aes() functions out of the geom_ and mapping() functions.\nNote that to create a scatterplot, we did not use a function like geom_scatterplot().\nInstead, we constructed one from scratch using the buildings blocks according to a simple design pattern.\nWe will see that some plot types are constructred this way while others have named functions.\nFor example, a histogram is created with geom_hist().\n\n\nHow it Works\nThe ggplot() function starts by creating a coordinate system that you can add layers to.\nYou can think of it as providing a base layer or canvas.\nOther layers are added by calling geometry functions.\nFor example, geom_point creates a point-based visualization.\nFor each layer, we can apply an aesthetic mapping.\nHere’s a description of what we just plotted:\ngglot() + # Build the coordinate system, i.e. the base layer canvas\n\naes(x = Sepal.Length, y = Sepal.Width) + # Map two features onto the `x` and `y` axes\n\ngeom_point(size = 3) + # Define a geometry that gives visible form to `x` and `y` coordinates\n\naes(color = Species) # Map colors onto coordinates by a third dimension\nNote that the coordinate system can be changed after the graph is initiated.\nThere are many geom_ functions:\n\ngeom_point()\ngeom_bar()\ngeom_histogram()\ngeom_boxplot()\ngeom_violin()\ngeom_density()\n\netc.\nThese can be layered on top of each other in a variety of ways.\nThere are also many channels that can used to represent numeric and categorical features with aes():\n\nx and y positions (in a two-dimensional system)\nColor\nSize\nShape\nText\n\n\n\nA Two Layered Plot\nHere we have a plot with two layers.\nThe second layer is created by a stat_ function.\nThis function internally applies a geom_ function to a statistical transformation to the data.\n\niris %&gt;%\n    ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + \n    geom_point(size = 5, aes(color = Species)) + \n    stat_smooth(method = lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nThe tilde sign ~ means “as a function of” — in this case, y is being plotted as function of x.\nInterestingly, if we pull the aes() function out of geom_point(), we get a different plot.\n\niris %&gt;%\n    ggplot() +\n    aes(color=Species) +\n    geom_point(size = 5) +\n    aes(x = Sepal.Length, y = Sepal.Width) +\n    stat_smooth(method = lm)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\nThe + Operator\nYou will notice the use of the + operator to connect GGPlot functions together to produce a final product.\nTheses are not quite the same as pipes %&gt;%.\nWhereas pipes feed data from one function to another, the + operation is a form of method chaining.\nWe saw method chaining in Pandas.\nKeep in mind: the + always goes at the end of a line, never at the beginning.\n\n\nFaceting\nGGPlot also provides plot faceting.\nFaceting is the visual equivalent of grouping in the split-apply-combine pattern.\nJust as with grouping, the distinct values in a data feature are used to divide the visualization into groups.\nEach group takes the same form but shows a different subset of data.\n\niris %&gt;%\n    ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + \n    geom_point(size = 5, aes(color = Species)) + \n    stat_smooth(method = lm) +\n    facet_wrap(facets = vars(Species))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nBy the way, this is an example of Simpson’s Paradox.\nThe overall trend is downward, but each group trend upward.\nWe can see this by layering the regression line for the aggregate over the individual ones.\n\niris %&gt;%\n    ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + \n    geom_point(size = 5, aes(color=Species)) + \n    stat_smooth(method = lm, se=F) +\n    stat_smooth(method = lm, se=F, aes(color=Species))\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nNote, the se argument in stat_smooth() toggles whether or not to display the shaded confidence intervals.\n\n\nVisualizing Dimensions\nAesthetics and facets are ways to represent extra dimensions without resorting to increasing the number of axes in our plots.\nFor example, instead of using color or facets to represent species, we might have considered a third axis z to represent this feature.\nWe tend to avoid going beyond two axes in our plots and so resort to other visual devices.\n\n\nBar Chart\nLet’s look at some other geometries.\nHere is a simple bar chart made with gemo_bar().\n\nmtcars %&gt;% \n    ggplot(aes(x = cyl)) +\n    geom_bar(fill = 'limegreen')\n\n\n\n\n\n\n\n\n\n\nHistogram\nThe function geom_hist() will generate a histogram.\nNote that this function actually performs a behind-the-scenes data transformation, which goes beyond mapping the data.\nWe typically see this with the stat_ family of functions.\n\nmtcars %&gt;% \n    ggplot(aes(x = mpg)) + \n    geom_histogram(bins = 20, aes(fill = factor(cyl))) + \n    labs(title=\"Histogram\") \n\n\n\n\n\n\n\n\nNote the use of the lab() function to provide a title.\n\n\nDensity Plot\nHere is a kernel density estimate (KDE) plot made with geom_density().\nA KDE plot is a smoothed version of a histogram.\nAs with geom_histogram(), this function does some behind-the-scenes compuation and then plots the result.\n\nmtcars %&gt;% \n    ggplot(aes(x = mpg)) + \n    geom_density(size = 2, aes(fill = factor(cyl))) + \n    labs(title=\"Density plot\") \n\n\n\n\n\n\n\n\n\n\nBoxplot\nThe function geom_boxplot() gives a classic boxplot, showing the mean, quantiles, and outliers of each variable.\nNote the arguments used — they control how the outliers are rendered.\nNotice we also pull out the aes() function for clarity; it could have remained within the geometry function’s argument space.\n\nmtcars %&gt;% \n    ggplot(aes(x = factor(cyl), y = mpg)) +\n    geom_boxplot(\n        width = 0.5, \n        outlier.colour = \"dodgerblue\", \n        outlier.size = 4, \n        outlier.shape = 16, \n        outlier.stroke = 2, \n    ) + \n    aes(fill = factor(cyl)) +\n    labs(title = \"Box plot\")\n\n\n\n\n\n\n\n\n\n\nViolin Plot\nThis is a violin plot using geom_violin().\nA violin plot is something like a smoothed version of a boxplot.\nThis version is untrimmed, i.e. we set trim to FALSE.\n\nmtcars %&gt;%\n    ggplot(aes(factor(cyl), mpg)) + \n    geom_violin(width = 0.5, trim = F) + \n    aes(fill = factor(cyl)) +\n    labs(title = \"Violin plot\")\n\n\n\n\n\n\n\n\n\n\nHeatmap\nTo create a heatmap, we use geom_tile().\nTo use this function, we first need to reshape our data into narrow form.\nHere, we take a correlation matrix among the features of mtcars.\n\ncorr &lt;- round(cor(mtcars), 2)\ncorr\n\n\nA matrix: 11 × 11 of type dbl\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\nmpg\n1.00\n-0.85\n-0.85\n-0.78\n0.68\n-0.87\n0.42\n0.66\n0.60\n0.48\n-0.55\n\n\ncyl\n-0.85\n1.00\n0.90\n0.83\n-0.70\n0.78\n-0.59\n-0.81\n-0.52\n-0.49\n0.53\n\n\ndisp\n-0.85\n0.90\n1.00\n0.79\n-0.71\n0.89\n-0.43\n-0.71\n-0.59\n-0.56\n0.39\n\n\nhp\n-0.78\n0.83\n0.79\n1.00\n-0.45\n0.66\n-0.71\n-0.72\n-0.24\n-0.13\n0.75\n\n\ndrat\n0.68\n-0.70\n-0.71\n-0.45\n1.00\n-0.71\n0.09\n0.44\n0.71\n0.70\n-0.09\n\n\nwt\n-0.87\n0.78\n0.89\n0.66\n-0.71\n1.00\n-0.17\n-0.55\n-0.69\n-0.58\n0.43\n\n\nqsec\n0.42\n-0.59\n-0.43\n-0.71\n0.09\n-0.17\n1.00\n0.74\n-0.23\n-0.21\n-0.66\n\n\nvs\n0.66\n-0.81\n-0.71\n-0.72\n0.44\n-0.55\n0.74\n1.00\n0.17\n0.21\n-0.57\n\n\nam\n0.60\n-0.52\n-0.59\n-0.24\n0.71\n-0.69\n-0.23\n0.17\n1.00\n0.79\n0.06\n\n\ngear\n0.48\n-0.49\n-0.56\n-0.13\n0.70\n-0.58\n-0.21\n0.21\n0.79\n1.00\n0.27\n\n\ncarb\n-0.55\n0.53\n0.39\n0.75\n-0.09\n0.43\n-0.66\n-0.57\n0.06\n0.27\n1.00\n\n\n\n\n\nThe we melt it into narrow form:\n\nnarrow &lt;- reshape2::melt(corr)\n\n\nnarrow %&gt;% head()\n\n\nA data.frame: 6 × 3\n\n\n\nVar1\nVar2\nvalue\n\n\n\n&lt;fct&gt;\n&lt;fct&gt;\n&lt;dbl&gt;\n\n\n\n\n1\nmpg\nmpg\n1.00\n\n\n2\ncyl\nmpg\n-0.85\n\n\n3\ndisp\nmpg\n-0.85\n\n\n4\nhp\nmpg\n-0.78\n\n\n5\ndrat\nmpg\n0.68\n\n\n6\nwt\nmpg\n-0.87\n\n\n\n\n\nNow we can pass the narrow data frame to our plot constructor:\n\nnarrow %&gt;% ggplot() +\n    aes(x = Var1, y = Var2, fill = value, label = value) +\n    geom_tile() + \n    geom_text(color = \"white\", size = 8) + \n    labs(title=\"mtcars - Correlation plot\") + \n    theme(text=element_text(size = 20), legend.position = \"none\")\n\n\n\n\n\n\n\n\nNote the use of theme() function to remove the legend and alter the font size in the result.\n\n\nAssigning to a Variable\nWe can assign plots to variables and build them incrementally.\n\ngg &lt;- iris %&gt;% ggplot()\ngg\n\n\n\n\n\n\n\n\n\ngg &lt;- gg + aes(x = Sepal.Length, y = Sepal.Width)\ngg\n\n\n\n\n\n\n\n\n\ngg &lt;- gg + geom_point(size=5)\ngg\n\n\n\n\n\n\n\n\n\ngg &lt;- gg + aes(color = Species)\ngg\n\n\n\n\n\n\n\n\n\ngg &lt;- gg + stat_smooth(method = 'lm')\ngg\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\nDesign Pattern\nLet’s use this ability to assign plots to variables to demonstrate another design pattern.\nOften, you will have data of a certain kind and you want to visualize it various ways.\nYou may not be sure of the most effective visualization, so you want to play around.\nFor example, you may want to explore the relationship between two continuous variables.\nThis relationship can visualized using a variety of geometries.\nSo, we may begin by assigning the basic plot to a variable and then applying different geometries to it.\n\nmy_gg &lt;- ggplot(mpg, aes(cty, hwy))\nmy_gg\n\n\n\n\n\n\n\n\nThe object my_gg just contains a blank canvas with two labeled and scaled axes.\nHere we draw a simple scatter plot by adding a geometry to our object.\n\nmy_gg + geom_point(size=5, color='red')\n\n\n\n\n\n\n\n\nHere we show the coordinates as text labels showing cty with a rectangle background.\nThe object remains unchanged by the previous visualization; we are just swapping out geometries.\n\nmy_gg + geom_label(aes(label = cty), nudge_x = 1, nudge_y = 1, color = 'blue') \n\n\n\n\n\n\n\n\nHere is a simple regression line.\n\nmy_gg + geom_smooth(method = lm) \n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAnd here is a boxplot …\n\nmy_gg + geom_boxplot()\n\n\n\n\n\n\n\n\nThe geom_density2d() function shows a \\(2\\)D kernel density estimation overlaying a scatterplot.\n\nmy_gg + geom_point() + geom_density2d()\n\n\n\n\n\n\n\n\nAnd here is filled line graph.\n\nmy_gg + geom_area(fill='red')\n\n\n\n\n\n\n\n\n\n\nConclusion\nThis notebook just scratches the surface of what you can do with GGPlot.\nThere are many other features we have not covered, such as changing coordinates.\nIn addition, there are many more geometry and statistics layers we have not shown.\nHowever, hopefully you understanding something of the logic of GGPlot and have gained insight into how graphics are built.\nThis should enable you to make informed guesses and asked effective questions as you develop your knowledge of this powerful toolkit.",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Getting Started with GGPlot2</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-02-RMarkdown.html",
    "href": "notebooks/M12_RViz/M12-02-RMarkdown.html",
    "title": "R Markdown",
    "section": "",
    "text": "Programming for Data Science\n\nLiterate Programming\nR provides a notebook style coding environment similar to Jupyter called R Markdown.\nIt follows the literate programming paradigm of inter-leaving text and runnable code.\nAs with Jupyter, they can be used interactively or as exported documents into standard formats.\nR Markdown files consists of the three types of element:\n\nMetadata, written in YAML (at the top of the file).\nText, written in Markdown.\nCode, written in one of several supported programming languages.\n\nAll of these are plain text and live in the same .Rmd file.\n\n\nMarkdown\nAs the name implies, R Markdown files uses a version of Markdown to create the text components and define the code blocks.\nMardown is a simplified version of HTML markup that uses typographic symbols and line spaces instead of angle brackets.\nFor example, instead of writing this in HTML:\n\nThis is is header\n\n\nThis paragraph defines a link/\n\nYou would write this:\n\n\nThis is a header\nThis paragraph defines a link.\nThe markdown gets converted into HTML by a viewer or converter at display time.\n\n\nCode\nThe code blocks are delimmited by three backtacks ``` with a language specified in braces.\nFor example, to run a block of R code, you would enter this:\nx &lt;- 10\nprint(x)\nR Markdown also supports running code in other languages in the same document.\nTo run a Python block, you could do something like this:\nx = 10\nprint(x)\nIn RStudio, these blocks of code can be executed in place, with results output in below the cell, as with Jupyter.\n\n\nComparison to Jupyter\nR Markdown files are optimized to be published documents.\nJupyter notebooks are meant primarily to be interactive environments.\nR Markdown files are plain text.\nJupyter notebooks are written in JavaScript.\nJavaScript is the native programming language of web browsers; the notebook format is executable code that can be integrated into a web application.\n\n\nVarieties of R Markdown outputs\nR Markdown is designed to be output to several formats, including notebooks, documents, presentations, and interactive applications.\nNotebooks and documents can be output as HTML, PDF, or Word files.\nPresentations may be output in IOSlides, Beamer, or PowerPoint format.\nInteractive applications are interactive apps that can be published on the web with a framework called Shiny.\n\n\nKnitting\nKnitting is the process of compiling all the code and visual assets of an R Markdown into a single file.\n\n\nPublishing\nRMarkdown has publication in mind as an outcome. RStudio allows you to publish in these destinations:\n\nRPubs\nR Studio Connect\n\n\n\nOutputting\nThere are two ways to set the output of a document:\n\nPermanently, by modifying the YAML header:\n\n---\ntitle: \"Viridis Demo\"\noutput: html_document\n---\n\nTransiently, by calling rmarkdown::render() by hand:\n\nrmarkdown::render(“diamond-sizes.Rmd”, output_format = “word_document”)\nThis is useful if you want to programmatically produce multiple types of output.\nRStudio’s knit button renders a file to the first format listed in its output field.\n\n\nOutput options\nTo override the default parameter values, you need to use an expanded output field. For example, if you wanted to render an html_document with a floating table of contents, you’d use:\n---\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n---\nYou can even render to multiple outputs by supplying a list of formats:\n---\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n  pdf_document: default\n---\nNote the special syntax if you don’t want to override any of the default options.\n\n\nHow It Works",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>R Markdown</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-03-Qplot-and-Plotly.html",
    "href": "notebooks/M12_RViz/M12-03-Qplot-and-Plotly.html",
    "title": "Plotly and GGPlotly",
    "section": "",
    "text": "Programming for Data Science\nRelated to GGPlot are two other visualization libraries that are worth looking into.\nPlotly is a cross platform visualization library that is great for making interactive plots.\nAnd GGPlotly provides a convenient way to translate GGPlot plots into Ploty plots.\nLet quickly take a look at these.\nFirst, lets install the Tidyverse and turn off warnings.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\noptions(warn = -1) # Turn off warnings\n\n\nPlotly in R\nPlotly runs on R, Python, JavaScript, and Matlab.\nIt uses the same model in each language, so learning it in R can help you use it in these other languages.\nWe first install it and then import it.\n\n# install.packages(\"plotly\")\n\n\nlibrary(plotly)\n\n\nAttaching package: ‘plotly’\n\n\nThe following object is masked from ‘package:ggplot2’:\n\n    last_plot\n\n\nThe following object is masked from ‘package:stats’:\n\n    filter\n\n\nThe following object is masked from ‘package:graphics’:\n\n    layout\n\n\n\n\nHere is a list of the kinds of plots you can create in Plotly:\nTypes of plots\n'bar', 'barpolar', 'box', 'candlestick', 'carpet', 'choropleth', 'choroplethmapbox', 'cone', 'contour', 'contourcarpet', 'densitymapbox', 'funnel', 'funnelarea', 'heatmap', 'heatmapgl', 'histogram', 'histogram2d', 'histogram2dcontour', 'icicle', 'image', 'indicator', 'isosurface', 'mesh3d', 'ohlc', 'parcats', 'parcoords', 'pie', 'pointcloud', 'sankey', 'scatter', 'scatter3d', 'scattercarpet', 'scattergeo', 'scattergl', 'scattermapbox', 'scatterpolar', 'scatterpolargl', 'scatterternary', 'splom', 'streamtube', 'sunburst', 'surface', 'table', 'treemap', 'violin', 'volume', 'waterfall'\nLet’s create a scatter plot.\nNote how we just specify the type and set the relevant arguments. Also note also the ~ prefix to feature names.\n\nfig1 &lt;- mpg %&gt;%\n    plot_ly(\n        x         = ~hwy, \n        y         = ~cty, \n        type      = 'scatter', \n        size      = ~displ, \n        color     = ~class,\n        hovertext = ~manufacturer,\n        mode      = \"markers\",\n        height    = 500, width = 750)\n\n\nfig1\n\n\n\n    \n        \n        \n\n\n\n\n\n\n\n    \n    \n        \n\n    \n\n\n\nHere we visualize the iris data set.\n\nfig2 &lt;- iris %&gt;%\n    plot_ly(\n        x         = ~Petal.Length, \n        y         = ~Petal.Width, \n        size      = ~Sepal.Length, \n        color     = ~Sepal.Width,\n        symbol    = ~Species,\n        type      = \"scatter\", \n        mode      = \"markers\",\n        height    = 500, width = 750)\n\n\nfig2\n\n\n\n    \n        \n        \n\n\n\n\n\n\n\n    \n    \n        \n\n    \n\n\n\n\n\nGGPlotly\nGGPlotly by Plotly lets you can convert your GGPlot figures into interactive ones powered by the Plotly library.\nIt works by calling ggplotly() with no argument right after a GGPlot definition.\nHere’s a quick example.\n\ndf &lt;- data.frame(\n    x = rnorm(100, mean = 0, sd = 1),\n    y = rnorm(100, mean = 5, sd = 10)\n)\n\n\ndf %&gt;% ggplot() + \n    aes(x, y) +\n    geom_point()\n\n\n\n\n\n\n\n\n\nggplotly()\n\n\n\n    \n        \n        \n\n\n\n\n\n\n\n\n    \n    \n        \n\n    \n\n\n\n\nggplotly(height=500, width=500)\n\n\n\n    \n        \n        \n\n\n\n\n\n\n\n    \n    \n        \n\n    \n\n\n\nYou also pass it a plot that was assigned to a variable.\nIn both cases, you can then add ploty features to your graph.\n\np &lt;- df %&gt;% ggplot() + \n    aes(x, y) +\n    geom_point(color='red')\n\n\nggplotly(p, height=500, width=500)",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>Plotly and GGPlotly</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-04-Plotnine.html",
    "href": "notebooks/M12_RViz/M12-04-Plotnine.html",
    "title": "GGPlot in Python with Plotnine",
    "section": "",
    "text": "GGPlot in Python\nThere are two ports of GGPlot2 to Python: pygg and plotnine.\nThe first seems to have stopped development and is much less used.\nLet’s look at Plotnine.\n# ! conda install -c conda-forge plotnine -y\nfrom plotnine import *\nfrom plotnine.data import mpg\nOur old friend, mpg in Python:\nmpg\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n229\nvolkswagen\npassat\n2.0\n2008\n4\nauto(s6)\nf\n19\n28\np\nmidsize\n\n\n230\nvolkswagen\npassat\n2.0\n2008\n4\nmanual(m6)\nf\n21\n29\np\nmidsize\n\n\n231\nvolkswagen\npassat\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\nmidsize\n\n\n232\nvolkswagen\npassat\n2.8\n1999\n6\nmanual(m5)\nf\n18\n26\np\nmidsize\n\n\n233\nvolkswagen\npassat\n3.6\n2008\n6\nauto(s6)\nf\n17\n26\np\nmidsize\n\n\n\n\n234 rows × 11 columns",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>GGPlot in Python with Plotnine</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-04-Plotnine.html#a-simple-bar-chart",
    "href": "notebooks/M12_RViz/M12-04-Plotnine.html#a-simple-bar-chart",
    "title": "GGPlot in Python with Plotnine",
    "section": "A Simple Bar Chart",
    "text": "A Simple Bar Chart\n\n(ggplot(mpg)            # defining what data to use\n    + aes(x='class')    # defining what variable to use\n    + geom_bar(size=20) # defining the type of plot to use\n)\n\n\n\n\n\n\n\n\nNotice that aes() is not a helper function (a function in the argument space).\nAlso, R dots become _ in the argument names.\nNote that we don’t have to use the syntax above, which groups the functions in a single expression with (...).\nWe can do this:\n\nggplot(mpg) + aes(x='class') + geom_bar(size=20)\n\n\n\n\n\n\n\n\nOr this:\n\nggplot(mpg) + \\\n    aes(x='class') + \\\n    geom_bar(size=20)\n\n\n\n\n\n\n\n\nNote that none of these are like R due to differing white space rules.",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>GGPlot in Python with Plotnine</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-04-Plotnine.html#aesthetics",
    "href": "notebooks/M12_RViz/M12-04-Plotnine.html#aesthetics",
    "title": "GGPlot in Python with Plotnine",
    "section": "Aesthetics",
    "text": "Aesthetics\nPlotnine supports using color and size on which to map features with aes().\n\nggplot(mpg) + \\\n    aes(x = 'drv', y = 'cty', color = 'class', size='cyl') + \\\n    geom_point()",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>GGPlot in Python with Plotnine</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-04-Plotnine.html#facets",
    "href": "notebooks/M12_RViz/M12-04-Plotnine.html#facets",
    "title": "GGPlot in Python with Plotnine",
    "section": "Facets",
    "text": "Facets\nYou can also create facets with facet_wrap().\n\n(ggplot(mpg)         \n + aes(x='drv', y='cty', color='class', size='cyl')\n + geom_point()\n + facet_wrap('class')\n + theme(legend_position = \"none\")\n)",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>GGPlot in Python with Plotnine</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming for Data Science Bootcamp",
    "section": "",
    "text": "Welcome\nWelcome to the companion text for Programming for Data Science Bootcamp.\nThis text is designed to provide all the content necessary to take the Programming for Data Science Bootcamps course at UVA’s School of Data Science.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/on-data.html",
    "href": "notebooks/M02_BasicPython/on-data.html",
    "title": "Data and Code",
    "section": "",
    "text": "Code should be simple\nAn important principle for writing effective and intelligible code is that code should be simple — to quote Einstein, as simple as possible but no simpler.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and Code</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/on-data.html#code-should-be-simple",
    "href": "notebooks/M02_BasicPython/on-data.html#code-should-be-simple",
    "title": "Data and Code",
    "section": "",
    "text": "A contributing factor to code simplicity is how it is related to the data it is designed to process.\nThis relationship depends largely on how the data are structured.\nA program is always written with data in mind — what kind of data it is and how it is structured.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and Code</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/on-data.html#simplicity-of-code-follows-from-the-structure-of-data",
    "href": "notebooks/M02_BasicPython/on-data.html#simplicity-of-code-follows-from-the-structure-of-data",
    "title": "Data and Code",
    "section": "Simplicity of code follows from the structure of data",
    "text": "Simplicity of code follows from the structure of data\nThere is a view among programmers which, although not orthodoxy, is commonplace.\n\nIt is the idea that the complexity of a program — its algorithms — is a function of the quality of the data structure it processes.\nIf a data structure is not well designed, algorithms may be excessively complex and hard to understand.\nHowever if a data structure is well designed, the algorithms that process them are more robust and intelligible.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and Code</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/on-data.html#supporting-references",
    "href": "notebooks/M02_BasicPython/on-data.html#supporting-references",
    "title": "Data and Code",
    "section": "Supporting References",
    "text": "Supporting References\nConsider these quotes cited in an essay on Data Structures. by Igor Budasov, reproduced here:\nHere’s a quote from Linus Torvalds in 2006:\n\nI’m a huge proponent of designing your code around the data, rather than the other way around, and I think it’s one of the reasons git has been fairly successful . . . I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his [sic] code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships.\n\nWhich sounds a lot like Eric Raymond’s “Rule of Representation” from 2003:\n\nFold knowledge into data, so program logic can be stupid and robust.\n\nWhich was just his summary of ideas like this one from Rob Pike in 1989:\n\nData dominates. If you’ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.\n\nWhich cites Fred Brooks from 1975:\n\nRepresentation is the Essence of Programming\n\nBeyond craftsmanship lies invention, and it is here that lean, spare, fast programs are born. Almost always these are the result of strategic breakthrough rather than tactical cleverness. Sometimes the strategic breakthrough will be a new algorithm, such as the Cooley-Tukey Fast Fourier Transform or the substitution of an n log n sort for an n 2 set of comparisons.\n\n\nMuch more often, strategic breakthrough will come from redoing the representation of the data or tables. This is where the heart of your program lies. Show me your flowcharts and conceal your tables, and I shall be continued to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data and Code</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/python-object-types.html",
    "href": "notebooks/M02_BasicPython/python-object-types.html",
    "title": "Python Object Types",
    "section": "",
    "text": "Python is organized into a hierarchy of object types. Sometimes, these are just call types.\nObjects are the basic unit out of which the language is constructed.\nWe’ll learn about objects later – what they are and how to create your own – but for now just understand that they have two main things associated with them:\n\nFirst, they can contain data.\nSecond, they can have behaviors, frequently in relation to the data they contain.\n\nData types and data structures are kinds of objects.",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python Object Types</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/M02-Exercises.html",
    "href": "notebooks/M02_BasicPython/M02-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "Python Introduction",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/vals-vars-expressions-statements.html",
    "href": "notebooks/M03_ControlStructures/vals-vars-expressions-statements.html",
    "title": "Values, Variables, Expressions, and Statements",
    "section": "",
    "text": "Definitions",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Values, Variables, Expressions, and Statements</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/vals-vars-expressions-statements.html#definitions",
    "href": "notebooks/M03_ControlStructures/vals-vars-expressions-statements.html#definitions",
    "title": "Values, Variables, Expressions, and Statements",
    "section": "",
    "text": "Values: Raw data elements represented in a program, e.g. numbers and strings.\nVariables: Names to which values are assigned.\nExpressions: Combinations of values, variables, operators, functions, and other expressions that evaluate to a value.\nStatements: Groupings of expressions that produce some result. Statements do things.\nBlocks: Groupings of statements into functional chunks of code, such as a control block or a function.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Values, Variables, Expressions, and Statements</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/vals-vars-expressions-statements.html#statement-types",
    "href": "notebooks/M03_ControlStructures/vals-vars-expressions-statements.html#statement-types",
    "title": "Values, Variables, Expressions, and Statements",
    "section": "Statement Types",
    "text": "Statement Types\nSee Statement Types in Lutz.",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Values, Variables, Expressions, and Statements</span>"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/M03-Exercises.html",
    "href": "notebooks/M03_ControlStructures/M03-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "Python Control Structures",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/M04-Exercises.html",
    "href": "notebooks/M04_PythonFunctions/M04-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "Python Functions",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/M05-Exercises.html",
    "href": "notebooks/M05_NumPy/M05-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "Python NumPy",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/M06-Exercises.html",
    "href": "notebooks/M06_Pandas/M06-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "Python Pandas",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/M10-Exercises.html",
    "href": "notebooks/M10_RBasics/M10-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "R Introduction",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/M11-Exercises.html",
    "href": "notebooks/M11_RDplyr/M11-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "R Dplyr",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/M12-Exercises.html",
    "href": "notebooks/M12_RViz/M12-Exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Click on the link below to open a set of exerices for this module.\nThese exercises are designed to give you practice implementing the ideas covered.\nThese exercises are in the form of a slide show that functions as a set of prompts.\nTo peform the exercises, advance to a slide with a prompt and attempt to perform the task asked.\nWhen you are ready to see the solution, navigate to the slide below.\nNote that the slide show is in Reveal.js. To navigate the Reveal.js slide deck, you can use the following keyboard shortcuts:\n\nPress the right arrow key (→) to move to the next slide.\nPress the left arrow key (←) to move to the previous slide.\nPress the down arrow key (↓) to move to the next vertical slide.\nPress the up arrow key (↑) to move to the previous vertical slide.\nPress the ‘Home’ key to go to the first slide.\nPress the ‘End’ key to go to the last slide.\nPress the ‘Esc’ key to toggle the overview mode.\n\nYou can also use the navigation widget in the lower right corner of the screen to navigate through the slides.\nExercises",
    "crumbs": [
      "R Visualization",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>Exercises</span>"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/m02-intro.html",
    "href": "notebooks/M02_BasicPython/m02-intro.html",
    "title": "Python Introduction",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "Python Introduction"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/m02-intro.html#topics",
    "href": "notebooks/M02_BasicPython/m02-intro.html#topics",
    "title": "Python Introduction",
    "section": "",
    "text": "Running Python code\nPython’s basic data types\nPython’s primary operators associated with each data type\nPython’s built-in data structures",
    "crumbs": [
      "Python Introduction"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/m02-intro.html#suggested-readings",
    "href": "notebooks/M02_BasicPython/m02-intro.html#suggested-readings",
    "title": "Python Introduction",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nKatz and Katz 2019, Section 1, Preparing the Workspace\nLutz, Learning Python, Part I: Getting Started, Chapter 2\nLutz, Learning Python, Part I: Getting Started, Chapter 3\nLutz, Learning Python, Part II: Types and Operations, Chapters 4–9\nKatz and Katz 2019, Section 1, First Steps in Coding - Variables and Data Types\nBuilt-in Types (Official)\nPython Data Types (GFG)\nPython Operators (W3S)\nImmutable vs Mutable Data Types in Python (Medium)",
    "crumbs": [
      "Python Introduction"
    ]
  },
  {
    "objectID": "notebooks/M02_BasicPython/m02-intro.html#videos",
    "href": "notebooks/M02_BasicPython/m02-intro.html#videos",
    "title": "Python Introduction",
    "section": "Videos",
    "text": "Videos\n\nData and Code\n\n\n\n\n\nData Types and Structures\n\n\n\n\n\nData Types, Literals, and Variables\n\n\n\n\n\nOperators and Expressions\n\n\n\n\n\nNumbers\n\n\n\n\n\nStrings\n\n\n\n\n\nData Structures\n\n\n\n\n\nAside on Immutables",
    "crumbs": [
      "Python Introduction"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/m03-intro.html",
    "href": "notebooks/M03_ControlStructures/m03-intro.html",
    "title": "Python Control Structures",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "Python Control Structures"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/m03-intro.html#topics",
    "href": "notebooks/M03_ControlStructures/m03-intro.html#topics",
    "title": "Python Control Structures",
    "section": "",
    "text": "More on Statements and Syntax\nControl Structures and Loops\nConditional Logic\nIterators\nComprehensions",
    "crumbs": [
      "Python Control Structures"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/m03-intro.html#suggested-readings",
    "href": "notebooks/M03_ControlStructures/m03-intro.html#suggested-readings",
    "title": "Python Control Structures",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nLutz, 2019, Part III, Chapter 10. Introducing Python Statements\nLutz, 2019, Part III, Chapter 11. Assignments, Expressions, and Prints\n\nRead only up to and including “The Python 3.X print Function.”\n\nLutz, 2019, Part III, Chapter 12. if Tests and Syntax Rules\nLutz, 2019, Part III, Chapter 13. while and for Loops\nLutz, 2019, Part III, Chapter 14. Iterations and Comprehensions\nLutz, 2019, Part III, Chapter 15: The Documentations Interlude\nVariables, Expressions, Statements, Types (Python Notes)\nMore Control Flow Tools (Python Docs)\nIf … Then (W3S)\nIterators (GFG)",
    "crumbs": [
      "Python Control Structures"
    ]
  },
  {
    "objectID": "notebooks/M03_ControlStructures/m03-intro.html#videos",
    "href": "notebooks/M03_ControlStructures/m03-intro.html#videos",
    "title": "Python Control Structures",
    "section": "Videos",
    "text": "Videos\n\nControl Structures\n\n\n\n\n\nIterables and Iterators\n\n\n\n\n\nComprehensions\n\n\n\n\n\nNested Comprehensions",
    "crumbs": [
      "Python Control Structures"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/m04-intro.html",
    "href": "notebooks/M04_PythonFunctions/m04-intro.html",
    "title": "Python Functions",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "Python Functions"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/m04-intro.html#topics",
    "href": "notebooks/M04_PythonFunctions/m04-intro.html#topics",
    "title": "Python Functions",
    "section": "",
    "text": "Built-in functions\nUser-defined functions\nVariable scope\nLambda functions\nDesign of functions\nRecursion",
    "crumbs": [
      "Python Functions"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/m04-intro.html#suggested-readings",
    "href": "notebooks/M04_PythonFunctions/m04-intro.html#suggested-readings",
    "title": "Python Functions",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nLutz 2019, Part IV, Chapter 16: Function Basics\nLutz 2019, Part IV, Chapter 17: Scopes\n\nNon-local is for advanced users.\n\nLutz 2019, Part IV, Chapter 18. Arguments\nLutz 2019, Part IV, Chapter 19: Advanced Function Topics\nMcKinney, 2023, Python for Data Analysis, “3.2: Functions”\nFunctions (W3S)\nGlobal and Local Variables (GFG)\nLambda Functions (Real Python)",
    "crumbs": [
      "Python Functions"
    ]
  },
  {
    "objectID": "notebooks/M04_PythonFunctions/m04-intro.html#videos",
    "href": "notebooks/M04_PythonFunctions/m04-intro.html#videos",
    "title": "Python Functions",
    "section": "Videos",
    "text": "Videos\n\nFunctions\n\n\n\n\n\nImporting\n\n\n\n\n\nLambda Functions\n\n\n\n\n\nRecursive Functions\n\n\n\n\n\nScope\n\n\n\n\n\nFunction Groups",
    "crumbs": [
      "Python Functions"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/m05-intro.html",
    "href": "notebooks/M05_NumPy/m05-intro.html",
    "title": "Python NumPy",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "Python NumPy"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/m05-intro.html#topics",
    "href": "notebooks/M05_NumPy/m05-intro.html#topics",
    "title": "Python NumPy",
    "section": "",
    "text": "Numpy and its role in the Python data science ecosystem\nNumpy Arrays\nArray indexing, slicing, and broadcasting\nAggregation\nTiming the difference between NumPy and plain old Python",
    "crumbs": [
      "Python NumPy"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/m05-intro.html#suggested-readings",
    "href": "notebooks/M05_NumPy/m05-intro.html#suggested-readings",
    "title": "Python NumPy",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nMcKinney 2023, Chapter 4: Numpy Basics\nMcKinney 2023, Appendix A. Advanced NumPy: A.3 Broadcasting\nNumPy for Beginners (Official)",
    "crumbs": [
      "Python NumPy"
    ]
  },
  {
    "objectID": "notebooks/M05_NumPy/m05-intro.html#videos",
    "href": "notebooks/M05_NumPy/m05-intro.html#videos",
    "title": "Python NumPy",
    "section": "Videos",
    "text": "Videos\n\nTiming\n\n\n\n\n\nNumPy Design\n\n\n\n\n\nNumPy Indexing\n\n\n\n\n\nNumPy Operations\n\n\n\n\n\nNumPy Functions",
    "crumbs": [
      "Python NumPy"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/m06-intro.html",
    "href": "notebooks/M06_Pandas/m06-intro.html",
    "title": "Python Pandas",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "Python Pandas"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/m06-intro.html#topics",
    "href": "notebooks/M06_Pandas/m06-intro.html#topics",
    "title": "Python Pandas",
    "section": "",
    "text": "Introduce Pandas and its relationship to NumPy\nUnderstand difference between Series and DataFrames\nUnderstand role of indexes in Pandas\nReview fundamental methods in Pandas",
    "crumbs": [
      "Python Pandas"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/m06-intro.html#suggested-readings",
    "href": "notebooks/M06_Pandas/m06-intro.html#suggested-readings",
    "title": "Python Pandas",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nMcKinney 2023, Chapter 5: Getting Started with Pandas\nGetting Started in Pandas (Official)",
    "crumbs": [
      "Python Pandas"
    ]
  },
  {
    "objectID": "notebooks/M06_Pandas/m06-intro.html#videos",
    "href": "notebooks/M06_Pandas/m06-intro.html#videos",
    "title": "Python Pandas",
    "section": "Videos",
    "text": "Videos\n\nIntroducing Pandas\n\n\n\n\n\nExploring Pandas\n\n\n\n\n\nDiving Deeper Into Pandas",
    "crumbs": [
      "Python Pandas"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/m10-intro.html",
    "href": "notebooks/M10_RBasics/m10-intro.html",
    "title": "R Introduction",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "R Introduction"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/m10-intro.html#topics",
    "href": "notebooks/M10_RBasics/m10-intro.html#topics",
    "title": "R Introduction",
    "section": "",
    "text": "Present R basics — syntax, data types, and operators\nPresent R data structures – vectors, lists, matrices, and data frames\nCreate a function in R, and use it in a program",
    "crumbs": [
      "R Introduction"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/m10-intro.html#suggested-readings",
    "href": "notebooks/M10_RBasics/m10-intro.html#suggested-readings",
    "title": "R Introduction",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nW3Schools R Tutorial\nW3Schools R Data Structures\nYau, R Tutorial, “R Introduction”",
    "crumbs": [
      "R Introduction"
    ]
  },
  {
    "objectID": "notebooks/M10_RBasics/m10-intro.html#videos",
    "href": "notebooks/M10_RBasics/m10-intro.html#videos",
    "title": "R Introduction",
    "section": "Videos",
    "text": "Videos\n\nIntroducing R\n\n\n\n\n\nR Data Types and Operators\n\n\n\n\n\nR Data Structures\n\n\n\n\n\nR Factors\n\n\n\n\n\nR Data Frames\n\n\n\n\n\nR Control Structures\n\n\n\n\n\nR Functions",
    "crumbs": [
      "R Introduction"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/m11-intro.html",
    "href": "notebooks/M11_RDplyr/m11-intro.html",
    "title": "R Dplyr",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "R Dplyr"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/m11-intro.html#topics",
    "href": "notebooks/M11_RDplyr/m11-intro.html#topics",
    "title": "R Dplyr",
    "section": "",
    "text": "The Tidyverse\nTibbles, a lightweight version of data frames\nData transformations using dplyr verbs",
    "crumbs": [
      "R Dplyr"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/m11-intro.html#suggested-readings",
    "href": "notebooks/M11_RDplyr/m11-intro.html#suggested-readings",
    "title": "R Dplyr",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nRFDS Explore 5 Data Transformation\nRDFS Wrangle 10 Tibbles\nRDFS Wrangle 11 Data Import\nRDFS Wrangle 12 Tidy data\nPeng, 2022, “Managing Data Frames with the dplyr package”",
    "crumbs": [
      "R Dplyr"
    ]
  },
  {
    "objectID": "notebooks/M11_RDplyr/m11-intro.html#videos",
    "href": "notebooks/M11_RDplyr/m11-intro.html#videos",
    "title": "R Dplyr",
    "section": "Videos",
    "text": "Videos\n\nThe Tidyverse and Tibbles\n\n\n\n\n\nDplyr",
    "crumbs": [
      "R Dplyr"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/m12-intro.html",
    "href": "notebooks/M12_RViz/m12-intro.html",
    "title": "R Visualization",
    "section": "",
    "text": "Topics",
    "crumbs": [
      "R Visualization"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/m12-intro.html#topics",
    "href": "notebooks/M12_RViz/m12-intro.html#topics",
    "title": "R Visualization",
    "section": "",
    "text": "R’s basic visualization tools\nGGPlot2\nRMarkown",
    "crumbs": [
      "R Visualization"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/m12-intro.html#suggested-readings",
    "href": "notebooks/M12_RViz/m12-intro.html#suggested-readings",
    "title": "R Visualization",
    "section": "Suggested Readings",
    "text": "Suggested Readings\n\nW3Schools R Graphics\nRFDS Explore 3 Data Visualization\n\nggplot2\n\nRDFS Communicate 27 R Markdown\nRDFS Communicate 28 Graphics for Communication\nggplot2 (Tidyverse)\nThe Complete ggplot2 Tutorial (r-statitics.co)\nR Markdown (RStudio)\nOverview (RStudio)\nIndex of Pages (RStudio)\nknitr (Yihui Xie)\nR Markdown: the Definitive Guide (Yihui Xie, J. J. Allaire, Garrett Grolemund)\nR Markdown Cookbook (Yihui Xie, Christophe Dervieux, Emily Riederer)\nGetting Started with R Markdown — Guide and Cheatsheet (Dataquest)\nGallery (RStudio)",
    "crumbs": [
      "R Visualization"
    ]
  },
  {
    "objectID": "notebooks/M12_RViz/m12-intro.html#videos",
    "href": "notebooks/M12_RViz/m12-intro.html#videos",
    "title": "R Visualization",
    "section": "Videos",
    "text": "Videos\n\nGGPlot and the Grammar of Graphics\n\n\n\n\n\nGetting Started with GGPlot\n\n\n\n\n\nR Markdown\n\n\n\n\n\nPlotly and GGPlotly\n\n\n\n\n\nGGPlot in Python",
    "crumbs": [
      "R Visualization"
    ]
  }
]